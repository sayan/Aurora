<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>logistic_regression_11</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<script src="../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap-5d3fd86dc4559d58e199c8cc4a79ed5b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<section id="question-12.-logistic-regression-models-produce-probabilities-for-binary-outcomes.-how-would-you-calibrate-these-probabilities-if-you-suspect-that-they-are-poorly-calibrated-and-why-is-calibration-important" class="level2">
<h2 class="anchored" data-anchor-id="question-12.-logistic-regression-models-produce-probabilities-for-binary-outcomes.-how-would-you-calibrate-these-probabilities-if-you-suspect-that-they-are-poorly-calibrated-and-why-is-calibration-important">Question: 12. Logistic regression models produce probabilities for binary outcomes. How would you calibrate these probabilities if you suspect that they are poorly calibrated, and why is calibration important?</h2>
<p><strong>Best Answer</strong></p>
<p>Logistic regression, while providing probabilities, doesn’t always guarantee well-calibrated probabilities. That is, a model predicting a probability of 0.8 for an event doesn’t necessarily mean the event will occur 80% of the time in reality. Calibration aims to correct this discrepancy, aligning predicted probabilities with observed frequencies.</p>
<p><strong>Importance of Calibration</strong></p>
<ul>
<li><strong>Decision-Making:</strong> Well-calibrated probabilities are crucial for making informed decisions. If a model predicts a 90% chance of a customer churning, a business needs to trust that this prediction reflects reality to allocate resources effectively for retention. Poorly calibrated probabilities can lead to sub-optimal or even harmful decisions. For example, overestimating risk could lead to unnecessary interventions, while underestimating it could lead to missed opportunities to mitigate threats.</li>
<li><strong>Risk Assessment:</strong> In domains like finance or medicine, accurate risk assessment is paramount. An under-calibrated model might underestimate risk, leading to inadequate safety measures. Conversely, an over-calibrated model might overestimate risk, leading to overly conservative actions and missed opportunities.</li>
<li><strong>Interpretability and Trust:</strong> When probabilities are well-calibrated, users are more likely to trust and understand the model’s outputs. This enhances the overall user experience and facilitates adoption, especially in high-stakes scenarios.</li>
<li><strong>Combining with other models or decision systems:</strong> Many decision systems use model outputs as inputs. If the outputs are poorly calibrated then downstream systems will make worse decisions.</li>
</ul>
<p><strong>Detecting Poor Calibration</strong></p>
<ul>
<li><p><strong>Calibration Curve (Reliability Diagram):</strong> This plot visualizes the relationship between predicted probabilities and observed frequencies. We bin the predicted probabilities and plot the mean predicted probability against the observed fraction of positives in each bin. A well-calibrated model’s curve should ideally follow the diagonal <span class="math inline">\(y=x\)</span>. Deviations from the diagonal indicate miscalibration.</p></li>
<li><p><strong>Brier Score:</strong> The Brier score measures the mean squared difference between predicted probabilities and the actual outcomes (0 or 1). Lower Brier scores indicate better calibration.</p>
<p><span class="math display">\[
\text{Brier Score} = \frac{1}{N} \sum_{i=1}^{N} (p_i - o_i)^2
\]</span></p>
<p>where <span class="math inline">\(p_i\)</span> is the predicted probability for the <span class="math inline">\(i\)</span>-th instance, <span class="math inline">\(o_i\)</span> is the actual outcome (0 or 1), and <span class="math inline">\(N\)</span> is the number of instances.</p></li>
<li><p><strong>Hosmer-Lemeshow Test:</strong> This statistical test assesses whether the observed event rates match expected event rates in subgroups of the dataset. A statistically significant result (typically p &lt; 0.05) suggests poor calibration.</p></li>
</ul>
<p><strong>Calibration Techniques</strong></p>
<p>Several techniques can be used to calibrate probabilities:</p>
<ol type="1">
<li><strong>Platt Scaling:</strong>
<ul>
<li><p><strong>Concept:</strong> Fits a logistic regression model to the outputs of the original model. It learns parameters <em>A</em> and <em>B</em> to transform the original probabilities.</p></li>
<li><p><strong>Formula:</strong> <span class="math display">\[
P_{\text{calibrated}}(y=1|x) = \frac{1}{1 + \exp(A \cdot f(x) + B)}
\]</span> where <span class="math inline">\(f(x)\)</span> is the original model’s predicted probability for instance <em>x</em>, and <em>A</em> and <em>B</em> are parameters learned via maximum likelihood estimation on a validation set.</p></li>
<li><p><strong>Advantages:</strong> Simple to implement and computationally efficient.</p></li>
<li><p><strong>Disadvantages:</strong> Can be less effective when the original model is severely miscalibrated. Assumes a sigmoidal shape to the calibration curve, which might not always be appropriate.</p></li>
</ul></li>
<li><strong>Isotonic Regression:</strong>
<ul>
<li><p><strong>Concept:</strong> A non-parametric approach that finds a non-decreasing function that best fits the original probabilities to the observed outcomes. It ensures that the calibrated probabilities are monotonically increasing with the original probabilities.</p></li>
<li><p><strong>Advantages:</strong> More flexible than Platt scaling, especially for severely miscalibrated models. Makes no assumptions about the shape of the calibration curve.</p></li>
<li><p><strong>Disadvantages:</strong> Can be prone to overfitting if the validation set is small. May produce piecewise constant calibrated probabilities. Computationally more expensive than Platt scaling.</p></li>
<li><p><strong>Implementation:</strong> Solves the following optimization problem:</p>
<p><span class="math display">\[
\min_{g} \sum_{i=1}^{N} (g(x_i) - y_i)^2
\]</span></p>
<p>subject to <span class="math inline">\(g(x_i) \leq g(x_j)\)</span> for all <span class="math inline">\(x_i \leq x_j\)</span>, where <span class="math inline">\(g\)</span> is the calibrated probability, <span class="math inline">\(x_i\)</span> is the original predicted probability, and <span class="math inline">\(y_i\)</span> is the actual outcome.</p></li>
</ul></li>
<li><strong>Beta Calibration:</strong>
<ul>
<li><strong>Concept:</strong> Fits a Beta distribution to the predicted probabilities. The Beta distribution’s parameters are then optimized to minimize a loss function that measures the discrepancy between the predicted and observed outcomes.</li>
<li><strong>Advantages:</strong> More flexible than Platt scaling and better suited for situations where the calibration curve is non-monotonic.</li>
<li><strong>Disadvantages:</strong> Can be more complex to implement and computationally expensive.</li>
<li><strong>Formula:</strong> <span class="math display">\[
P_{\text{calibrated}}(y=1|x) = \text{Beta}(f(x); \alpha, \beta)
\]</span> where <span class="math inline">\(f(x)\)</span> is the original model’s predicted probability for instance <em>x</em>, and <span class="math inline">\(\alpha\)</span> and <span class="math inline">\(\beta\)</span> are the parameters of the Beta distribution.</li>
</ul></li>
<li><strong>Temperature Scaling:</strong>
<ul>
<li>A simplified version of Platt scaling, specifically for neural networks, where only one parameter (the temperature <em>T</em>) is learned. This parameter is used to divide the logits before the softmax function is applied.</li>
<li><strong>Formula:</strong> <span class="math display">\[
P_{\text{calibrated}}(y=1|x) = \text{Softmax}(\frac{z}{T})
\]</span> where <span class="math inline">\(z\)</span> are the logits of the model and <span class="math inline">\(T\)</span> is the temperature parameter.</li>
</ul></li>
</ol>
<p><strong>Implementation Considerations</strong></p>
<ul>
<li><strong>Validation Set:</strong> Calibration should always be performed on a separate validation set, <em>distinct</em> from the training set and the test set. Using the training set for calibration will lead to overfitting and biased results. The validation set should be representative of the data the model will encounter in production.</li>
<li><strong>Choice of Technique:</strong> The choice of calibration technique depends on the characteristics of the original model, the degree of miscalibration, and the size of the validation set. Platt scaling is a good starting point for simple miscalibration, while isotonic regression or Beta Calibration are better suited for more complex scenarios.</li>
<li><strong>Regular Monitoring:</strong> Calibration can drift over time as the data distribution changes. Therefore, it’s important to regularly monitor the model’s calibration and recalibrate as needed. Setting up automated monitoring systems that track calibration metrics (e.g., Brier score, calibration curves) can help detect drift early on.</li>
</ul>
<p>In summary, calibrating logistic regression probabilities is essential for reliable decision-making, accurate risk assessment, and improved interpretability. Techniques like Platt scaling, isotonic regression and Beta Calibration can be applied using a validation set to align predicted probabilities with observed frequencies. Regular monitoring and recalibration are crucial to maintain the model’s calibration over time.</p>
<p><strong>How to Narrate</strong></p>
<ol type="1">
<li><p><strong>Start with the definition:</strong> Begin by clearly defining what calibration means in the context of logistic regression: aligning predicted probabilities with observed frequencies.</p></li>
<li><p><strong>Emphasize the importance:</strong> Explain why calibration matters. Highlight the impact of miscalibrated probabilities on decision-making, risk assessment, and trust. Give concrete examples to illustrate the consequences of poor calibration in real-world scenarios (e.g., medical diagnosis, fraud detection). “Imagine a medical diagnosis system that predicts a 90% chance of a patient having a disease. If that probability isn’t well-calibrated, doctors might make incorrect treatment decisions.”</p></li>
<li><p><strong>Mention detection methods:</strong> Briefly describe how to detect poor calibration using calibration curves or the Brier score. For the calibration curve, say something like: “We can visualize calibration using a calibration curve, which plots predicted probabilities against observed frequencies. A well-calibrated model should have a curve close to the diagonal.” Avoid going into too much detail unless prompted.</p></li>
<li><p><strong>Introduce Calibration Techniques:</strong></p>
<ul>
<li>Start with Platt scaling as it is simpler: “One common method is Platt scaling, which fits a logistic regression model to the original model’s outputs to learn a transformation.”</li>
<li>Then, introduce Isotonic Regression: “For more complex miscalibration, we can use Isotonic Regression, a non-parametric method that finds a non-decreasing function to calibrate the probabilities.”</li>
<li>Beta Calibration: “Another option, Beta Calibration, fits a Beta distribution to the predicted probabilities for better calibration curves.”</li>
</ul></li>
<li><p><strong>Mathematical Explanation (If Required):</strong></p>
<ul>
<li>If the interviewer asks for more details on Platt scaling, provide the formula: “Platt scaling uses the formula: <span class="math inline">\(P_{calibrated}(y=1|x) = \frac{1}{1 + \exp(A \cdot f(x) + B)}\)</span>, where <em>f(x)</em> is the original model’s output, and <em>A</em> and <em>B</em> are learned parameters.” Explain that these parameters are learned using maximum likelihood estimation on a validation set.</li>
<li>For Isotonic regression, if asked, mention that it aims to minimize the squared difference between the calibrated probabilities and the true outcomes, subject to the constraint that the calibrated probabilities are non-decreasing. Avoid showing the full optimization problem unless explicitly asked.</li>
</ul></li>
<li><p><strong>Implementation Considerations:</strong></p>
<ul>
<li>Stress the importance of using a separate validation set for calibration: “It’s crucial to use a separate validation set for calibration to avoid overfitting and ensure unbiased results.”</li>
<li>Discuss the trade-offs between the different calibration techniques: “Platt scaling is simpler, but Isotonic Regression is more flexible for severe miscalibration.”</li>
<li>Emphasize the need for regular monitoring: “Calibration can drift over time, so it’s important to regularly monitor and recalibrate the model.”</li>
</ul></li>
<li><p><strong>Conclude Summarily:</strong> Reiterate the importance of calibration for building reliable and trustworthy models.</p></li>
</ol>
<p><strong>Communication Tips:</strong></p>
<ul>
<li><strong>Pace yourself:</strong> Don’t rush through the explanation. Give the interviewer time to process the information.</li>
<li><strong>Use clear language:</strong> Avoid jargon unless necessary. Explain complex concepts in simple terms.</li>
<li><strong>Check for understanding:</strong> Pause periodically and ask if the interviewer has any questions.</li>
<li><strong>Be flexible:</strong> Adapt your explanation based on the interviewer’s background and interests. If they are particularly interested in a specific technique, delve deeper into that area. If they seem less mathematically inclined, focus on the conceptual aspects.</li>
<li><strong>Project confidence:</strong> Speak clearly and confidently, demonstrating your expertise in the subject matter.</li>
<li><strong>Be Honest:</strong> If you do not know the answer, be honest and say that you are not familiar with the topic. Do not try to bluff your way through.</li>
</ul>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>