<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.41">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>scaling_laws_and_model_sizes_11</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../../">
<script src="../../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../site_libs/quarto-html/quarto-syntax-highlighting-48ffa3e5b9d089919c6712c39e5b00f2.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../site_libs/bootstrap/bootstrap-a37d0bf9d509de95c1ba4621f20add8c.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<section id="question-12.-looking-forward-what-are-some-promising-research-directions-or-methodologies-to-refine-scaling-laws-so-that-they-become-more-predictive-for-next-generation-models-and-diverse-application-domains" class="level2">
<h2 class="anchored" data-anchor-id="question-12.-looking-forward-what-are-some-promising-research-directions-or-methodologies-to-refine-scaling-laws-so-that-they-become-more-predictive-for-next-generation-models-and-diverse-application-domains">Question: 12. Looking forward, what are some promising research directions or methodologies to refine scaling laws so that they become more predictive for next-generation models and diverse application domains?</h2>
<p><strong>Best Answer</strong></p>
<p>Scaling laws have provided a valuable framework for understanding the relationship between model size, dataset size, and performance in deep learning. However, they are not perfect and often fall short when predicting the behavior of next-generation models or when applied to diverse application domains. Here are several promising research directions to refine scaling laws:</p>
<ul>
<li><p><strong>Adaptive Scaling Laws and Incorporating Architectural Innovations:</strong> Current scaling laws primarily focus on model size (number of parameters), dataset size, and compute as primary drivers of performance. Future research should focus on adaptive scaling laws that incorporate architectural innovations. Different architectures may have different scaling exponents or coefficients. For example, transformers, MLPs, and CNNs might exhibit different scaling behaviors. A more generalized form of a scaling law might look like this:</p>
<p><span class="math display">\[
\text{Performance} = f(\text{Model Size}, \text{Dataset Size}, \text{Compute}, \text{Architecture-Specific Parameters})
\]</span></p>
<p>Where “Architecture-Specific Parameters” could include factors like the number of attention heads in a transformer, the depth and width of the network, or the connectivity patterns. Furthermore, architectural innovations like Mixture-of-Experts (MoE) introduces sparsity that fundamentally alters scaling behavior. Scaling laws must account for the “effective” number of parameters, not just the total.</p></li>
<li><p><strong>Dynamic Data Regimes and Data Quality:</strong> Most scaling laws assume a static, well-curated dataset. However, real-world datasets are often dynamic, evolving over time, and contain varying levels of noise and bias. Research needs to explore how scaling laws change when models are trained on continuously updating data streams or datasets with varying levels of data quality. This requires incorporating metrics that quantify data quality and diversity into the scaling law formulation. For instance, the effective dataset size could be adjusted based on its information content or redundancy. A possible refinement:</p>
<p><span class="math display">\[
\text{Performance} = f(\text{Model Size}, \text{Effective Dataset Size}, \text{Compute})
\]</span></p>
<p>Where Effective Dataset Size accounts for data quality and redundancy.</p></li>
<li><p><strong>Integrating Theory with Empirical Studies: Addressing the Limitations of Power Laws:</strong> Current scaling laws are primarily empirical, derived from observing trends in model performance. There’s a need for more theoretical grounding to explain <em>why</em> these scaling laws exist and under what conditions they hold. Research should explore theoretical frameworks, such as information theory or statistical mechanics, to derive scaling laws from first principles. It’s important to test the assumption of power-law behavior. While power laws are convenient, they may not accurately represent the full spectrum of scaling behavior, especially at very large or very small scales. Saturation effects or phase transitions might occur, leading to deviations from power-law scaling. Exploring alternative functional forms, such as logarithmic or exponential relationships, might be more appropriate in certain scenarios.</p></li>
<li><p><strong>Transfer Learning and Fine-tuning:</strong> Scaling laws often focus on training from scratch. However, transfer learning and fine-tuning are common practices. Future research should investigate how scaling laws change when models are pre-trained on a large dataset and then fine-tuned on a smaller, task-specific dataset. The scaling behavior of the pre-training and fine-tuning stages may be different. The effectiveness of transfer learning can be related to the similarity between the pre-training and fine-tuning datasets. Metrics that quantify dataset similarity can be incorporated into scaling law predictions.</p></li>
<li><p><strong>Cross-Domain Applications and Generalization:</strong> Most scaling laws are derived from specific domains, such as natural language processing or computer vision. Research should explore how well these scaling laws generalize to other domains. It’s likely that different domains have different scaling exponents or coefficients due to variations in data complexity and task difficulty. This necessitates domain-specific scaling laws or a more universal scaling law that incorporates domain-specific parameters. Understanding the limits of generalization and identifying domain-invariant features that contribute to scaling laws are crucial.</p></li>
<li><p><strong>Meta-Learning and Automated Scaling Law Discovery:</strong> Meta-learning techniques can be used to automatically discover scaling laws from experimental data. By training a meta-model to predict the performance of different models trained on different datasets, we can identify the key factors that influence scaling behavior. This can lead to the discovery of new scaling laws that are more accurate and generalizable.</p></li>
<li><p><strong>Incorporating Computational Resources &amp; Efficiency:</strong> Current scaling laws often treat compute as a monolithic entity. Future research should differentiate between different types of compute (e.g., FLOPs, memory bandwidth, communication costs) and how they impact scaling. This is particularly important for distributed training, where communication costs can be a significant bottleneck. Exploring the trade-offs between compute, memory, and communication is crucial for optimizing the training process.</p></li>
</ul>
<p>In conclusion, refining scaling laws requires a multi-faceted approach that combines theoretical insights, empirical validation, and the development of more sophisticated models that account for architectural innovations, data dynamics, and domain-specific characteristics. This will enable us to build more predictive and reliable models for next-generation AI systems.</p>
<hr>
<p><strong>How to Narrate</strong></p>
<p>Here’s a step-by-step guide on how to articulate this answer in an interview:</p>
<ol type="1">
<li><strong>Start with a summary:</strong>
<ul>
<li>“Scaling laws provide a valuable framework for understanding the relationship between model size, dataset size, and performance. However, they’re not perfect, particularly when dealing with next-generation models or diverse application domains.”</li>
<li><em>Communication Tip:</em> Begin by acknowledging the value and limitations of existing scaling laws to set the stage.</li>
</ul></li>
<li><strong>Introduce Adaptive Scaling Laws:</strong>
<ul>
<li>“One promising direction is to develop adaptive scaling laws that incorporate architectural innovations. Current laws focus primarily on model size, dataset size, and compute. We need to account for the specific architectural choices.”</li>
<li>Present the generalized equation: “A more generalized form of a scaling law might look like this: [Performance = f(Model&nbsp;Size, Dataset&nbsp;Size, Compute, Architecture-Specific&nbsp;Parameters)]. Where Architecture-Specific Parameters could include factors like the number of attention heads in a transformer, the depth and width of the network, or the connectivity patterns.”</li>
<li>“For example, Mixture-of-Experts architectures introduce sparsity that requires accounting for the ‘effective’ number of parameters.”</li>
<li><em>Communication Tip:</em> Explain the concept of adaptive scaling laws in simple terms, highlighting the need to move beyond just model size and dataset size. Emphasize architectural importance. Don’t dive deep into every architectural detail.</li>
</ul></li>
<li><strong>Explain Dynamic Data Regimes and Data Quality:</strong>
<ul>
<li>“Another area for improvement is to address dynamic data regimes and data quality. Most scaling laws assume static, well-curated datasets, but real-world data is often noisy, biased, and evolving.”</li>
<li>“We need to incorporate metrics that quantify data quality and diversity into the scaling law formulation. For instance, the effective dataset size could be adjusted based on its information content or redundancy.”</li>
<li>Present the effective dataset equation: “A possible refinement: [Performance = f(Model&nbsp;Size, Effective&nbsp;Dataset&nbsp;Size, Compute)] where Effective Dataset Size accounts for data quality and redundancy.”</li>
<li><em>Communication Tip:</em> Focus on the practical relevance of data quality. Avoid getting bogged down in specific data quality metrics unless the interviewer asks.</li>
</ul></li>
<li><strong>Discuss Integrating Theory with Empirical Studies:</strong>
<ul>
<li>“It’s crucial to integrate theory with empirical studies. Current scaling laws are largely empirical. We need theoretical frameworks, such as information theory or statistical mechanics, to explain <em>why</em> these scaling laws exist.”</li>
<li>“It’s also important to test the assumption of power-law behavior. Saturation effects or phase transitions might lead to deviations from power-law scaling, suggesting alternative functional forms.”</li>
<li><em>Communication Tip:</em> This is a good point to demonstrate your understanding of the underlying assumptions and limitations.</li>
</ul></li>
<li><strong>Mention Transfer Learning and Fine-tuning:</strong>
<ul>
<li>“Scaling laws should also account for transfer learning and fine-tuning. The scaling behavior of the pre-training and fine-tuning stages may be different. The effectiveness of transfer learning can be related to the similarity between datasets.”</li>
<li><em>Communication Tip:</em> Keep it concise.</li>
</ul></li>
<li><strong>Highlight Cross-Domain Applications:</strong>
<ul>
<li>“We need to explore how well scaling laws generalize across different domains. It’s likely that different domains have different scaling exponents or coefficients due to variations in data complexity and task difficulty.”</li>
<li><em>Communication Tip:</em> Focus on the need for domain-specific considerations or a more universal scaling law.</li>
</ul></li>
<li><strong>Mention Meta-Learning and Automated Discovery:</strong>
<ul>
<li>“Meta-learning techniques can be used to automatically discover scaling laws from data, leading to more accurate and generalizable scaling laws.”</li>
<li><em>Communication Tip:</em> Briefly mention this as a forward-looking research direction.</li>
</ul></li>
<li><strong>Address Computational Resources &amp; Efficiency:</strong>
<ul>
<li>“Current scaling laws often treat compute as a monolithic entity. Future research should differentiate between different types of compute (e.g., FLOPs, memory bandwidth, communication costs) and how they impact scaling. This is particularly important for distributed training.”</li>
<li><em>Communication Tip:</em> Briefly mention this as a forward-looking research direction.</li>
</ul></li>
<li><strong>Conclude with a summary:</strong>
<ul>
<li>“In conclusion, refining scaling laws requires a multi-faceted approach that combines theoretical insights, empirical validation, and more sophisticated models that account for architectural innovations, data dynamics, and domain-specific characteristics. This will lead to more predictive and reliable AI systems.”</li>
<li><em>Communication Tip:</em> End on a positive and forward-looking note.</li>
</ul></li>
</ol>
<p><em>Overall Communication Tips:</em></p>
<ul>
<li><em>Pacing:</em> Speak clearly and at a moderate pace. Allow the interviewer time to process the information.</li>
<li><em>Engagement:</em> Maintain eye contact and show enthusiasm for the topic.</li>
<li><em>Adaptability:</em> Pay attention to the interviewer’s body language and adjust your answer accordingly. If they seem confused, slow down and provide more context. If they seem particularly interested in one aspect, elaborate on that.</li>
<li><em>Don’t be afraid to say “I don’t know”:</em> If you are asked about a very specific or niche area that you are not familiar with, it is better to be honest and say that you don’t know the answer, rather than trying to bluff your way through it. You can add that you would be interested in learning more about it.</li>
</ul>
<p>By following these tips, you can effectively communicate your knowledge and expertise on scaling laws while engaging the interviewer in a meaningful conversation.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>