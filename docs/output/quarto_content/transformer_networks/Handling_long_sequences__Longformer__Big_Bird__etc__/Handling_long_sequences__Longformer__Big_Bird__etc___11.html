<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>handling_long_sequences__longformer__big_bird__etc___11</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../../">
<script src="../../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../site_libs/bootstrap/bootstrap-5d3fd86dc4559d58e199c8cc4a79ed5b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<section id="question-12.-explain-how-you-would-approach-an-experiment-to-compare-the-performance-of-a-traditional-transformer-longformer-and-big-bird-on-a-long-document-classification-task.-what-metrics-and-evaluation-techniques-would-you-employ" class="level2">
<h2 class="anchored" data-anchor-id="question-12.-explain-how-you-would-approach-an-experiment-to-compare-the-performance-of-a-traditional-transformer-longformer-and-big-bird-on-a-long-document-classification-task.-what-metrics-and-evaluation-techniques-would-you-employ">Question: 12. Explain how you would approach an experiment to compare the performance of a traditional transformer, Longformer, and Big Bird on a long-document classification task. What metrics and evaluation techniques would you employ?</h2>
<p><strong>Best Answer</strong></p>
<p>To rigorously compare the performance of a traditional Transformer, Longformer, and Big Bird on a long-document classification task, a well-designed experimental setup is crucial. This setup would involve data preparation, model configuration, training/validation/test splits, appropriate metrics, and techniques for robust evaluation. Here’s a detailed approach:</p>
<p><strong>1. Dataset Selection and Preprocessing:</strong></p>
<ul>
<li><strong>Dataset Selection:</strong> Choose a suitable long-document classification dataset. Examples include:
<ul>
<li><strong>IMDB Reviews:</strong> While each review might not be extremely long, concatenation can create artificially long documents.</li>
<li><strong>Amazon Reviews:</strong> Similar to IMDB, suitable for sentiment analysis or product classification.</li>
<li><strong>PubMed Abstracts/Full Texts:</strong> Scientific literature offers genuinely long documents for tasks like topic classification.</li>
<li><strong>Legal Documents:</strong> Datasets containing legal texts allow for classification tasks based on document type or legal issue.</li>
</ul></li>
<li><strong>Data Preprocessing:</strong>
<ul>
<li><strong>Tokenization:</strong> Use a suitable tokenizer (e.g., SentencePiece, Byte-Pair Encoding) that is consistent across all models to ensure a fair comparison.</li>
<li><strong>Truncation/Padding:</strong> Since Transformers have limitations on sequence length, determine the maximum sequence length based on the chosen architecture’s capabilities. Pad shorter sequences and truncate longer sequences. The traditional transformer will require significant truncation compared to Longformer and BigBird, which is an important factor in the comparison.</li>
<li><strong>Vocabulary:</strong> Create a vocabulary that captures relevant information from the text. It’s ideal to use a pre-trained vocabulary if leveraging pre-trained models as it saves training time.</li>
<li><strong>Splitting:</strong> Divide the dataset into training, validation, and test sets (e.g., 70/15/15 split). Stratify the split to maintain class distribution across the sets.</li>
</ul></li>
</ul>
<p><strong>2. Model Configuration and Hyperparameter Tuning:</strong></p>
<ul>
<li><p><strong>Model Selection:</strong> Implement or leverage pre-trained versions of the following models:</p>
<ul>
<li><strong>Traditional Transformer:</strong> Standard encoder-decoder transformer architecture.</li>
<li><strong>Longformer:</strong> Incorporates sparse attention mechanisms (e.g., sliding window, global attention) to handle longer sequences.</li>
<li><strong>Big Bird:</strong> Uses a combination of random, global, and windowed attention to reduce computational complexity.</li>
</ul></li>
<li><p><strong>Hyperparameter Tuning:</strong> This is critical for a fair comparison. Use the validation set to optimize hyperparameters for each model independently. Some crucial hyperparameters include:</p>
<ul>
<li><strong>Learning Rate:</strong> Crucial for convergence. Use techniques like learning rate scheduling (discussed later).</li>
<li><strong>Batch Size:</strong> Adjust based on memory constraints. Smaller batch sizes may be necessary for Transformers due to memory limitations.</li>
<li><strong>Number of Layers:</strong> Depth of the model.</li>
<li><strong>Hidden Size:</strong> Dimensionality of the hidden states.</li>
<li><strong>Attention Heads:</strong> Number of attention heads in multi-head attention.</li>
<li><strong>Dropout Rate:</strong> Regularization to prevent overfitting.</li>
<li><strong>Attention Type Specific Hyperparameters:</strong> For Longformer, configure window size, global attention locations. For Big Bird, configure random attention.</li>
</ul></li>
<li><p><strong>Learning Rate Scheduling:</strong> Apply learning rate scheduling to improve training dynamics. Common techniques include:</p>
<ul>
<li><strong>Warm-up and Decay:</strong> Initially increase the learning rate linearly (warm-up) followed by a decay (e.g., cosine decay, inverse square root decay). This is particularly useful for Transformer-based models. The equation for a simple inverse square root decay is:</li>
</ul>
<p><span class="math display">\[
\text{lr}(t) = \frac{\text{initial_lr}}{\sqrt{t}}
\]</span></p>
<p>where <span class="math inline">\(t\)</span> is the training step.</p>
<ul>
<li><p><strong>Cyclical Learning Rates:</strong> Vary the learning rate cyclically between lower and upper bounds.</p></li>
<li><p><strong>ReduceLROnPlateau:</strong> Monitor a validation metric (e.g., validation loss) and reduce the learning rate when the metric plateaus.</p></li>
</ul></li>
<li><p><strong>Regularization:</strong> Apply L1 or L2 regularization to prevent overfitting. The cost function with L2 regularization can be written as: <span class="math display">\[
J(\theta) = \frac{1}{N} \sum_{i=1}^{N} L(y_i, \hat{y}_i) + \frac{\lambda}{2N} ||\theta||^2
\]</span> where <span class="math inline">\(J(\theta)\)</span> is the cost function, <span class="math inline">\(L\)</span> is the loss function, <span class="math inline">\(y_i\)</span> is the true label, <span class="math inline">\(\hat{y}_i\)</span> is the predicted label, <span class="math inline">\(\theta\)</span> represents model parameters, <span class="math inline">\(\lambda\)</span> is the regularization strength, and <span class="math inline">\(N\)</span> is the number of training examples.</p></li>
</ul>
<p><strong>3. Training and Validation:</strong></p>
<ul>
<li><strong>Training Loop:</strong> Train each model using the training data. Monitor the validation loss/metric during training to track progress and detect overfitting. Use early stopping based on the validation metric to prevent overfitting.</li>
<li><strong>Gradient Clipping:</strong> Clip gradients to prevent exploding gradients, which can be an issue with deep Transformer models.</li>
</ul>
<p><strong>4. Evaluation Metrics:</strong></p>
<ul>
<li><strong>Accuracy:</strong> The most straightforward metric, measuring the percentage of correctly classified documents. <span class="math display">\[
\text{Accuracy} = \frac{\text{Number of Correct Predictions}}{\text{Total Number of Predictions}}
\]</span></li>
<li><strong>Precision, Recall, and F1-score:</strong> These are especially important when dealing with imbalanced datasets. <span class="math display">\[
\text{Precision} = \frac{\text{True Positives}}{\text{True Positives + False Positives}}
\]</span> <span class="math display">\[
\text{Recall} = \frac{\text{True Positives}}{\text{True Positives + False Negatives}}
\]</span> <span class="math display">\[
\text{F1-score} = 2 \cdot \frac{\text{Precision} \cdot \text{Recall}}{\text{Precision + Recall}}
\]</span></li>
<li><strong>Area Under the Receiver Operating Characteristic Curve (AUC-ROC):</strong> Useful for binary classification problems, providing a measure of the model’s ability to discriminate between classes.</li>
<li><strong>Macro/Micro Averaging:</strong> When dealing with multi-class classification, calculate macro-averaged (average of F1 scores for each class) and micro-averaged (global F1 score) metrics to get a comprehensive view.</li>
<li><strong>Computational Efficiency:</strong>
<ul>
<li><strong>Inference Time:</strong> Measure the time it takes for each model to classify a single document or a batch of documents.</li>
<li><strong>Memory Usage:</strong> Track the memory footprint of each model during training and inference.</li>
</ul></li>
<li><strong>Perplexity (Optional):</strong> If the classification task involves generative aspects or language modeling pretraining, perplexity can be a relevant metric.</li>
</ul>
<p><strong>5. Evaluation Techniques:</strong></p>
<ul>
<li><strong>Statistical Significance Testing:</strong> Use statistical tests (e.g., t-tests, ANOVA) to determine if the differences in performance between the models are statistically significant. Account for multiple hypothesis testing (e.g., Bonferroni correction).</li>
<li><strong>Confidence Intervals:</strong> Calculate confidence intervals for the evaluation metrics to provide a range of plausible values for the model’s performance.</li>
<li><strong>Ablation Studies:</strong> Conduct ablation studies to analyze the impact of specific components or hyperparameters on the model’s performance. For example, remove global attention from Longformer and observe the performance change.</li>
<li><strong>Attention Visualization:</strong> Visualize attention weights to understand which parts of the document each model focuses on. This can provide insights into the model’s decision-making process. Tools like <code>BertViz</code> can be adapted.</li>
<li><strong>Error Analysis:</strong> Manually examine misclassified documents to identify patterns or biases in the model’s predictions. This can reveal areas where the model needs improvement.</li>
</ul>
<p><strong>6. Implementation Details and Considerations:</strong></p>
<ul>
<li><strong>Hardware:</strong> Use consistent hardware (GPUs, CPUs, memory) for all experiments.</li>
<li><strong>Software:</strong> Use the same versions of libraries (e.g., PyTorch, TensorFlow, Transformers).</li>
<li><strong>Reproducibility:</strong> Document all steps of the experiment, including data preprocessing, model configuration, hyperparameter tuning, and evaluation. Use random seeds to ensure reproducibility.</li>
<li><strong>Code Optimization:</strong> Optimize code for efficiency (e.g., using optimized attention implementations, minimizing data transfers).</li>
<li><strong>Scalability:</strong> Consider the scalability of each model to larger datasets and longer documents.</li>
</ul>
<p><strong>7. Reporting:</strong></p>
<ul>
<li><strong>Comprehensive Reporting:</strong> Document all aspects of the experiment, including the experimental setup, hyperparameter tuning process, evaluation results, statistical significance tests, and error analysis.</li>
<li><strong>Visualizations:</strong> Use visualizations (e.g., plots, tables, attention maps) to present the results clearly and concisely.</li>
</ul>
<p>By following this comprehensive approach, one can rigorously compare the performance of traditional Transformers, Longformer, and Big Bird on a long-document classification task, providing valuable insights into their strengths and weaknesses.</p>
<hr>
<p><strong>How to Narrate</strong></p>
<p>Here’s a step-by-step guide on how to articulate this to an interviewer:</p>
<ol type="1">
<li><p><strong>Start with a High-Level Overview:</strong></p>
<ul>
<li>“To compare the performance of Transformer, Longformer, and Big Bird on long-document classification, I’d design a controlled experiment with a focus on fair comparison and robust evaluation.”</li>
</ul></li>
<li><p><strong>Discuss Data Preparation:</strong></p>
<ul>
<li>“First, I’d select a suitable long-document dataset like [mention a specific dataset]. I’d then preprocess the data by tokenizing, handling sequence length through truncation/padding, and creating a consistent vocabulary across all models.”</li>
<li>“It’s important to use the same tokenization and vocabulary across all models to minimize variables, focusing instead on the architectural differences.”</li>
</ul></li>
<li><p><strong>Explain Model Configuration and Tuning:</strong></p>
<ul>
<li>“Next, I’d configure each model and perform hyperparameter tuning using the validation set. Key hyperparameters include learning rate, batch size, number of layers, and attention-specific parameters.”</li>
<li>“Learning rate scheduling, such as warm-up and decay, is important for Transformer-based models. We can define the learning rate decay using a formula like this: <span class="math inline">\(\text{lr}(t) = \frac{\text{initial_lr}}{\sqrt{t}}\)</span>, where <span class="math inline">\(t\)</span> is the training step.” (Present the equation clearly and explain the variables).</li>
<li>“I’d also use regularization techniques to prevent overfitting. L2 regularization, for example, adds a penalty term to the loss function, which can be expressed as: <span class="math inline">\(J(\theta) = \frac{1}{N} \sum_{i=1}^{N} L(y_i, \hat{y}_i) + \frac{\lambda}{2N} ||\theta||^2\)</span>.” (Explain the components).</li>
</ul></li>
<li><p><strong>Describe Training and Validation:</strong></p>
<ul>
<li>“I would train each model using the training data, monitoring the validation loss. Early stopping would be implemented to prevent overfitting.”</li>
</ul></li>
<li><p><strong>Outline Evaluation Metrics:</strong></p>
<ul>
<li>“The evaluation would focus on a variety of metrics: accuracy, precision, recall, F1-score (especially crucial with imbalanced datasets). I will use equations as follows”</li>
<li>Present Equations for: Accuracy, Precision, Recall, and F1 score.</li>
</ul></li>
<li><p><strong>Detail Evaluation Techniques:</strong></p>
<ul>
<li>“To ensure robust evaluation, I’d use statistical significance testing (e.g., t-tests, ANOVA) and calculate confidence intervals to determine if observed differences are statistically meaningful.”</li>
<li>“Ablation studies would help to understand the impact of specific components. Attention visualization can provide insights into how each model processes the documents.”</li>
</ul></li>
<li><p><strong>Discuss Implementation Considerations:</strong></p>
<ul>
<li>“Consistent hardware, software, and reproducibility through documented steps and random seeds are critical. Code optimization and scalability need to be considered, too.”</li>
</ul></li>
<li><p><strong>Wrap Up with Reporting:</strong></p>
<ul>
<li>“Finally, the results would be presented in a comprehensive report with visualizations and a detailed analysis of the findings, including error analysis.”</li>
</ul></li>
</ol>
<p><strong>Communication Tips:</strong></p>
<ul>
<li><strong>Pace Yourself:</strong> Don’t rush. Take your time to explain each step clearly.</li>
<li><strong>Use Visual Aids:</strong> If possible, have a diagram or chart to illustrate the model architectures or attention mechanisms.</li>
<li><strong>Explain the “Why”:</strong> Don’t just state what you would do; explain <em>why</em> you would do it. For example, why is learning rate scheduling important? Why use F1-score?</li>
<li><strong>Engage the Interviewer:</strong> Ask if they have any questions or if they’d like you to elaborate on any specific point.</li>
<li><strong>Handle Math with Care:</strong> When presenting equations, explain the variables and their significance. Don’t assume the interviewer knows the notation. Offer a simplified, intuitive explanation if the interviewer seems less familiar with the mathematics.</li>
<li><strong>Be Honest:</strong> If you’re unsure about a specific detail, acknowledge it but emphasize your general understanding and your ability to find the answer.</li>
<li><strong>Show Enthusiasm:</strong> Demonstrate your passion for the topic and your desire to solve challenging problems.</li>
</ul>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>