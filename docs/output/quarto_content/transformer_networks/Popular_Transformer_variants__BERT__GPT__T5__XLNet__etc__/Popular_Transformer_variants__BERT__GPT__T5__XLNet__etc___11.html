<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.41">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>popular_transformer_variants__bert__gpt__t5__xlnet__etc___11</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../../">
<script src="../../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../site_libs/quarto-html/quarto-syntax-highlighting-48ffa3e5b9d089919c6712c39e5b00f2.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../site_libs/bootstrap/bootstrap-a37d0bf9d509de95c1ba4621f20add8c.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<section id="question-12.-considering-the-increasing-complexity-of-transformer-models-what-steps-would-you-take-to-ensure-that-your-models-performance-is-robust-against-adversarial-attacks-and-biases-inherent-in-the-training-data" class="level2">
<h2 class="anchored" data-anchor-id="question-12.-considering-the-increasing-complexity-of-transformer-models-what-steps-would-you-take-to-ensure-that-your-models-performance-is-robust-against-adversarial-attacks-and-biases-inherent-in-the-training-data">Question: 12. Considering the increasing complexity of Transformer models, what steps would you take to ensure that your model’s performance is robust against adversarial attacks and biases inherent in the training data?</h2>
<p><strong>Best Answer</strong></p>
<p>Addressing adversarial attacks and biases in large Transformer models requires a multifaceted approach encompassing data preprocessing, model training, and post-deployment monitoring. Here’s a breakdown of key strategies:</p>
<p><strong>1. Data Preprocessing and Bias Mitigation:</strong></p>
<ul>
<li><p><strong>Bias Auditing:</strong></p>
<ul>
<li><p>Before training, thoroughly audit the pre-training dataset for biases related to gender, race, religion, etc. Tools like the AI Fairness 360 toolkit can be invaluable here. Quantify these biases using metrics like disparate impact, statistical parity difference, and equal opportunity difference.</p></li>
<li><p><em>Disparate Impact:</em> Ratio of selection rates for different groups:</p></li>
</ul>
<p><span class="math display">\[
DI = \frac{P(Y=1|A=a)}{P(Y=1|A=a')}
\]</span></p>
<p>Where: <span class="math inline">\(Y\)</span> is the outcome, <span class="math inline">\(A\)</span> is the sensitive attribute, and <span class="math inline">\(a\)</span> and <span class="math inline">\(a'\)</span> are different values of the sensitive attribute. A DI less than 0.8 is often considered indicative of adverse impact.</p></li>
<li><p><strong>Data Augmentation/Re-weighting:</strong></p>
<ul>
<li>Address identified biases through data augmentation techniques. For example, if a dataset is under-representative of a particular demographic group, synthesize or oversample data points for that group. Alternatively, re-weight the samples during training so that under-represented groups have a higher influence on the loss function.</li>
<li><em>Re-weighting:</em> Adjust the weight of each sample in the loss function based on its group membership. This can be achieved using various strategies, such as inverse probability weighting.</li>
</ul></li>
<li><p><strong>Balanced Dataset Creation:</strong> Create subsets of data to force model training to train on balanced data with respect to key features.</p></li>
</ul>
<p><strong>2. Adversarial Training:</strong></p>
<ul>
<li><p><strong>Projected Gradient Descent (PGD) Adversarial Training:</strong></p>
<ul>
<li><p>This is a powerful technique to improve robustness. The core idea is to generate adversarial examples during training by iteratively perturbing the input data in the direction that maximizes the loss function, subject to a constraint on the magnitude of the perturbation.</p></li>
<li><p>The adversarial example <span class="math inline">\(x_{adv}\)</span> is generated as follows:</p>
<p><span class="math display">\[
x_{adv}^{t+1} = \Pi_{X} \left( x_{adv}^{t} + \alpha \cdot \text{sign}(\nabla_{x} L(\theta, x_{adv}^{t}, y)) \right)
\]</span></p>
<p>Where:</p>
<ul>
<li><span class="math inline">\(x_{adv}^{t}\)</span> is the adversarial example at iteration <span class="math inline">\(t\)</span>.</li>
<li><span class="math inline">\(\alpha\)</span> is the step size.</li>
<li><span class="math inline">\(L(\theta, x, y)\)</span> is the loss function with model parameters <span class="math inline">\(\theta\)</span>, input <span class="math inline">\(x\)</span>, and true label <span class="math inline">\(y\)</span>.</li>
<li><span class="math inline">\(\nabla_{x} L(\theta, x, y)\)</span> is the gradient of the loss function with respect to the input <span class="math inline">\(x\)</span>.</li>
<li><span class="math inline">\(\text{sign}(\cdot)\)</span> is the sign function.</li>
<li><span class="math inline">\(\Pi_{X}(\cdot)\)</span> is a projection function that keeps the adversarial example within the valid input space <span class="math inline">\(X\)</span>.</li>
</ul></li>
<li><p>The model is then trained on these adversarial examples, making it more resilient to similar attacks.</p></li>
</ul></li>
<li><p><strong>Fast Gradient Sign Method (FGSM):</strong> A simpler, single-step approach for generating adversarial examples:</p>
<p><span class="math display">\[
x_{adv} = x + \epsilon \cdot \text{sign}(\nabla_{x} L(\theta, x, y))
\]</span></p>
<p>Where:</p>
<ul>
<li><span class="math inline">\(\epsilon\)</span> controls the magnitude of the perturbation.</li>
</ul></li>
<li><p><strong>Min-Max Optimization:</strong> The adversarial training objective can be formulated as a min-max problem:</p>
<p><span class="math display">\[
\min_{\theta} \mathbb{E}_{(x, y) \sim \mathcal{D}} \left[ \max_{\delta \in \Delta} L(\theta, x + \delta, y) \right]
\]</span></p>
<p>Where:</p>
<ul>
<li><span class="math inline">\(\theta\)</span> represents the model parameters.</li>
<li><span class="math inline">\(\mathcal{D}\)</span> is the data distribution.</li>
<li><span class="math inline">\(\delta\)</span> is the adversarial perturbation.</li>
<li><span class="math inline">\(\Delta\)</span> is the set of allowed perturbations.</li>
</ul></li>
</ul>
<p><strong>3. Input Perturbation Defenses:</strong></p>
<ul>
<li><strong>Input Sanitization:</strong>
<ul>
<li>Implement techniques to detect and remove potentially adversarial perturbations from the input before feeding it to the model. This could involve techniques like Gaussian smoothing, feature squeezing, or total variance minimization.</li>
</ul></li>
<li><strong>Randomization:</strong> Add small random perturbations to the input during inference. This can disrupt adversarial attacks that rely on precise gradient information.</li>
</ul>
<p><strong>4. Model Architecture Modifications:</strong></p>
<ul>
<li><strong>Certified Robustness:</strong> Explore techniques like randomized smoothing to create models with provable robustness guarantees within a certain radius around each input.</li>
<li><strong>Defensive Distillation:</strong> Train a “student” model to mimic the output probabilities of a “teacher” model that has been adversarially trained. The student model often inherits some of the teacher’s robustness.</li>
</ul>
<p><strong>5. Monitoring and Auditing:</strong></p>
<ul>
<li><p><strong>Continuous Monitoring:</strong> Implement monitoring systems to track the model’s performance in production and detect anomalies that might indicate an adversarial attack or bias-related issue. This can include tracking metrics like accuracy, confidence scores, and fairness metrics across different demographic groups.</p></li>
<li><p><strong>Regular Audits:</strong> Conduct regular audits of the model’s performance and fairness. This should involve evaluating the model on diverse datasets and stress-testing it with various adversarial attacks.</p></li>
</ul>
<p><strong>6. Ethical Considerations and Transparency:</strong></p>
<ul>
<li><strong>Documentation:</strong> Maintain comprehensive documentation of the model’s training data, architecture, training process, and evaluation results. This should include information about any identified biases and the mitigation strategies that were implemented.</li>
<li><strong>Transparency:</strong> Be transparent with users about the limitations of the model and the potential for bias or adversarial attacks.</li>
</ul>
<p><strong>Real-world Considerations:</strong></p>
<ul>
<li><strong>Computational Cost:</strong> Adversarial training can be computationally expensive, especially for large Transformer models. Techniques like gradient checkpointing and mixed-precision training can help mitigate this cost.</li>
<li><strong>Transferability of Attacks:</strong> Adversarial examples generated for one model can sometimes transfer to other models. It’s important to evaluate the robustness of the model against a wide range of attacks.</li>
<li><strong>Evolving Threats:</strong> Adversarial attacks are constantly evolving. It’s important to stay up-to-date with the latest research and adapt defense strategies accordingly.</li>
<li><strong>Trade-offs:</strong> Robustness often comes at the cost of accuracy on clean data. It’s important to find a balance between these two objectives.</li>
<li><strong>Bias Amplification:</strong> It’s crucial to ensure that defense mechanisms don’t inadvertently amplify existing biases.</li>
<li><strong>Interpretability:</strong> Invest in interpretability methods to understand <em>why</em> certain inputs are vulnerable to adversarial attacks or result in biased predictions. This can guide the development of more effective defenses.</li>
</ul>
<p>By employing these strategies, one can significantly improve the robustness and fairness of Transformer models, making them more reliable and trustworthy for real-world applications.</p>
<hr>
<p><strong>How to Narrate</strong></p>
<p>Here’s a suggested way to present this answer in an interview:</p>
<ol type="1">
<li><p><strong>Start with a High-Level Overview:</strong></p>
<ul>
<li>“Thank you for the question. Addressing adversarial attacks and biases in large Transformer models is critical for their responsible deployment. It requires a comprehensive strategy that spans data preprocessing, model training, and post-deployment monitoring.”</li>
<li>“I’ll outline several key steps, touching on both technical and ethical considerations.”</li>
</ul></li>
<li><p><strong>Discuss Data Preprocessing and Bias Mitigation:</strong></p>
<ul>
<li>“Before training, a thorough bias audit is crucial. We can use tools like AI Fairness 360 to quantify biases related to sensitive attributes.”</li>
<li>“We can then use data augmentation or re-weighting to mitigate these biases.” (Optionally, present the disparate impact formula).</li>
<li>“It’s essential to create balanced datasets, if possible, to prevent the model from learning skewed relationships.”</li>
</ul></li>
<li><p><strong>Explain Adversarial Training:</strong></p>
<ul>
<li>“One of the most effective techniques is adversarial training, where we expose the model to perturbed inputs designed to fool it.”</li>
<li>“A powerful approach is Projected Gradient Descent (PGD). We iteratively perturb the input in the direction that maximizes the loss.”</li>
<li>(Present the PGD formula, but <em>don’t</em> dive into every detail unless asked. Say something like, “The key idea is to take small steps in the direction of increasing the loss, while staying within a reasonable range of the original input.”).</li>
<li>“We can also use simpler methods like the Fast Gradient Sign Method (FGSM).”</li>
<li>“The goal is to train the model to be robust to these perturbations, effectively creating a more resilient model.”</li>
</ul></li>
<li><p><strong>Describe Input Perturbation Defenses:</strong></p>
<ul>
<li>“In addition to adversarial training, we can implement defenses that operate on the input itself.”</li>
<li>“This includes input sanitization techniques to remove adversarial noise or randomization to disrupt attacks that rely on precise gradients.”</li>
</ul></li>
<li><p><strong>Briefly Mention Model Architecture Modifications:</strong></p>
<ul>
<li>“There are also approaches that involve modifying the model architecture itself, such as certified robustness or defensive distillation.”</li>
</ul></li>
<li><p><strong>Emphasize Monitoring and Auditing:</strong></p>
<ul>
<li>“Crucially, we need continuous monitoring in production to detect anomalies and regular audits to assess the model’s performance and fairness across different groups.”</li>
</ul></li>
<li><p><strong>Highlight Ethical Considerations and Transparency:</strong></p>
<ul>
<li>“It’s vital to maintain comprehensive documentation and be transparent with users about the model’s limitations and potential for bias.”</li>
</ul></li>
<li><p><strong>Address Real-World Considerations (Optional):</strong></p>
<ul>
<li>“It’s important to be aware of the computational cost of adversarial training and the evolving nature of adversarial attacks.”</li>
<li>“There’s often a trade-off between robustness and accuracy on clean data, and we must be careful not to amplify existing biases.”</li>
</ul></li>
<li><p><strong>Conclude with a Summary:</strong></p>
<ul>
<li>“By combining these strategies, we can significantly enhance the robustness and fairness of Transformer models, making them more reliable for real-world applications.”</li>
</ul></li>
</ol>
<p><strong>Communication Tips:</strong></p>
<ul>
<li><strong>Pace Yourself:</strong> Don’t rush through the answer. Speak clearly and deliberately.</li>
<li><strong>Use Signposting:</strong> Use phrases like “First, we…”, “Next, we…”, “Finally, we…” to guide the interviewer through your answer.</li>
<li><strong>Pause for Questions:</strong> After explaining a complex concept, pause briefly and ask if the interviewer has any questions.</li>
<li><strong>Be Prepared to Elaborate:</strong> The interviewer may ask you to go into more detail on a particular aspect. Be prepared to do so.</li>
<li><strong>Acknowledge Limitations:</strong> It’s okay to admit that you don’t know everything. If you’re unsure about something, say so, but offer to speculate or suggest resources for further learning.</li>
<li><strong>Stay Practical:</strong> Connect your answer to real-world applications and challenges.</li>
</ul>
<p>By following these guidelines, you can demonstrate your expertise and effectively communicate your understanding of how to address adversarial attacks and biases in Transformer models.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>