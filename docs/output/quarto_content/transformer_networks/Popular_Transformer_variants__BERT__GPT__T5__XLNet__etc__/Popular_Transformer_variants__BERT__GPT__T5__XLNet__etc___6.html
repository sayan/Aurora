<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>popular_transformer_variants__bert__gpt__t5__xlnet__etc___6</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../../">
<script src="../../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../site_libs/bootstrap/bootstrap-5d3fd86dc4559d58e199c8cc4a79ed5b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<section id="question-7.-when-deploying-transformer-models-in-real-world-applications-what-are-some-challenges-you-might-face-with-messy-or-noisy-data-how-would-you-mitigate-these-issues" class="level2">
<h2 class="anchored" data-anchor-id="question-7.-when-deploying-transformer-models-in-real-world-applications-what-are-some-challenges-you-might-face-with-messy-or-noisy-data-how-would-you-mitigate-these-issues">Question: 7. When deploying Transformer models in real-world applications, what are some challenges you might face with messy or noisy data? How would you mitigate these issues?</h2>
<p><strong>Best Answer</strong></p>
<p>Deploying Transformer models in real-world applications exposes them to data that is often significantly messier and noisier than the curated datasets they are typically trained on. This discrepancy presents several key challenges:</p>
<ul>
<li><p><strong>Data Preprocessing Challenges:</strong> Real-world data is often incomplete, inconsistent, and contains various errors (e.g., typos, incorrect formatting, missing values). Traditional data cleaning methods can be insufficient, and improper preprocessing can degrade the model’s performance.</p></li>
<li><p><strong>Handling Out-of-Vocabulary (OOV) Tokens:</strong> Transformer models rely on a fixed vocabulary. Noisy data often contains rare words, misspellings, or domain-specific terminology not present in the training vocabulary. This leads to OOV tokens, which are typically mapped to a single <code>&lt;UNK&gt;</code> token, losing potentially valuable information.</p></li>
<li><p><strong>Domain Mismatch:</strong> The distribution of real-world data can differ significantly from the training data (domain shift). This can be due to changes in language style, topic focus, or data quality. A model trained on a clean dataset might struggle with the nuances and characteristics of the new domain.</p></li>
<li><p><strong>Bias Amplification:</strong> Noisy data can exacerbate existing biases in the model. For example, if the training data contains biased language patterns, errors in real-world data might reinforce these biases, leading to unfair or discriminatory outcomes.</p></li>
<li><p><strong>Error Propagation:</strong> Transformer models can be sensitive to input errors, especially in sequential tasks like machine translation or text generation. A small error in the input can propagate through the model, leading to significant errors in the output.</p></li>
</ul>
<p>To mitigate these issues, several strategies can be employed:</p>
<ol type="1">
<li><p><strong>Robust Data Augmentation:</strong></p>
<ul>
<li><em>Goal:</em> To increase the model’s robustness to noisy inputs by training on a wider range of data variations.</li>
<li><em>Techniques:</em>
<ul>
<li><em>Back-translation:</em> Translate the data to another language and back to generate slightly different but semantically similar versions.</li>
<li><em>Noise injection:</em> Introduce random noise (e.g., typos, word deletions, word swaps) into the training data.</li>
<li><em>Adversarial training:</em> Train the model to be robust against small, carefully crafted perturbations of the input. For example, we can create adversarial examples using Fast Gradient Method: <span class="math display">\[x_{adv} = x + \epsilon \cdot sign(\nabla_x L(\theta, x, y))\]</span> where <span class="math inline">\(x\)</span> is the original input, <span class="math inline">\(\epsilon\)</span> is the perturbation magnitude, <span class="math inline">\(L\)</span> is the loss function, <span class="math inline">\(\theta\)</span> are the model parameters, and <span class="math inline">\(y\)</span> is the target.</li>
</ul></li>
</ul></li>
<li><p><strong>Domain Adaptation:</strong></p>
<ul>
<li><em>Goal:</em> To transfer knowledge from the training domain to the real-world domain.</li>
<li><em>Techniques:</em>
<ul>
<li><em>Fine-tuning:</em> Fine-tune the pre-trained Transformer model on a smaller dataset of real-world data.</li>
<li><em>Domain adversarial training:</em> Train the model to be invariant to the domain while preserving performance on the main task. This can be achieved by adding a domain classifier to the model and training it to predict the domain of the input. The feature extractor is then trained to confuse the domain classifier, thus learning domain-invariant features. The overall loss function would be a combination of the task loss and the domain classification loss.</li>
</ul></li>
</ul></li>
<li><p><strong>Subword Tokenization:</strong></p>
<ul>
<li><em>Goal:</em> To handle OOV tokens more effectively by breaking words into smaller subword units.</li>
<li><em>Techniques:</em>
<ul>
<li><em>Byte-Pair Encoding (BPE):</em> Iteratively merges the most frequent pairs of bytes (or characters) until a desired vocabulary size is reached.</li>
<li><em>WordPiece:</em> Similar to BPE but uses a likelihood-based approach to determine which subword units to merge.</li>
<li><em>Unigram Language Model:</em> Trains a unigram language model on the data and uses the learned probabilities to define subword units.</li>
</ul></li>
</ul></li>
<li><p><strong>Error Handling and Fallback Mechanisms:</strong></p>
<ul>
<li><em>Goal:</em> To gracefully handle unexpected errors or noisy inputs during deployment.</li>
<li><em>Techniques:</em>
<ul>
<li><em>Confidence scores:</em> Use the model’s confidence scores to identify uncertain predictions and trigger fallback mechanisms.</li>
<li><em>Ensemble methods:</em> Combine the predictions of multiple models to reduce the impact of individual errors.</li>
<li><em>Human-in-the-loop:</em> Incorporate human review for uncertain or critical predictions.</li>
</ul></li>
</ul></li>
<li><p><strong>Bias Detection and Mitigation:</strong></p>
<ul>
<li><em>Goal:</em> To identify and mitigate biases in the model and the data.</li>
<li><em>Techniques:</em>
<ul>
<li><em>Bias audits:</em> Evaluate the model’s performance across different demographic groups to identify potential biases.</li>
<li><em>Debiasing techniques:</em> Apply techniques to remove or reduce biases in the training data or the model’s predictions. Techniques include adversarial debiasing (training a model to be invariant to sensitive attributes) and re-weighting the training data to balance the representation of different groups.</li>
</ul></li>
</ul></li>
</ol>
<p><strong>How to Narrate</strong></p>
<p>Here’s a suggested way to articulate this in an interview:</p>
<ol type="1">
<li><strong>Start with a High-Level Overview:</strong>
<ul>
<li>“When deploying Transformer models in real-world scenarios, we face significant challenges due to the inherent messiness and noise in real-world data, as opposed to the more controlled and curated training datasets.”</li>
</ul></li>
<li><strong>Explain the Specific Challenges:</strong>
<ul>
<li>“These challenges include data preprocessing difficulties, where standard cleaning methods often fall short; the problem of handling out-of-vocabulary tokens effectively; domain mismatch, which causes a distribution shift between training and real-world data; the risk of amplifying biases present in the data; and error propagation, where small input errors can lead to significant output inaccuracies.” (Pause briefly after each challenge to ensure the interviewer is following).</li>
</ul></li>
<li><strong>Introduce Mitigation Strategies:</strong>
<ul>
<li>“To address these issues, we can employ several mitigation strategies. I’ll outline a few key approaches…”</li>
</ul></li>
<li><strong>Explain Robust Data Augmentation:</strong>
<ul>
<li>“First, we can use robust data augmentation techniques. This involves training the model on a more diverse set of data, including variations with added noise, back-translations to introduce semantic variations, and even adversarial training to make the model robust against specifically crafted perturbations. For example, in adversarial training, we can slightly modify the input using the gradient of the loss function: [mention the adversarial example formula: <span class="math display">\[x_{adv} = x + \epsilon \cdot sign(\nabla_x L(\theta, x, y))\]</span>] This helps the model become less sensitive to small input changes.”</li>
<li><em>Communication Tip:</em> Briefly explain the formula without getting bogged down in technical details. Say something like: “This formula essentially creates a slightly altered version of the input that is designed to fool the model, forcing it to learn more robust features.”</li>
</ul></li>
<li><strong>Explain Domain Adaptation:</strong>
<ul>
<li>“Another crucial technique is domain adaptation. Here, the goal is to transfer knowledge from the training domain to the real-world domain. Common methods include fine-tuning the pre-trained model on a small sample of real-world data, or employing domain adversarial training where the model learns to be invariant to the source domain.”</li>
</ul></li>
<li><strong>Explain Subword Tokenization:</strong>
<ul>
<li>“To handle out-of-vocabulary tokens, we can use subword tokenization methods like Byte-Pair Encoding or WordPiece. These methods break down words into smaller units, allowing the model to handle rare words and misspellings more effectively without losing information.”</li>
</ul></li>
<li><strong>Explain Error Handling and Fallback Mechanisms:</strong>
<ul>
<li>“Finally, we can implement error handling and fallback mechanisms. This could involve using confidence scores to identify uncertain predictions, employing ensemble methods to combine predictions from multiple models, or even incorporating human-in-the-loop review for critical decisions.”</li>
</ul></li>
<li><strong>Mention Bias Mitigation:</strong>
<ul>
<li>“It’s also crucial to address potential biases. This involves conducting bias audits to evaluate model performance across different groups and applying debiasing techniques to reduce or remove biases in the data or model predictions.”</li>
</ul></li>
<li><strong>Conclude Concisely:</strong>
<ul>
<li>“By combining these strategies, we can significantly improve the robustness and reliability of Transformer models when deploying them in real-world applications with noisy or messy data.”</li>
</ul></li>
</ol>
<p><em>Communication Tips:</em></p>
<ul>
<li><em>Pace:</em> Speak at a moderate pace, allowing the interviewer time to process the information.</li>
<li><em>Enthusiasm:</em> Show your passion for the subject matter.</li>
<li><em>Clarity:</em> Use clear and concise language, avoiding jargon where possible.</li>
<li><em>Engagement:</em> Maintain eye contact and observe the interviewer’s reactions to gauge their understanding.</li>
<li><em>Questions:</em> Encourage questions from the interviewer throughout the explanation. For example, “Does that make sense?” or “Would you like me to elaborate on any of these points?”</li>
<li><em>Math:</em> When presenting a formula, briefly explain its components and purpose without dwelling on the mathematical details.</li>
</ul>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>