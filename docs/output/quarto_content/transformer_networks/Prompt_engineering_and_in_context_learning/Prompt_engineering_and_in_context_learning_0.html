<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.41">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>prompt_engineering_and_in_context_learning_0</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../../">
<script src="../../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../site_libs/quarto-html/quarto-syntax-highlighting-48ffa3e5b9d089919c6712c39e5b00f2.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../site_libs/bootstrap/bootstrap-a37d0bf9d509de95c1ba4621f20add8c.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<section id="question-1.-can-you-explain-the-concept-of-prompt-engineering-and-why-it-is-crucial-in-modern-language-model-applications" class="level2">
<h2 class="anchored" data-anchor-id="question-1.-can-you-explain-the-concept-of-prompt-engineering-and-why-it-is-crucial-in-modern-language-model-applications">Question: 1. Can you explain the concept of prompt engineering and why it is crucial in modern language model applications?</h2>
<p><strong>Best Answer</strong></p>
<p>Prompt engineering is the art and science of designing effective prompts (inputs) to elicit desired responses from large language models (LLMs). It’s crucial because the quality and relevance of an LLM’s output heavily depend on the input prompt. A well-engineered prompt can significantly improve the accuracy, coherence, and usefulness of the generated text, while a poorly designed prompt can lead to irrelevant, nonsensical, or even harmful outputs.</p>
<p>Here’s a more detailed breakdown:</p>
<ul>
<li><p><strong>Definition:</strong> Prompt engineering involves crafting specific instructions, questions, examples, or other forms of input that guide the LLM to produce a particular type of response. It’s an iterative process of experimentation and refinement to discover the optimal prompt structure for a given task.</p></li>
<li><p><strong>Why is it crucial?</strong></p>
<ul>
<li><p><strong>Eliciting desired behavior:</strong> LLMs are trained on vast amounts of data and can perform a wide range of tasks. Prompt engineering allows us to steer the model toward the specific task we want it to perform, such as translation, summarization, question answering, code generation, or creative writing.</p></li>
<li><p><strong>Improving accuracy and reducing errors:</strong> LLMs can generate incorrect or nonsensical outputs if the prompt is ambiguous or doesn’t provide sufficient context. A well-crafted prompt can help to reduce these errors and improve the overall accuracy of the generated text. This is especially vital in safety-critical applications.</p></li>
<li><p><strong>Controlling output style and format:</strong> Prompts can be designed to influence the style, tone, and format of the generated text. For example, we can instruct the model to write in a formal or informal style, to use specific vocabulary, or to follow a particular formatting convention.</p></li>
<li><p><strong>Enabling in-context learning:</strong> LLMs can learn new tasks or adapt to new data distributions from just a few examples provided in the prompt. This is known as in-context learning, and it’s a powerful way to customize the model’s behavior without fine-tuning its parameters.</p></li>
</ul></li>
<li><p><strong>Techniques in Prompt Engineering</strong></p>
<ul>
<li><p><strong>Zero-shot prompting:</strong> Asking the model to perform a task without providing any examples. For example, “Translate the following English text to French: ‘Hello, world!’”</p></li>
<li><p><strong>Few-shot prompting:</strong> Providing a small number of examples of the desired input-output pairs in the prompt. This helps the model understand the task and generate more accurate results. For example:</p>
<pre><code>English: The cat sat on the mat.
French: Le chat était assis sur le tapis.

English: The dog chased the ball.
French: Le chien a couru après le ballon.

English: The bird flew away.
French: L'oiseau s'est envolé.</code></pre></li>
<li><p><strong>Chain-of-thought prompting:</strong> Guiding the model to break down a complex problem into a series of smaller, more manageable steps. This can improve the model’s reasoning ability and lead to more accurate solutions. For instance, when solving an arithmetic problem, we encourage the model to first lay out each step and then provide the answer.</p></li>
<li><p><strong>Role prompting:</strong> Instructing the model to assume a specific persona or role. For example, “You are a helpful AI assistant. Please answer the following question…”</p></li>
<li><p><strong>Prompt Templates and Libraries:</strong> Creating reusable templates and libraries of prompts that can be adapted for different tasks. This can save time and effort in prompt engineering.</p></li>
<li><p><strong>Adversarial Prompting:</strong> Testing the robustness of a model by crafting prompts designed to elicit undesirable behavior. This is crucial for identifying vulnerabilities and improving the model’s safety and reliability.</p></li>
</ul></li>
<li><p><strong>Mathematical Perspective (In-Context Learning):</strong></p>
<ul>
<li><p>In-context learning can be viewed as a form of meta-learning, where the LLM learns to learn from the examples provided in the prompt. Let’s say we have a model <span class="math inline">\(M\)</span> and a task <span class="math inline">\(T\)</span>. The prompt <span class="math inline">\(P\)</span> contains <span class="math inline">\(k\)</span> examples, each consisting of an input <span class="math inline">\(x_i\)</span> and a desired output <span class="math inline">\(y_i\)</span>, i.e., <span class="math inline">\(P = \{(x_1, y_1), (x_2, y_2), ..., (x_k, y_k)\}\)</span>.</p></li>
<li><p>The model uses the prompt <span class="math inline">\(P\)</span> to predict the output <span class="math inline">\(y'\)</span> for a new input <span class="math inline">\(x'\)</span>. We can represent this as:</p>
<p><span class="math display">\[y' = M(x', P)\]</span></p></li>
<li><p>Ideally, the model should minimize the loss function <span class="math inline">\(L\)</span> between the predicted output <span class="math inline">\(y'\)</span> and the true output <span class="math inline">\(y\)</span> over a distribution of tasks:</p>
<p><span class="math display">\[ \min_M E_{T \sim D} [L(M(x', P), y)] \]</span></p>
<p>Where <span class="math inline">\(D\)</span> is the distribution of tasks. The challenge is to find prompts <span class="math inline">\(P\)</span> that enable the model <span class="math inline">\(M\)</span> to generalize well across different tasks within the distribution <span class="math inline">\(D\)</span>.</p></li>
</ul></li>
<li><p><strong>Iterative Refinement:</strong> Prompt engineering is not a one-time process. It requires experimentation and iteration to find the optimal prompt structure. This often involves:</p>
<ul>
<li><strong>Testing different prompt formulations.</strong></li>
<li><strong>Analyzing the model’s outputs.</strong></li>
<li><strong>Adjusting the prompt based on the analysis.</strong></li>
</ul></li>
<li><p><strong>Real-world Considerations:</strong></p>
<ul>
<li><strong>Context Length:</strong> LLMs have a limited context window, which restricts the length of the prompt. Prompt engineers must carefully balance the amount of information provided in the prompt with the context length limitations.</li>
<li><strong>Tokenization:</strong> Understanding how the model tokenizes text is crucial for crafting effective prompts. Different tokenization strategies can affect the performance of the model.</li>
<li><strong>Bias:</strong> Prompts can inadvertently introduce biases into the generated text. It’s important to be aware of potential biases and to design prompts that mitigate them.</li>
<li><strong>Cost:</strong> Longer prompts consume more tokens, which can increase the cost of using the LLM. It’s important to optimize the prompt for both performance and cost.</li>
</ul></li>
</ul>
<p>In summary, prompt engineering is a critical skill for anyone working with LLMs. It enables us to harness the full potential of these powerful models and to create a wide range of innovative applications.</p>
<hr>
<p><strong>How to Narrate</strong></p>
<p>Here’s a suggested approach for explaining prompt engineering in an interview:</p>
<ol type="1">
<li><p><strong>Start with a concise definition:</strong> “Prompt engineering is the process of designing effective input prompts to elicit the desired outputs from large language models.”</p></li>
<li><p><strong>Emphasize the importance:</strong> “It’s crucial because the quality and relevance of the LLM’s output is directly related to the quality of the prompt. Good prompts unlock the potential of these models, while bad prompts can lead to inaccurate or nonsensical results.”</p></li>
<li><p><strong>Provide examples of why it’s important, choosing 2-3 bullets to focus on:</strong></p>
<ul>
<li>“It allows us to steer the model towards specific tasks like translation or summarization.”</li>
<li>“It can significantly improve the accuracy of the generated text.”</li>
<li>“It enables in-context learning, where the model learns from examples in the prompt.”</li>
</ul></li>
<li><p><strong>Explain different prompting techniques. Pick 2-3 to describe and use examples.</strong></p>
<ul>
<li>“There are several prompt engineering techniques, such as few-shot prompting, where we provide a few examples to guide the model. For instance, when doing translation, we can give the model a couple of English-French sentence pairs before asking it to translate a new sentence.”</li>
<li>“Another useful technique is Chain-of-Thought prompting, where you guide the model to break down the problem into smaller steps before answering. This is especially useful in arithmetic and reasoning type problems.”</li>
</ul></li>
<li><p><strong>(Optional) Touch upon the mathematical perspective <em>briefly</em> if the interviewer seems technically inclined:</strong> “In-context learning can be viewed as a form of meta-learning. Essentially, we’re trying to optimize the prompt to minimize the difference between the model’s prediction and the actual correct answer, across a range of tasks. The main challenge here is finding the optimal prompt.” Avoid going too deep into the equation, just explain the intuition.</p></li>
<li><p><strong>Mention the iterative nature and real-world considerations:</strong> “Prompt engineering is an iterative process. We need to experiment, analyze the results, and refine the prompt to achieve the desired outcome. Factors like context length, tokenization, bias, and cost must be considered.”</p></li>
<li><p><strong>Offer to elaborate:</strong> “I can provide more details on specific prompt engineering techniques or discuss specific real-world applications if you’d like.”</p></li>
</ol>
<p><strong>Communication Tips:</strong></p>
<ul>
<li><strong>Speak Clearly and Concisely:</strong> Avoid jargon unless you are sure the interviewer will understand it.</li>
<li><strong>Use Examples:</strong> Illustrate your points with concrete examples to make them more understandable.</li>
<li><strong>Gauge the Interviewer’s Interest:</strong> Pay attention to the interviewer’s body language and questions. If they seem particularly interested in a specific aspect, delve deeper into that topic. If they seem less interested, move on to another topic.</li>
<li><strong>Don’t Overwhelm:</strong> Avoid presenting too much information at once. Break down complex topics into smaller, more manageable chunks.</li>
<li><strong>Be Prepared to Dive Deeper:</strong> If the interviewer asks a follow-up question, be prepared to provide more detailed information and technical explanations.</li>
<li><strong>Be Confident, But Humble:</strong> Demonstrate your expertise, but avoid appearing arrogant or condescending. Acknowledge that prompt engineering is an evolving field and that there’s always more to learn.</li>
<li><strong>Pause Briefly:</strong> Give the interviewer time to process the information and ask questions.</li>
<li><strong>For equations: When explaining the mathematical portion, emphasize the <em>intuition</em> behind the formulas rather than getting bogged down in technical details, unless explicitly asked.</strong> For example: “Essentially, we are trying to create a prompt that enables the model to perform well on different tasks in a distribution of tasks”.</li>
</ul>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>