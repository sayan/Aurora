<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>model_versioning_and_governance_3</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../../">
<script src="../../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../site_libs/bootstrap/bootstrap-5d3fd86dc4559d58e199c8cc4a79ed5b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<section id="question-in-a-scenario-where-metadata-on-model-versions-becomes-inconsistent-or-incomplete-for-example-due-to-integration-issues-with-various-data-sources-how-would-you-approach-cleaning-and-reconciling-this-information-to-maintain-governance-standards" class="level2">
<h2 class="anchored" data-anchor-id="question-in-a-scenario-where-metadata-on-model-versions-becomes-inconsistent-or-incomplete-for-example-due-to-integration-issues-with-various-data-sources-how-would-you-approach-cleaning-and-reconciling-this-information-to-maintain-governance-standards">Question: In a scenario where metadata on model versions becomes inconsistent or incomplete (for example, due to integration issues with various data sources), how would you approach cleaning and reconciling this information to maintain governance standards?</h2>
<p><strong>Best Answer</strong></p>
<p>Inconsistent or incomplete model metadata is a serious problem, undermining model governance, reproducibility, and potentially leading to compliance issues. A systematic approach is crucial to clean and reconcile this data. Here’s how I would tackle this problem:</p>
<p><strong>1. Assessment and Scoping</strong></p>
<ul>
<li><strong>Inventory:</strong> First, I would conduct a thorough inventory of all existing model versions and their associated metadata sources. This includes model registries, CI/CD pipelines, data lineage tools, experiment tracking systems (e.g., MLflow, Kubeflow), and any manual documentation.</li>
<li><strong>Identify Data Quality Issues:</strong> Next, I would analyze the current state of the metadata. Key questions:
<ul>
<li><strong>Completeness:</strong> What percentage of models have complete metadata records? Which fields are most frequently missing?</li>
<li><strong>Consistency:</strong> Are there conflicting values for the same model attribute across different systems (e.g., different training dates, accuracy metrics)?</li>
<li><strong>Accuracy:</strong> Are the recorded values correct (e.g., verified against source code, training logs)?</li>
<li><strong>Validity:</strong> Do the data types and formats of the metadata conform to the established schema?</li>
<li><strong>Timeliness:</strong> Is the metadata up-to-date with the current model versions?</li>
</ul></li>
<li><strong>Prioritize:</strong> Not all inconsistencies are created equal. I’d prioritize based on:
<ul>
<li><strong>Business impact:</strong> Which models are most critical to the business?</li>
<li><strong>Regulatory compliance:</strong> Are there models subject to specific regulatory requirements (e.g., GDPR, CCPA)?</li>
<li><strong>Data dependencies:</strong> Which models are downstream dependencies of other models?</li>
</ul></li>
</ul>
<p><strong>2. Metadata Standardization and Schema Definition</strong></p>
<ul>
<li><strong>Define a Unified Schema:</strong> Work with data engineers, MLOps engineers, and business stakeholders to define a consistent, comprehensive metadata schema. This schema should include:
<ul>
<li><strong>Model Identifier:</strong> Unique ID for the model.</li>
<li><strong>Version:</strong> Model version number (following semantic versioning principles).</li>
<li><strong>Description:</strong> A clear description of the model’s purpose.</li>
<li><strong>Training Data:</strong> Information on the dataset(s) used for training (version, source, size, features).</li>
<li><strong>Training Parameters:</strong> Hyperparameters used during training.</li>
<li><strong>Evaluation Metrics:</strong> Key performance metrics (e.g., accuracy, precision, recall, F1-score, AUC) on validation and test sets.</li>
<li><strong>Training Environment:</strong> Details about the hardware and software environment (e.g., Python version, libraries, GPU/CPU).</li>
<li><strong>Author/Owner:</strong> The individual or team responsible for the model.</li>
<li><strong>Deployment Information:</strong> Location of the deployed model, API endpoint, and associated infrastructure.</li>
<li><strong>Date Created/Updated:</strong> Timestamps for model creation, training, and deployment.</li>
<li><strong>Data Lineage:</strong> The relationship of the model to upstream data sources.</li>
<li><strong>Drift Monitoring Stats:</strong> Key drift statistics related to the model performance in production.</li>
</ul></li>
<li><strong>Data Types and Validation Rules:</strong> Define data types for each metadata field (e.g., string, integer, float, date) and establish validation rules to ensure data quality (e.g., regular expressions, range checks). For instance, the F1-score must fall between 0 and 1.</li>
</ul>
<p><strong>3. Data Cleaning and Reconciliation</strong></p>
<ul>
<li><strong>Develop Automated Scripts:</strong> I would create automated scripts (e.g., in Python with libraries like Pandas and potentially using APIs of model registries such as MLflow or KubeFlow) to perform the following tasks:
<ul>
<li><strong>Data Extraction:</strong> Extract metadata from various sources (model registries, experiment tracking systems, code repositories).</li>
<li><strong>Data Transformation:</strong> Transform the data to conform to the unified schema (e.g., renaming columns, converting data types).</li>
<li><strong>Data Validation:</strong> Validate the data against the defined validation rules.</li>
<li><strong>Data Reconciliation:</strong> Resolve inconsistencies by applying pre-defined rules. Here are some strategies:
<ul>
<li><strong>Source of Truth:</strong> Designate a “source of truth” for certain attributes. For instance, the model registry might be the authoritative source for the current deployed version.</li>
<li><strong>Time-based Prioritization:</strong> If there are conflicting timestamps, prioritize the most recent timestamp.</li>
<li><strong>Manual Review:</strong> For complex conflicts, flag them for manual review by a domain expert.</li>
</ul></li>
</ul></li>
<li><strong>Handling Missing Data:</strong>
<ul>
<li><strong>Imputation:</strong> If appropriate, impute missing values using statistical techniques (e.g., mean imputation, median imputation). However, be very cautious about imputing critical metadata like training data versions. In some cases, it is better to leave the field blank and flag the model for further investigation.</li>
<li><strong>Default Values:</strong> Use default values for certain fields when appropriate (e.g., setting the author to “Unknown” if the author is not specified).</li>
<li><strong>Data Mining from Logs/Code:</strong> Parse training logs, version control history, and model code to extract missing metadata.</li>
</ul></li>
<li><strong>Version Control of Cleaning Scripts:</strong> All cleaning scripts should be version-controlled to ensure reproducibility.</li>
<li><strong>Logging:</strong> Implement comprehensive logging to track all data cleaning and reconciliation steps. This will be crucial for auditing and debugging.</li>
</ul>
<p><strong>4. Establishing Consistency Checks and Monitoring</strong></p>
<ul>
<li><strong>Automated Validation Pipelines:</strong> Build automated pipelines that regularly validate metadata against the defined schema. This pipeline should:
<ul>
<li><strong>Run on a schedule:</strong> Run automatically (e.g., daily) to detect new inconsistencies.</li>
<li><strong>Generate alerts:</strong> Alert relevant teams when inconsistencies are detected.</li>
<li><strong>Report on data quality:</strong> Provide a dashboard with key data quality metrics.</li>
</ul></li>
<li><strong>Continuous Monitoring:</strong> Integrate with monitoring tools to continuously monitor the quality of metadata and trigger alerts when anomalies are detected. For example, monitoring changes in model performance can indicate issues with the recorded training data or hyperparameters.</li>
</ul>
<p><strong>5. Collaboration and Communication</strong></p>
<ul>
<li><strong>Cross-Team Collaboration:</strong> This process requires close collaboration between data scientists, MLOps engineers, data engineers, and business stakeholders.</li>
<li><strong>Clear Communication:</strong> Establish clear communication channels to report on progress, discuss challenges, and resolve conflicts. Document all decisions and assumptions made during the data cleaning process.</li>
</ul>
<p><strong>6. Governance and Documentation</strong></p>
<ul>
<li><strong>Document the Data Cleaning Process:</strong> Thoroughly document the data cleaning process, including the rationale for each decision. This documentation should be readily accessible to all stakeholders.</li>
<li><strong>Establish Data Governance Policies:</strong> Define clear data governance policies for model metadata, including roles and responsibilities, data quality standards, and change management procedures.</li>
<li><strong>Regular Audits:</strong> Conduct regular audits to ensure that data governance policies are being followed.</li>
</ul>
<p><strong>7. Iterative Improvement</strong></p>
<ul>
<li><strong>Feedback Loop:</strong> Continuously monitor the effectiveness of the data cleaning and reconciliation process and solicit feedback from stakeholders.</li>
<li><strong>Refine the Process:</strong> Based on the feedback, refine the process to improve data quality and efficiency.</li>
</ul>
<p><strong>Impact on Governance and Reproducibility</strong></p>
<p>A clean and consistent model metadata repository is essential for:</p>
<ul>
<li><strong>Model Governance:</strong> Enables effective monitoring, auditing, and compliance.</li>
<li><strong>Reproducibility:</strong> Allows to reproduce model results, track lineage, and understand the complete lifecycle of the model.</li>
<li><strong>Model Risk Management:</strong> Provides the information needed to assess and mitigate risks associated with model deployment.</li>
<li><strong>Knowledge Sharing:</strong> Enables efficient knowledge sharing and collaboration across teams.</li>
</ul>
<p><strong>Real-World Considerations</strong></p>
<ul>
<li><strong>Scalability:</strong> The data cleaning and reconciliation process should be scalable to handle a large number of models and metadata records.</li>
<li><strong>Tooling:</strong> Select appropriate tools to support the data cleaning and reconciliation process (e.g., data quality tools, data catalog tools, model registries).</li>
<li><strong>Organizational Culture:</strong> Fostering a data-driven culture that values data quality is crucial for long-term success.</li>
<li><strong>Incremental Approach:</strong> Tackle the problem incrementally, starting with the most critical models and gradually expanding the scope.</li>
<li><strong>Data Security and Privacy:</strong> Ensure that the data cleaning and reconciliation process is secure and protects sensitive data.</li>
</ul>
<p>By following this structured approach, I would aim to create a reliable and consistent model metadata repository that supports effective model governance, reproducibility, and risk management.</p>
<p><strong>How to Narrate</strong></p>
<p>Here’s how I would present this information in an interview:</p>
<ol type="1">
<li><strong>Start with the Problem Statement:</strong>
<ul>
<li>“Inconsistent and incomplete model metadata can severely hinder model governance, reproducibility, and compliance. It’s a problem I’ve encountered and here’s how I approach resolving it.”</li>
</ul></li>
<li><strong>Outline the Approach (High-Level):</strong>
<ul>
<li>“My approach is structured, focusing on assessment, standardization, cleaning, and continuous monitoring.”</li>
</ul></li>
<li><strong>Dive into Assessment and Scoping:</strong>
<ul>
<li>“First, I’d inventory all model versions and metadata sources - model registries, experiment tracking systems, CI/CD pipelines, code repos, etc. Then, I would asses for completeness, consistency, and accuracy.”</li>
<li>“I’d use metrics to quantify the data quality problems and prioritize based on business impact and compliance needs.”</li>
</ul></li>
<li><strong>Explain Metadata Standardization:</strong>
<ul>
<li>“Next, working with stakeholders, I’d define a unified metadata schema. This includes key attributes like model ID, version, training data details, metrics, training environment, deployment information, data lineage and drift monitoring stats.”</li>
<li>“I’d emphasize the importance of defining data types and validation rules to enforce data quality.”</li>
</ul></li>
<li><strong>Detail the Data Cleaning Process:</strong>
<ul>
<li>“I’d develop automated scripts to extract, transform, and validate the data. Reconciliation strategies would involve establishing a ‘source of truth’, time-based prioritization, and manual review for complex cases.”</li>
<li>“For missing data, I’d consider imputation (cautiously), default values, and data mining from logs and code. It’s crucial to version control these scripts and maintain thorough logging.”</li>
</ul></li>
<li><strong>Address Consistency Checks and Monitoring:</strong>
<ul>
<li>“Automated validation pipelines are essential. These pipelines should run regularly, generate alerts, and report on data quality. Integrating with monitoring tools allows continuous monitoring of metadata quality.”</li>
</ul></li>
<li><strong>Highlight Collaboration and Communication:</strong>
<ul>
<li>“Cross-team collaboration is paramount. Clear communication channels are needed to report progress, discuss challenges, and document decisions.”</li>
</ul></li>
<li><strong>Emphasize Governance and Documentation:</strong>
<ul>
<li>“The entire data cleaning process must be well-documented. Clear data governance policies should be established, including roles, responsibilities, and change management procedures. Regular audits are crucial.”</li>
</ul></li>
<li><strong>Conclude with Impact and Real-World Considerations:</strong>
<ul>
<li>“A clean metadata repository is essential for governance, reproducibility, and risk management.”</li>
<li>“Real-world considerations include scalability, tooling, organizational culture, and an incremental approach.”</li>
</ul></li>
<li><strong>Mathematical Notes</strong>
<ul>
<li>If talking about validation metrics, you can use inline equations as required, for example: F1 score can be written as <span class="math inline">\(F1 = 2 * \frac{precision * recall}{precision + recall}\)</span></li>
</ul></li>
<li><strong>Communication Tips:</strong>
<ul>
<li><strong>Pace:</strong> Speak clearly and avoid rushing.</li>
<li><strong>Emphasis:</strong> Highlight key points (e.g., “source of truth,” “automated pipelines,” “cross-team collaboration”).</li>
<li><strong>Engagement:</strong> Pause periodically to gauge the interviewer’s understanding and invite questions.</li>
<li><strong>Example:</strong> Use a concrete example to illustrate the benefits of a clean metadata repository. For example, “Imagine we need to debug a performance issue in production. With consistent metadata, we can quickly trace the model back to the training data and identify potential issues.”</li>
<li><strong>Mathematical Sections:</strong> You can mention that standard metrics for model performance such as accuracy, precision, recall, and F1 score are used to evaluate the validation of the model during the metadata creation process.</li>
</ul></li>
</ol>
<p>By following these steps, you can effectively convey your expertise and demonstrate your ability to address this complex problem.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>