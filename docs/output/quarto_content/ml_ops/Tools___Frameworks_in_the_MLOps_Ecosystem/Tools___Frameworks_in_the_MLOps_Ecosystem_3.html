<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>tools___frameworks_in_the_mlops_ecosystem_3</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../../">
<script src="../../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../site_libs/bootstrap/bootstrap-5d3fd86dc4559d58e199c8cc4a79ed5b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<section id="question-4.-in-real-world-scenarios-with-messy-and-frequently-changing-data-how-would-you-leverage-mlops-tools-to-ensure-data-integrity-reproducibility-and-adaptability-of-your-ml-pipeline" class="level2">
<h2 class="anchored" data-anchor-id="question-4.-in-real-world-scenarios-with-messy-and-frequently-changing-data-how-would-you-leverage-mlops-tools-to-ensure-data-integrity-reproducibility-and-adaptability-of-your-ml-pipeline">Question: 4. In real-world scenarios with messy and frequently changing data, how would you leverage MLOps tools to ensure data integrity, reproducibility, and adaptability of your ML pipeline?</h2>
<p><strong>Best Answer</strong></p>
<p>In real-world scenarios, data is rarely clean, consistent, or static. Handling “messy” and frequently changing data requires a robust MLOps strategy encompassing data integrity, reproducibility, and adaptability. Here’s a breakdown of how I would approach this, leveraging various MLOps tools and techniques:</p>
<p><strong>1. Data Integrity:</strong> Ensuring data quality throughout the pipeline.</p>
<ul>
<li><p><strong>Data Validation:</strong></p>
<ul>
<li><p><strong>Schema Validation:</strong> Enforce data schemas at the ingestion point. Tools like TensorFlow Data Validation (TFDV) are excellent for this. TFDV allows you to:</p>
<ul>
<li>Infer a schema from your training data.</li>
<li>Detect anomalies based on the inferred schema.</li>
<li>Freeze the schema and use it to validate incoming data during training and serving.</li>
<li>Detect schema drift by comparing the current data schema to the frozen schema.</li>
</ul>
<p>For example, we might define a schema requiring certain features to be numerical, within specific ranges, or having a limited number of categorical values. Any data violating this schema would trigger an alert and potentially halt pipeline execution.</p></li>
<li><p><strong>Statistical Validation:</strong> Beyond schema validation, perform statistical checks to detect anomalies. This includes:</p>
<ul>
<li><strong>Missing Value Ratio:</strong> Track the percentage of missing values for each feature. Alert if it exceeds a threshold.</li>
<li><strong>Outlier Detection:</strong> Use techniques like IQR (Interquartile Range), z-score, or clustering to identify and flag outliers.</li>
<li><strong>Data Distribution Analysis:</strong> Compare the distribution of features in the incoming data with the distribution in the training data. Tools like TFDV and Great Expectations provide functionalities for this.</li>
</ul></li>
<li><p><strong>Implementation:</strong> Tools like Great Expectations can be incorporated within an Airflow pipeline. Let’s say you have a data validation rule for the number of columns in a dataframe:</p></li>
</ul>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> great_expectations <span class="im">as</span> gx</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> validate_data(df: pd.DataFrame, expectation_suite_name: <span class="bu">str</span>) <span class="op">-&gt;</span> <span class="bu">bool</span>:</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co">    Validates a Pandas DataFrame against a Great Expectations suite.</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="co">        df: The Pandas DataFrame to validate.</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="co">        expectation_suite_name: The name of the Great Expectations suite.</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="co">        True if the validation is successful, False otherwise.</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    context <span class="op">=</span> gx.get_context()</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    batch <span class="op">=</span> context.get_batch_request(</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>        datasource_name<span class="op">=</span><span class="st">"your_datasource_name"</span>,  <span class="co"># Replace with your datasource name</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>        data_asset_name<span class="op">=</span><span class="st">"your_data_asset_name"</span>,    <span class="co"># Replace with your data asset name</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>        batch_spec_passthrough<span class="op">=</span>{<span class="st">"dataframe"</span>: df},</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    validator <span class="op">=</span> context.get_validator(</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>        batch_request<span class="op">=</span>batch,</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>        expectation_suite_name<span class="op">=</span>expectation_suite_name,</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>    results <span class="op">=</span> validator.validate()</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> results[<span class="st">"success"</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This function reads a dataframe and validates it with a Great Expectations expectation suite, and return success or failure. This function can be integrated into an Airflow DAG.</p></li>
<li><p><strong>Data Versioning:</strong></p>
<ul>
<li>Use tools like DVC (Data Version Control) to track changes to your datasets. This allows you to:
<ul>
<li>Reproduce experiments with specific data versions.</li>
<li>Track the lineage of your data.</li>
<li>Compare different data versions.</li>
</ul></li>
<li>Consider using cloud storage solutions (e.g., AWS S3, Google Cloud Storage) with versioning enabled.</li>
</ul></li>
</ul>
<p><strong>2. Reproducibility:</strong> Ensuring that the ML pipeline can be executed consistently and reliably.</p>
<ul>
<li><strong>Experiment Tracking:</strong>
<ul>
<li>Use tools like MLflow, Weights &amp; Biases (W&amp;B), or Neptune.ai to track all aspects of your experiments, including:
<ul>
<li>Code versions (using Git integration).</li>
<li>Data versions (using DVC or similar).</li>
<li>Hyperparameters.</li>
<li>Metrics (e.g., accuracy, loss).</li>
<li>Artifacts (e.g., trained models, data preprocessing scripts).</li>
</ul></li>
<li>This level of tracking is crucial for reproducing results and understanding the impact of data changes on model performance. For instance, we can track the model’s accuracy as a function of data version, allowing us to quickly identify if a data change has negatively affected the model.</li>
</ul></li>
<li><strong>Pipeline Orchestration:</strong>
<ul>
<li>Use workflow management platforms like Airflow, Kubeflow, or Prefect to define and orchestrate your ML pipelines.</li>
<li>These platforms provide:
<ul>
<li>Dependency management.</li>
<li>Scheduling.</li>
<li>Monitoring.</li>
<li>Automatic retries.</li>
</ul></li>
<li>By defining your pipeline as code, you ensure that it can be executed consistently across different environments.</li>
</ul></li>
<li><strong>Containerization:</strong>
<ul>
<li>Package your code and dependencies into Docker containers. This ensures that your pipeline runs in a consistent environment, regardless of the underlying infrastructure.</li>
</ul></li>
</ul>
<p><strong>3. Adaptability:</strong> Making the ML pipeline resilient to data drift and schema evolution.</p>
<ul>
<li><strong>Data Drift Detection:</strong>
<ul>
<li><p>Monitor your data for drift in real-time. This is crucial for ensuring that your model continues to perform well as the data distribution changes over time.</p></li>
<li><p>Techniques for drift detection include:</p>
<ul>
<li><strong>Statistical tests:</strong> Kolmogorov-Smirnov (KS) test, Chi-squared test, etc.</li>
<li><strong>Drift detection algorithms:</strong> Concept drift detection algorithms like ADWIN (Adaptive Windowing).</li>
<li><strong>Monitoring model performance:</strong> A significant drop in model performance is often an indicator of data drift.</li>
</ul></li>
<li><p>Tools like Evidently AI, Fiddler AI, and Arize AI are specifically designed for drift detection and model monitoring.</p></li>
<li><p>Formally, let <span class="math inline">\(p_0(x)\)</span> be the distribution of the training data and <span class="math inline">\(p_t(x)\)</span> be the distribution of the data at time <span class="math inline">\(t\)</span>. Data drift occurs when <span class="math inline">\(p_t(x)\)</span> differs significantly from <span class="math inline">\(p_0(x)\)</span>. We can use the Kolmogorov-Smirnov test to quantify this difference: <span class="math display">\[D = \sup_x |F_0(x) - F_t(x)|\]</span> where <span class="math inline">\(F_0(x)\)</span> and <span class="math inline">\(F_t(x)\)</span> are the cumulative distribution functions of <span class="math inline">\(p_0(x)\)</span> and <span class="math inline">\(p_t(x)\)</span>, respectively. A large value of <span class="math inline">\(D\)</span> indicates significant data drift.</p></li>
</ul></li>
<li><strong>Automated Retraining:</strong>
<ul>
<li>When data drift is detected, automatically trigger a retraining process.</li>
<li>This process should:
<ul>
<li>Fetch the latest data.</li>
<li>Re-train the model.</li>
<li>Evaluate the new model.</li>
<li>Deploy the new model if it meets performance criteria.</li>
</ul></li>
<li>Airflow or Kubeflow can be used to automate this retraining process.</li>
</ul></li>
<li><strong>Model Monitoring:</strong>
<ul>
<li>Continuously monitor the performance of your deployed models. This allows you to detect issues such as:
<ul>
<li>Decreasing accuracy.</li>
<li>Increasing latency.</li>
<li>Bias drift.</li>
</ul></li>
<li>Tools like Prometheus and Grafana can be used to monitor model performance metrics in real-time.</li>
</ul></li>
<li><strong>Feature Store:</strong>
<ul>
<li>Consider implementing a feature store such as Feast. A feature store allows us to reliably serve the same features used for training to our online serving environment, thus preventing training-serving skew and helping to maintain consistency despite changing data.</li>
</ul></li>
</ul>
<p><strong>Potential Issues and Solutions:</strong></p>
<ul>
<li><strong>Inconsistent Data Schemas:</strong> Use schema evolution techniques to handle changes to the data schema. This might involve:
<ul>
<li>Adding new columns to the schema.</li>
<li>Renaming columns.</li>
<li>Changing data types.</li>
</ul></li>
<li><strong>Delayed Drift Detection:</strong> Adjust the sensitivity of your drift detection algorithms to detect drift earlier. However, be careful not to trigger false alarms.</li>
<li><strong>Concept Drift:</strong> Address concept drift (changes in the relationship between input features and the target variable) by using online learning algorithms or by continuously retraining the model with new data.</li>
</ul>
<p>By implementing these strategies and leveraging the appropriate MLOps tools, we can build ML pipelines that are robust, reliable, and adaptable to the challenges of real-world data.</p>
<p><strong>How to Narrate</strong></p>
<p>Here’s how I’d structure my answer in an interview:</p>
<ol type="1">
<li><strong>Start with a High-Level Overview:</strong>
<ul>
<li>“In real-world scenarios, data is rarely perfect. My approach to handling messy and frequently changing data within an MLOps framework focuses on three core principles: data integrity, reproducibility, and adaptability.”</li>
</ul></li>
<li><strong>Data Integrity - Walk through Validation, Versioning:</strong>
<ul>
<li>“First, data integrity. This is about ensuring data quality. The core is data validation with tools like TensorFlow Data Validation (TFDV) and Great Expectations. With TFDV, we can define a schema and automatically detect anomalies.” <em>Briefly mention schema definition and anomaly detection.</em></li>
<li>“Then, statistical validation. We track metrics like missing value ratios, outliers, and data distribution. We want to catch any deviations from the norm and have a solid way to take action.” <em>Mention the key metrics and purpose.</em></li>
<li>“Data versioning is equally critical. We employ tools like DVC to track changes to datasets, allowing us to reproduce experiments with specific data versions and understand data lineage.” <em>Focus on the benefits of reproducibility and lineage.</em></li>
<li>“For example, an Airflow DAG can incorporate Great Expectations to ensure the dataframe has the right number of columns. If the validation fails, the DAG will stop, and we can investigate the issue.” <em>Illustrate with a succinct example.</em></li>
</ul></li>
<li><strong>Reproducibility - Experiment Tracking, Orchestration, Containerization:</strong>
<ul>
<li>“Next is reproducibility. Experiment tracking with MLflow, W&amp;B, or Neptune.ai helps us capture every detail of our experiments, from code versions to hyperparameters.” <em>Emphasize the comprehensive nature of the tracking.</em></li>
<li>“Pipeline orchestration is managed by Airflow or Kubeflow, enabling us to define pipelines as code, ensuring consistent execution across environments.” <em>Highlight the benefit of consistent execution and dependency management.</em></li>
<li>“We package our code and dependencies in Docker containers for a consistent runtime environment across different platforms.” <em>Mention containerization as a key factor for reproducibility.</em></li>
</ul></li>
<li><strong>Adaptability - Data Drift, Retraining, Monitoring:</strong>
<ul>
<li>“Adaptability is all about resilience to data drift. We use statistical tests like the Kolmogorov-Smirnov (KS) test, and drift detection algorithms such as ADWIN.” <em>Briefly explain how data drift is quantified.</em></li>
<li>“When data drift is detected, we automatically trigger a retraining process using Airflow or Kubeflow, fetching the latest data and redeploying the model, assuming performance criteria are met.” <em>Mention the automated nature of the retraining process.</em></li>
<li>“Finally, we constantly monitor our deployed models using tools like Prometheus and Grafana to spot any performance degradation, bias drift, or other issues.” <em>Focus on continuous monitoring for optimal performance.</em></li>
</ul></li>
<li><strong>Address Potential Issues:</strong>
<ul>
<li>“Of course, there are challenges. Inconsistent data schemas can be handled with schema evolution techniques. Delayed drift detection requires careful tuning of drift detection algorithms, and concept drift may necessitate online learning or continuous retraining.” <em>Briefly describe each challenge and its potential solution.</em></li>
</ul></li>
<li><strong>Conclude with a Summary:</strong>
<ul>
<li>“By integrating these MLOps strategies, we can build robust, reliable, and adaptable ML pipelines that perform effectively in the face of real-world data complexities.”</li>
</ul></li>
</ol>
<p><strong>Communication Tips:</strong></p>
<ul>
<li><strong>Pace Yourself:</strong> Don’t rush through the explanation. Give the interviewer time to digest the information.</li>
<li><strong>Use Visual Aids (If Possible):</strong> If you’re in a virtual interview, consider sharing your screen to show diagrams or code snippets.</li>
<li><strong>Check for Understanding:</strong> After explaining a complex concept, ask the interviewer if they have any questions.</li>
<li><strong>Stay Practical:</strong> Ground your answers in real-world examples and practical considerations.</li>
<li><strong>Emphasize the “Why”:</strong> Explain the reasoning behind each technique and its impact on the overall ML pipeline.</li>
<li><strong>Confidence:</strong> Speak with authority and conviction, demonstrating your deep understanding of the subject matter.</li>
<li><strong>Mathematical Notation:</strong> When discussing equations, briefly explain each term and its significance. For example, when presenting the KS test, say, “Here, D represents the maximum difference between the cumulative distribution functions. A larger D indicates more significant drift.”</li>
</ul>
<p>By following this structure, you can present a comprehensive and compelling answer that showcases your expertise in MLOps and your ability to handle real-world data challenges.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>