<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>tools___frameworks_in_the_mlops_ecosystem_4</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../../">
<script src="../../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../site_libs/bootstrap/bootstrap-5d3fd86dc4559d58e199c8cc4a79ed5b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<section id="question-5.-how-do-you-integrate-monitoring-and-logging-in-an-mlops-pipeline-and-what-tools-or-frameworks-would-you-use-for-detecting-model-drift-and-performance-degradation-in-production" class="level2">
<h2 class="anchored" data-anchor-id="question-5.-how-do-you-integrate-monitoring-and-logging-in-an-mlops-pipeline-and-what-tools-or-frameworks-would-you-use-for-detecting-model-drift-and-performance-degradation-in-production">Question: 5. How do you integrate monitoring and logging in an MLOps pipeline, and what tools or frameworks would you use for detecting model drift and performance degradation in production?</h2>
<p><strong>Best Answer</strong></p>
<p>Integrating monitoring and logging is a crucial aspect of an MLOps pipeline, ensuring model reliability, performance, and trustworthiness in production. It allows for proactive detection of issues like data drift, concept drift, and performance degradation, enabling timely interventions such as retraining, recalibration, or redeployment. Here’s a detailed breakdown:</p>
<p><strong>1. Importance of Monitoring and Logging:</strong></p>
<ul>
<li><strong>Early Issue Detection:</strong> Identify problems before they significantly impact business outcomes.</li>
<li><strong>Model Performance Tracking:</strong> Monitor key performance indicators (KPIs) over time.</li>
<li><strong>Root Cause Analysis:</strong> Facilitate debugging and understanding the causes of model failures or degradation.</li>
<li><strong>Data Drift Detection:</strong> Detect changes in input data distribution that can affect model accuracy.</li>
<li><strong>Concept Drift Detection:</strong> Identify changes in the relationship between input features and the target variable.</li>
<li><strong>Compliance and Auditability:</strong> Maintain a record of model behavior for regulatory compliance and auditing purposes.</li>
<li><strong>Continuous Improvement:</strong> Provide insights for model refinement and improvement.</li>
</ul>
<p><strong>2. Components of Monitoring and Logging in MLOps:</strong></p>
<ul>
<li><strong>Data Monitoring:</strong> Track characteristics of input data, such as mean, variance, missing values, and distributions. This helps detect data drift.</li>
<li><strong>Model Input Monitoring:</strong> Monitors the input features the model uses at inference time. Crucial for ensuring data quality and identifying unexpected input patterns.</li>
<li><strong>Prediction Monitoring:</strong> Focuses on analyzing the model’s output predictions. Are the predicted values within expected ranges? Are there any unusual patterns in the predictions?</li>
<li><strong>Performance Monitoring:</strong> Measure key metrics such as accuracy, precision, recall, F1-score, AUC, and latency.</li>
<li><strong>Infrastructure Monitoring:</strong> Track resource utilization (CPU, memory, disk I/O) to ensure the model is running efficiently and identify potential bottlenecks.</li>
<li><strong>Logging:</strong> Record events, errors, and debugging information throughout the pipeline. Includes model version, data version, timestamps, and user interactions.</li>
<li><strong>Alerting:</strong> Configure alerts based on predefined thresholds for metrics. Trigger alerts for deviations from expected behavior.</li>
</ul>
<p><strong>3. Tools and Frameworks:</strong></p>
<p>Several tools and frameworks can be used to implement monitoring and logging in MLOps:</p>
<ul>
<li><strong>Logging Infrastructure:</strong>
<ul>
<li><strong>ELK Stack (Elasticsearch, Logstash, Kibana):</strong> A popular open-source solution for centralized logging, indexing, and visualization. Logstash collects and processes logs, Elasticsearch stores them, and Kibana provides a user interface for querying and visualizing the data.</li>
<li><strong>Splunk:</strong> A commercial platform for log management, security information, and event management (SIEM).</li>
<li><strong>Fluentd:</strong> An open-source data collector that unifies the data collection and consumption for better use and understanding of data.</li>
<li><strong>Custom Logging Frameworks:</strong> For specialized needs, custom logging can be implemented using Python’s <code>logging</code> module or similar libraries in other languages. These can be integrated with cloud-based storage solutions (e.g., AWS S3, Google Cloud Storage, Azure Blob Storage).</li>
</ul></li>
<li><strong>Metrics Monitoring and Alerting:</strong>
<ul>
<li><strong>Prometheus:</strong> An open-source monitoring solution that collects metrics from various sources and stores them in a time-series database.</li>
<li><strong>Grafana:</strong> A data visualization tool that can be used to create dashboards from Prometheus metrics, providing real-time insights into model performance.</li>
<li><strong>CloudWatch (AWS):</strong> A monitoring service for AWS resources and applications.</li>
<li><strong>Azure Monitor:</strong> A monitoring service for Azure resources and applications.</li>
<li><strong>Google Cloud Monitoring:</strong> A monitoring service for Google Cloud resources and applications.</li>
<li><strong>StatsD:</strong> A network daemon for aggregating statistics.</li>
</ul></li>
<li><strong>Model Monitoring and Drift Detection:</strong>
<ul>
<li><strong>Evidently AI:</strong> An open-source library for evaluating, testing, and monitoring machine learning models in production. It provides tools for detecting data drift, concept drift, and performance degradation.</li>
<li><strong>MLflow:</strong> An open-source platform for the machine learning lifecycle, including experiment tracking, model management, and deployment. MLflow integrates with monitoring tools to track model performance in production.</li>
<li><strong>Seldon Core:</strong> An open-source platform for deploying and managing machine learning models on Kubernetes. It provides built-in monitoring capabilities and integrates with Prometheus and Grafana.</li>
<li><strong>Arize AI:</strong> A commercial model monitoring platform that provides advanced features for drift detection, performance analysis, and explainability.</li>
<li><strong>Fiddler AI:</strong> Another commercial model monitoring platform with a focus on explainable AI and bias detection.</li>
<li><strong>WhyLabs:</strong> A model monitoring platform that uses statistical analysis to detect anomalies and drift in model behavior.</li>
<li><strong>Custom Drift Detection Methods:</strong> Statistical tests like Kolmogorov-Smirnov test for continuous variables, Chi-squared test for categorical variables, or domain adaptation techniques can be used for custom drift detection implementations. Specifically, consider using Population Stability Index (PSI). The PSI is calculated as: <span class="math display">\[PSI = \sum_{i=1}^{N} (Actual_i - Expected_i) \times ln(\frac{Actual_i}{Expected_i})\]</span> where <span class="math inline">\(Actual_i\)</span> is the actual distribution in bin <span class="math inline">\(i\)</span> and <span class="math inline">\(Expected_i\)</span> is the expected distribution in bin <span class="math inline">\(i\)</span>. The typical rule of thumb for PSI is:
<ul>
<li>PSI &lt; 0.1: No significant change in population.</li>
<li>0.1 &lt;= PSI &lt; 0.2: Small shift in population.</li>
<li>PSI &gt;= 0.2: Significant shift in population.</li>
</ul></li>
</ul></li>
<li><strong>Orchestration and Automation:</strong>
<ul>
<li><strong>Kubeflow:</strong> An open-source machine learning platform for Kubernetes.</li>
<li><strong>Airflow:</strong> A workflow management platform for orchestrating complex data pipelines.</li>
</ul></li>
</ul>
<p><strong>4. Implementing Monitoring and Logging:</strong></p>
<p>The implementation process involves the following steps:</p>
<ol type="1">
<li><p><strong>Define Key Metrics:</strong> Identify the metrics that are most important for monitoring model performance and data quality. Examples include accuracy, precision, recall, F1-score, latency, data drift scores, and prediction distributions.</p></li>
<li><p><strong>Implement Logging:</strong> Add logging statements to your code to capture relevant events, errors, and debugging information. Use structured logging formats (e.g., JSON) to facilitate analysis.</p></li>
<li><p><strong>Collect Metrics:</strong> Integrate with monitoring tools to collect metrics from your model and infrastructure. This can be done using client libraries or agents that expose metrics in a standardized format (e.g., Prometheus).</p></li>
<li><p><strong>Visualize Data:</strong> Create dashboards using Grafana, Kibana, or other visualization tools to monitor metrics and identify trends.</p></li>
<li><p><strong>Configure Alerts:</strong> Set up alerts based on predefined thresholds for metrics. Configure alerts to be sent to appropriate channels (e.g., email, Slack, PagerDuty).</p></li>
<li><p><strong>Automate Retraining:</strong> Implement automated retraining pipelines that are triggered when drift is detected or performance degrades. This ensures that the model remains accurate and up-to-date.</p></li>
<li><p><strong>Establish Feedback Loops:</strong> Gather feedback from users and stakeholders to identify areas for improvement in the model and monitoring system.</p></li>
</ol>
<p><strong>5. Integration Challenges and Considerations:</strong></p>
<ul>
<li><strong>Scalability:</strong> Ensure that the monitoring and logging infrastructure can handle the volume of data generated by the model.</li>
<li><strong>Real-time Processing:</strong> Process metrics and logs in real-time to enable timely detection of issues.</li>
<li><strong>Security:</strong> Secure the monitoring and logging infrastructure to prevent unauthorized access.</li>
<li><strong>Cost Optimization:</strong> Optimize the cost of monitoring and logging by selecting the right tools and configuring them appropriately.</li>
<li><strong>Model Explainability:</strong> Integrate model explainability techniques to understand why the model is making certain predictions. This can help identify bias and improve trust in the model.</li>
<li><strong>Data Privacy:</strong> Ensure that sensitive data is handled appropriately in the monitoring and logging system.</li>
</ul>
<p><strong>6. Example Scenario: Fraud Detection Model</strong></p>
<ul>
<li><strong>Data Monitoring:</strong> Track the distribution of transaction amounts, the number of transactions per user, and the frequency of different transaction types.</li>
<li><strong>Model Input Monitoring:</strong> Monitor the incoming features of the model: transaction amount, time of day, location, etc.</li>
<li><strong>Prediction Monitoring:</strong> Monitor the distribution of predicted fraud scores. Alert if the average fraud score increases significantly.</li>
<li><strong>Performance Monitoring:</strong> Track precision, recall, and F1-score of the fraud detection model. Alert if the F1-score drops below a predefined threshold.</li>
<li><strong>Logging:</strong> Log all transactions, model predictions, and any errors that occur during the inference process.</li>
<li><strong>Drift Detection:</strong> Use Evidently AI to detect data drift in the transaction data. If drift is detected, trigger a retraining pipeline.</li>
</ul>
<p><strong>In conclusion, integrating monitoring and logging is essential for building reliable and trustworthy MLOps pipelines. By carefully selecting the right tools and implementing a robust monitoring strategy, organizations can ensure that their models are performing optimally and delivering value.</strong></p>
<p><strong>How to Narrate</strong></p>
<p>Here’s how I would articulate this answer in an interview:</p>
<ol type="1">
<li><p><strong>Start with the “Why”:</strong> “Monitoring and logging are <em>critical</em> in MLOps because they’re our eyes and ears in production. They allow us to proactively detect issues, ensure model reliability, and maintain trust in our AI systems. Without them, we’re essentially flying blind.”</p></li>
<li><p><strong>Break Down the Key Components:</strong> “The monitoring system needs to have several components. First, <strong>data monitoring</strong> focuses on input data characteristics to detect drift, things like mean, variance, and distribution. Then, we need to monitor the <strong>model input features</strong> to ensure quality. <strong>Prediction monitoring</strong> looks at the model’s output and we can track the distribution of predictions. <strong>Performance monitoring</strong> measures accuracy, precision, recall, and latency. And finally, <strong>infrastructure monitoring</strong> tracks resource utilization.”</p></li>
<li><p><strong>Introduce Tools Strategically:</strong> “There are lots of great tools out there. For <strong>logging</strong>, the ELK stack is very common, and can be used for centralized logging, and visualization. Then for <strong>metrics</strong> and alerting, Prometheus is a go-to, often paired with Grafana for dashboards.”</p></li>
<li><p><strong>Deep Dive into Drift Detection:</strong> “Drift detection is a bit more specialized. I’ve used Evidently AI extensively, it is an open-source library that is effective. Commercial platforms like Arize AI and Fiddler AI offer advanced capabilities, especially for explainability. Also, one can implement custom methods for drift detections such as utilizing Kolmogorov-Smirnov tests, or population stability indexes. The PSI calculation involves comparing the actual distribution of a variable to its expected distribution, giving a score for how much the population has shifted. A PSI over 0.2 generally indicates significant shift and may warrant retraining. The formula is <psi calculation="" formula="">.”</psi></p></li>
<li><p><strong>Discuss Integration and Challenges:</strong> “The biggest challenge is integrating all these components into a cohesive pipeline. It has to be scalable to handle production volumes and process data in near real-time. We also have to think about security and cost optimization.”</p></li>
<li><p><strong>Use the Fraud Detection Example:</strong> “For example, let’s say we’re deploying a fraud detection model. We’d monitor things like transaction amounts, user activity, and predicted fraud scores. If we detect data drift or a drop in performance, we automatically trigger a retraining pipeline. It’s all about closing the loop.”</p></li>
<li><p><strong>Pause for Questions:</strong> Throughout the explanation, pause periodically and ask, “Does that make sense?” or “Any questions about that?”. Encourage interaction to gauge the interviewer’s understanding and tailor the explanation accordingly.</p></li>
<li><p><strong>Communicate Confidence, Not Arrogance:</strong> Speak clearly and confidently, but avoid being overly technical or using jargon. Focus on explaining the concepts in a way that is easy to understand.</p></li>
</ol>
<p>By following this approach, I can demonstrate my expertise in MLOps monitoring and logging while keeping the interviewer engaged and informed.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>