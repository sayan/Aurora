<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.41">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>tools___frameworks_in_the_mlops_ecosystem_0</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../../">
<script src="../../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../site_libs/quarto-html/quarto-syntax-highlighting-48ffa3e5b9d089919c6712c39e5b00f2.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../site_libs/bootstrap/bootstrap-a37d0bf9d509de95c1ba4621f20add8c.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<section id="question-1.-what-is-mlops-and-how-do-tools-frameworks-such-as-kubeflow-mlflow-and-airflow-support-the-end-to-end-lifecycle-of-machine-learning-models" class="level2">
<h2 class="anchored" data-anchor-id="question-1.-what-is-mlops-and-how-do-tools-frameworks-such-as-kubeflow-mlflow-and-airflow-support-the-end-to-end-lifecycle-of-machine-learning-models">Question: 1. What is MLOps and how do tools &amp; frameworks such as Kubeflow, MLflow, and Airflow support the end-to-end lifecycle of machine learning models?</h2>
<p><strong>Best Answer</strong></p>
<p>MLOps, short for Machine Learning Operations, is a set of practices that aims to automate and streamline the machine learning lifecycle. It’s essentially applying DevOps principles to machine learning, focusing on collaboration, reproducibility, version control, automation, and continuous monitoring of ML systems. The core idea is to bring ML models out of isolated research environments and reliably deploy and maintain them in production.</p>
<p>The ML lifecycle can be broken down into several key stages:</p>
<ol type="1">
<li><p><strong>Data Engineering:</strong> Involves data collection, cleaning, validation, transformation, and preparation. This stage ensures data quality and readiness for model training.</p></li>
<li><p><strong>Model Development/Experimentation:</strong> ML engineers and data scientists build and train models. This includes feature engineering, algorithm selection, hyperparameter tuning, and model evaluation. The goal is to find the best-performing model.</p></li>
<li><p><strong>Model Deployment:</strong> Making the trained model available to serve predictions in a production environment. This may involve containerization, API creation, and infrastructure provisioning.</p></li>
<li><p><strong>Model Monitoring:</strong> Continuously tracking model performance, data drift, and prediction quality. This stage helps identify model degradation and triggers retraining if necessary.</p></li>
<li><p><strong>Model Retraining:</strong> Re-training the model with new data or updated parameters to maintain performance. This may be triggered automatically based on monitoring alerts.</p></li>
</ol>
<p>Tools like Kubeflow, MLflow, and Airflow play significant roles in supporting each of these stages and the overall MLOps lifecycle:</p>
<ul>
<li><p><strong>MLflow:</strong> This is an open-source platform to manage the ML lifecycle, including experimentation, reproducibility, deployment, and a central model registry. It addresses the crucial aspects of tracking experiments, packaging code into reproducible runs, and managing and deploying models. It comprises four main components:</p>
<ul>
<li><p><strong>MLflow Tracking:</strong> An API and UI for logging parameters, code versions, metrics, and artifacts when running ML code. It supports organizing runs into experiments and comparing results. This helps in understanding how hyperparameters affect model performance. For example, we might log the learning rate, the number of layers, and the loss function used in an experiment, along with the resulting accuracy and F1-score.</p>
<ul>
<li>Mathematically, let’s say we are tuning a model with parameters <span class="math inline">\(\theta\)</span>. MLflow Tracking allows us to track the relationship between <span class="math inline">\(\theta\)</span> and the resulting metric <span class="math inline">\(M(\theta)\)</span>. <span class="math display">\[ M(\theta) = \text{Evaluation Metric (e.g., Accuracy)} \]</span> We can then compare different configurations of <span class="math inline">\(\theta\)</span> to optimize <span class="math inline">\(M\)</span>.</li>
</ul></li>
<li><p><strong>MLflow Projects:</strong> A standard format for packaging ML code in a reproducible way. It specifies dependencies and entry points, allowing you to run projects on different platforms. This ensures that the same code will produce the same results regardless of the execution environment. It usually uses conda environments.</p></li>
<li><p><strong>MLflow Models:</strong> A standard format for saving and loading models, defining a standard way to serialize and deserialize models, making it easier to deploy them in various environments. It supports various model types, including scikit-learn, TensorFlow, PyTorch, and more.</p>
<ul>
<li>If <span class="math inline">\(f(x; \theta)\)</span> represents our model with input <span class="math inline">\(x\)</span> and parameters <span class="math inline">\(\theta\)</span>, the MLflow Model component provides a standardized way to save this function (model) along with its metadata, dependencies, and input/output schemas.</li>
</ul></li>
<li><p><strong>MLflow Registry:</strong> A central repository to collaboratively manage the full lifecycle of MLflow Models. It provides model lineage, model versioning, stage transitions (e.g., staging, production, archived), and annotations.</p></li>
</ul></li>
<li><p><strong>Kubeflow:</strong> A Kubernetes-native platform for developing, deploying, and managing ML workflows. It simplifies the deployment and scaling of ML models on Kubernetes clusters, making it easier to manage complex ML pipelines.</p>
<ul>
<li>Kubeflow Pipelines: A component of Kubeflow that allows you to build and manage end-to-end ML workflows. Each step in the pipeline can be containerized, making it reproducible and scalable. It makes use of a directed acyclic graph (DAG) to define the workflow.
<ul>
<li>The nodes in the DAG represent the components of the pipeline, and the edges represent the data dependencies between them.</li>
</ul></li>
<li>Training Operators: Kubeflow provides custom Kubernetes operators for training various types of models, including TensorFlow, PyTorch, and XGBoost. These operators simplify the process of distributed training and hyperparameter tuning.
<ul>
<li>For example, the TFJob operator allows you to define a TensorFlow training job as a Kubernetes resource. Kubeflow handles the creation of the necessary pods and services to run the training job.</li>
</ul></li>
<li>Serving: Kubeflow simplifies the process of deploying models for online prediction using tools like KFServing (now v2 Inference). It supports features like canary deployments, traffic splitting, and autoscaling.
<ul>
<li>For example, one might deploy a new model version as a canary to a small percentage of users to test its performance before rolling it out to the entire user base.</li>
</ul></li>
</ul></li>
<li><p><strong>Airflow:</strong> A workflow management platform for authoring, scheduling, and monitoring workflows as directed acyclic graphs (DAGs). In the context of MLOps, Airflow is used to orchestrate ML pipelines, including data preprocessing, model training, and deployment. It is particularly useful for scheduling recurring tasks and managing dependencies between them.</p>
<ul>
<li>Airflow allows you to define complex ML workflows as a series of tasks, each represented as a node in the DAG. Tasks can include running data preprocessing scripts, training models, evaluating model performance, and deploying models to production.</li>
<li>Airflow provides features for monitoring the status of tasks, retrying failed tasks, and triggering alerts when errors occur. This helps ensure the reliability of the ML pipeline.</li>
<li>Consider an example where a model needs to be retrained every week with new data. Airflow can be used to schedule a DAG that extracts the data, preprocesses it, trains the model, evaluates it, and deploys it, all automatically.</li>
</ul></li>
</ul>
<p>Here’s a table summarizing the key contributions of each tool:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 7%">
<col style="width: 55%">
<col style="width: 36%">
</colgroup>
<thead>
<tr class="header">
<th>Tool</th>
<th>Key Functionality</th>
<th>MLOps Stage Supported</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>MLflow</td>
<td>Experiment tracking, reproducible runs, model management, model registry</td>
<td>Model Development/Experimentation, Model Deployment</td>
</tr>
<tr class="even">
<td>Kubeflow</td>
<td>Kubernetes-native ML workflow orchestration, training operators, model serving</td>
<td>Model Deployment, Model Monitoring, Model Retraining</td>
</tr>
<tr class="odd">
<td>Airflow</td>
<td>Workflow scheduling, dependency management, monitoring</td>
<td>Data Engineering, Model Deployment, Model Retraining</td>
</tr>
</tbody>
</table>
<p>In summary, MLOps is crucial for enabling organizations to reliably deploy and manage ML models in production. Tools like Kubeflow, MLflow, and Airflow play vital roles in automating and streamlining different stages of the ML lifecycle, enabling data scientists and ML engineers to collaborate effectively and deliver value from ML projects. They allow for faster iteration, better reproducibility, and improved model performance in real-world applications.</p>
<p><strong>How to Narrate</strong></p>
<p>Here’s a step-by-step guide on how to articulate this answer in an interview:</p>
<ol type="1">
<li><p><strong>Start with a Clear Definition of MLOps:</strong></p>
<ul>
<li>Begin by stating, “MLOps, or Machine Learning Operations, is essentially applying DevOps principles to the ML lifecycle, focusing on automation, collaboration, and continuous monitoring. It aims to bridge the gap between model development and deployment.”</li>
</ul></li>
<li><p><strong>Explain the ML Lifecycle Briefly:</strong></p>
<ul>
<li>“The ML lifecycle consists of several key stages, including data engineering, model development and experimentation, model deployment, model monitoring, and model retraining. Each of these stages requires specific processes and tools.” Briefly describe each stage.</li>
</ul></li>
<li><p><strong>Introduce MLflow and Its Components:</strong></p>
<ul>
<li><p>“MLflow is an open-source platform designed to manage the entire ML lifecycle. It consists of four main components: Tracking, Projects, Models, and Registry.”</p></li>
<li><p>For <strong>MLflow Tracking</strong>, say something like, “MLflow Tracking helps log parameters, metrics, and artifacts during experiments. For instance, when tuning a model, we can track how different learning rates or network architectures affect the model’s accuracy.” Mention the equation <span class="math inline">\(M(\theta)\)</span> and explain in plain terms: “Essentially, we are trying to find the best set of parameters that maximizes our evaluation metric.”</p></li>
<li><p>For <strong>MLflow Projects</strong>, explain that it ensures reproducibility, “MLflow Projects standardize how ML code is packaged, ensuring the same code produces consistent results across different environments. This avoids ‘it works on my machine’ issues.”</p></li>
<li><p>For <strong>MLflow Models</strong>, emphasize its role in standardization, “MLflow Models provide a standard format for saving and loading models. This makes it easier to deploy models in various environments, such as serving endpoints or batch processing pipelines.” You might mention that <span class="math inline">\(f(x; \theta)\)</span> is saved in a way that anyone can load it, knowing what to expect for input and output.</p></li>
<li><p>For <strong>MLflow Registry</strong>, highlight its role in collaboration and governance, “MLflow Registry provides a centralized hub for managing model versions, stages (like staging and production), and metadata. This promotes collaboration and ensures governance over the model deployment process.”</p></li>
</ul></li>
<li><p><strong>Discuss Kubeflow and its Kubernetes Integration:</strong></p>
<ul>
<li><p>“Kubeflow is a Kubernetes-native platform for deploying and managing ML workflows. Its strength lies in simplifying the deployment and scaling of ML models on Kubernetes clusters.”</p></li>
<li><p>Explain <strong>Kubeflow Pipelines</strong> by saying, “Kubeflow Pipelines allow you to build end-to-end ML workflows where each step is containerized. This makes the process reproducible and scalable. Think of it as a graph where each node is a step in your ML process.”</p></li>
<li><p>For <strong>Training Operators</strong>, mention, “Kubeflow provides custom Kubernetes operators for training models like TensorFlow and PyTorch. These operators handle the complexities of distributed training and hyperparameter tuning, allowing data scientists to focus on model development.”</p></li>
<li><p>For <strong>Serving</strong>, highlight key features, “Kubeflow simplifies model deployment for online prediction using tools like KFServing. It supports features like canary deployments and autoscaling, ensuring high availability and performance.”</p></li>
</ul></li>
<li><p><strong>Explain Airflow for Workflow Orchestration:</strong></p>
<ul>
<li><p>“Airflow is a workflow management platform used to schedule and monitor ML pipelines. It allows you to define complex workflows as directed acyclic graphs, making it easy to manage dependencies and automate recurring tasks.”</p></li>
<li><p>Provide an example: “For example, imagine retraining a model weekly. Airflow can automate the entire process: extracting data, preprocessing it, training the model, evaluating its performance, and deploying the updated model – all without manual intervention.”</p></li>
</ul></li>
<li><p><strong>Summarize the Roles:</strong></p>
<ul>
<li>“In summary, MLflow handles experiment tracking and model management, Kubeflow focuses on deployment and scaling on Kubernetes, and Airflow orchestrates complex workflows. They all contribute to streamlining the MLOps lifecycle.”</li>
</ul></li>
<li><p><strong>Highlight the Importance of MLOps:</strong></p>
<ul>
<li>Conclude by saying, “MLOps is crucial for organizations to reliably deploy and manage ML models in production, enabling faster iteration, better reproducibility, and improved model performance in real-world applications. By embracing MLOps principles and tools, organizations can unlock the full potential of their ML projects.”</li>
</ul></li>
</ol>
<p><strong>Communication Tips:</strong></p>
<ul>
<li><p><strong>Pace Yourself:</strong> Don’t rush through the explanation. Give the interviewer time to process the information.</p></li>
<li><p><strong>Use Plain Language:</strong> Avoid overly technical jargon when possible. Explain concepts in a clear and concise manner.</p></li>
<li><p><strong>Emphasize Practical Applications:</strong> Connect the concepts to real-world scenarios to demonstrate your understanding of how these tools are used in practice.</p></li>
<li><p><strong>Check for Understanding:</strong> Pause periodically and ask if the interviewer has any questions. This shows that you are engaged and want to ensure they are following along.</p></li>
<li><p><strong>Be Confident:</strong> Speak clearly and confidently, demonstrating your expertise in the subject matter.</p></li>
<li><p><strong>Adjust to the Interviewer:</strong> Gauge the interviewer’s level of technical expertise and adjust your explanation accordingly. If they seem very technical, you can go into more detail. If they are less technical, focus on the high-level concepts and practical applications.</p></li>
</ul>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>