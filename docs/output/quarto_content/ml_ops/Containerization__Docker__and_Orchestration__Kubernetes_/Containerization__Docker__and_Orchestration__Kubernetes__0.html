<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>containerization__docker__and_orchestration__kubernetes__0</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../../">
<script src="../../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../site_libs/bootstrap/bootstrap-5d3fd86dc4559d58e199c8cc4a79ed5b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<section id="question-can-you-explain-the-concept-of-containerization-and-how-docker-differs-from-traditional-virtual-machines-in-terms-of-architecture-and-resource-utilization" class="level2">
<h2 class="anchored" data-anchor-id="question-can-you-explain-the-concept-of-containerization-and-how-docker-differs-from-traditional-virtual-machines-in-terms-of-architecture-and-resource-utilization">Question: Can you explain the concept of containerization and how Docker differs from traditional virtual machines in terms of architecture and resource utilization?</h2>
<p><strong>Best Answer</strong></p>
<p>Containerization is a form of operating system virtualization where applications are run in isolated user spaces, called containers. These containers share the host OS kernel, but each container has its own file system, processes, network interfaces, and other dependencies, isolated from the host system and other containers. This isolation ensures that applications running in different containers do not interfere with each other, even if they depend on conflicting libraries or software versions.</p>
<p><strong>Key Concepts of Containerization:</strong></p>
<ul>
<li><strong>Isolation:</strong> Containers isolate applications and their dependencies from the underlying host system and other containers.</li>
<li><strong>Portability:</strong> Containers package an application and all its dependencies into a single unit, making it easy to move the application between different environments (e.g., development, testing, production) without worrying about compatibility issues.</li>
<li><strong>Lightweight:</strong> Containers are lightweight because they share the host OS kernel and do not require a full guest OS. This reduces overhead and improves resource utilization.</li>
<li><strong>Efficiency:</strong> Containers are more efficient than virtual machines (VMs) because they consume fewer resources and start up faster.</li>
</ul>
<p><strong>Docker vs.&nbsp;Virtual Machines:</strong></p>
<p>The fundamental difference between Docker and VMs lies in their architectural approaches to virtualization.</p>
<ul>
<li><p><strong>Virtual Machines (VMs):</strong> VMs use hardware virtualization. Each VM runs its own full-fledged operating system (guest OS) on top of a hypervisor, which sits either directly on the hardware (Type 1 hypervisor like Xen, VMware ESXi) or on top of a host OS (Type 2 hypervisor like VMware Workstation, VirtualBox). The hypervisor allocates resources (CPU, memory, storage) to each VM.</p>
<ul>
<li><strong>Architecture:</strong> Host OS -&gt; Hypervisor -&gt; Guest OS -&gt; Application</li>
<li><strong>Resource Utilization:</strong> High, because each VM requires its own OS, kernel, and system utilities, resulting in significant overhead.</li>
</ul></li>
<li><p><strong>Docker (Containers):</strong> Docker uses OS-level virtualization. Instead of virtualizing the hardware, Docker virtualizes the operating system. Containers share the host OS kernel but are isolated from each other through namespaces and cgroups. Docker containers package the application and its dependencies into a single image, which can then be deployed on any system with the Docker runtime.</p>
<ul>
<li><strong>Architecture:</strong> Host OS (with Docker Engine) -&gt; Containers (Application + Dependencies)</li>
<li><strong>Resource Utilization:</strong> Low, because containers share the host OS kernel and do not require a separate OS, resulting in less overhead.</li>
</ul></li>
</ul>
<p><strong>Comparison Table:</strong></p>
<table class="caption-top table">
<colgroup>
<col style="width: 13%">
<col style="width: 39%">
<col style="width: 46%">
</colgroup>
<thead>
<tr class="header">
<th>Feature</th>
<th>Docker (Containers)</th>
<th>Virtual Machines (VMs)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Virtualization</td>
<td>OS-level</td>
<td>Hardware-level</td>
</tr>
<tr class="even">
<td>OS</td>
<td>Shares host OS kernel</td>
<td>Each VM has its own guest OS</td>
</tr>
<tr class="odd">
<td>Size</td>
<td>Smaller (MBs)</td>
<td>Larger (GBs)</td>
</tr>
<tr class="even">
<td>Boot Time</td>
<td>Seconds</td>
<td>Minutes</td>
</tr>
<tr class="odd">
<td>Resource Usage</td>
<td>Lower</td>
<td>Higher</td>
</tr>
<tr class="even">
<td>Isolation</td>
<td>Processes are isolated using namespaces &amp; cgroups</td>
<td>Full OS isolation via hypervisor</td>
</tr>
<tr class="odd">
<td>Portability</td>
<td>Highly portable, using Docker images</td>
<td>Portable, but can be affected by hardware and OS specifics</td>
</tr>
<tr class="even">
<td>Overhead</td>
<td>Minimal</td>
<td>Significant</td>
</tr>
</tbody>
</table>
<p><strong>Resource Utilization Details</strong></p>
<p>Let’s consider the overhead in terms of memory and storage. A typical VM might require several gigabytes of disk space for the OS image and consume hundreds of megabytes to gigabytes of RAM just to run the OS. In contrast, a Docker container might only require a few megabytes of disk space and consume significantly less RAM since it shares the host OS kernel.</p>
<p>Mathematically, we can represent the resource consumption as follows:</p>
<ul>
<li><p><strong>VM:</strong></p>
<p><span class="math display">\[
R_{VM} = R_{OS} + R_{App} + R_{Hypervisor}
\]</span></p>
<p>where:</p>
<ul>
<li><span class="math inline">\(R_{VM}\)</span> is the total resource consumption of the VM.</li>
<li><span class="math inline">\(R_{OS}\)</span> is the resource consumption of the guest OS.</li>
<li><span class="math inline">\(R_{App}\)</span> is the resource consumption of the application.</li>
<li><span class="math inline">\(R_{Hypervisor}\)</span> is the overhead introduced by the hypervisor.</li>
</ul></li>
<li><p><strong>Container:</strong></p>
<p><span class="math display">\[
R_{Container} = R_{App} + R_{Docker}
\]</span></p>
<p>where:</p>
<ul>
<li><span class="math inline">\(R_{Container}\)</span> is the total resource consumption of the container.</li>
<li><span class="math inline">\(R_{App}\)</span> is the resource consumption of the application.</li>
<li><span class="math inline">\(R_{Docker}\)</span> is the overhead introduced by the Docker engine, which is significantly smaller than <span class="math inline">\(R_{OS} + R_{Hypervisor}\)</span>.</li>
</ul></li>
</ul>
<p><strong>Use Cases:</strong></p>
<ul>
<li><strong>Docker:</strong> Ideal for microservices architectures, continuous integration/continuous deployment (CI/CD) pipelines, and applications that need to be deployed quickly and efficiently.</li>
<li><strong>VMs:</strong> Suitable for applications that require strong isolation, different operating systems, or direct hardware access.</li>
</ul>
<p><strong>Real-world Considerations:</strong></p>
<ul>
<li><strong>Security:</strong> While containers provide isolation, they are not as isolated as VMs. A vulnerability in the host OS kernel can potentially affect all containers. Security best practices, such as using minimal base images and regularly patching the host OS, are crucial.</li>
<li><strong>Orchestration:</strong> Docker containers are often managed using orchestration tools like Kubernetes, which automate the deployment, scaling, and management of containerized applications.</li>
</ul>
<p><strong>In summary:</strong> Docker and containerization offer a lightweight, portable, and efficient alternative to traditional VMs, particularly well-suited for modern application development and deployment practices.</p>
<p><strong>How to Narrate</strong></p>
<p>Here’s a step-by-step guide on delivering this answer in an interview:</p>
<ol type="1">
<li><strong>Start with the Definition:</strong>
<ul>
<li>“Containerization is a form of OS-level virtualization where applications are run in isolated user spaces called containers. These containers share the host OS kernel, providing isolation and portability.”</li>
</ul></li>
<li><strong>Highlight Key Benefits:</strong>
<ul>
<li>“The key benefits include isolation, meaning applications don’t interfere with each other; portability, making it easy to move applications between environments; and being lightweight, improving resource utilization.”</li>
</ul></li>
<li><strong>Explain the Core Difference: Docker vs VMs:</strong>
<ul>
<li>“The fundamental difference lies in their architecture. VMs virtualize hardware, requiring a full guest OS for each instance, while Docker virtualizes the OS, sharing the kernel.”</li>
<li>“Think of VMs as running entire separate computers on your machine, while Docker containers are like isolated applications that share the computer’s core operating system.”</li>
</ul></li>
<li><strong>Describe VM Architecture (If asked for more depth):</strong>
<ul>
<li>“VMs run on a hypervisor, which can be Type 1, running directly on hardware, or Type 2, running on top of an OS. Each VM has its own OS, consuming significant resources.”</li>
</ul></li>
<li><strong>Describe Docker Architecture:</strong>
<ul>
<li>“Docker containers run on the host OS, managed by the Docker Engine. They package the application and its dependencies, using namespaces and cgroups for isolation.”</li>
</ul></li>
<li><strong>Use a clear analogy:</strong>
<ul>
<li>“Imagine an apartment building (Host OS) vs.&nbsp;individual houses (VMs). In the apartment, tenants (containers) share common resources like electricity and plumbing (OS kernel), making it more efficient than each tenant having their own separate house with its own utilities (VMs).”</li>
</ul></li>
<li><strong>Mention Resource Utilization with math (Optionally, if the interviewer seems technically engaged):</strong>
<ul>
<li>“The lower overhead of containers is clear when looking at resource consumption.”</li>
<li>“In VMs, you have the resources of the Guest OS, the application, and the Hypervisor: <span class="math inline">\(R_{VM} = R_{OS} + R_{App} + R_{Hypervisor}\)</span>.”</li>
<li>“For Containers, it’s just the application and the Docker overhead: <span class="math inline">\(R_{Container} = R_{App} + R_{Docker}\)</span>.”</li>
<li>“The Docker overhead is considerably less, explaining the significant difference.”</li>
</ul></li>
<li><strong>Provide a comparison table (If the interviewer is visually inclined):</strong>
<ul>
<li>“To summarize, here’s a brief comparison. [Refer to the table in the Best Answer].”</li>
</ul></li>
<li><strong>Discuss Use Cases:</strong>
<ul>
<li>“Docker is ideal for microservices and CI/CD pipelines, while VMs are better for applications needing strong isolation or different OS requirements.”</li>
</ul></li>
<li><strong>Address Real-World Considerations:</strong>
<ul>
<li>“It’s important to consider security; while containers provide isolation, they aren’t as isolated as VMs. Also, orchestration tools like Kubernetes are vital for managing Docker containers at scale.”</li>
</ul></li>
<li><strong>Summarize:</strong>
<ul>
<li>“In conclusion, Docker offers a lightweight and efficient alternative to VMs, particularly valuable for modern application development, but it’s crucial to understand both their strengths and weaknesses.”</li>
</ul></li>
</ol>
<p><strong>Communication Tips:</strong></p>
<ul>
<li><strong>Pace Yourself:</strong> Don’t rush through the explanation. Take your time to articulate each point clearly.</li>
<li><strong>Use Simple Language:</strong> Avoid jargon unless necessary, and explain technical terms if you use them.</li>
<li><strong>Engage the Interviewer:</strong> Watch their body language and adjust your explanation based on their level of understanding. Ask if they have any questions.</li>
<li><strong>Be Confident:</strong> Project confidence in your knowledge. Even if you’re unsure about a detail, focus on what you do know and explain it clearly.</li>
<li><strong>Be Concise:</strong> While providing a comprehensive explanation is important, avoid rambling. Stick to the key points and be mindful of the interviewer’s time.</li>
<li><strong>Math Transparency</strong>: When discussing resource usage and equations, emphasize that the equations are to illustrate the concept and don’t delve into extremely detailed calculations unless prompted.</li>
</ul>
<p>By following these steps and tips, you can effectively communicate your understanding of containerization and the differences between Docker and VMs, demonstrating your senior-level expertise.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>