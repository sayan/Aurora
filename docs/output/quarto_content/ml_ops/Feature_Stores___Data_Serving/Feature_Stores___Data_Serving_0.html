<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.41">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>feature_stores___data_serving_0</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../../">
<script src="../../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../site_libs/quarto-html/quarto-syntax-highlighting-48ffa3e5b9d089919c6712c39e5b00f2.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../site_libs/bootstrap/bootstrap-a37d0bf9d509de95c1ba4621f20add8c.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<section id="question-1.-what-is-a-feature-store-and-why-is-it-essential-in-modern-machine-learning-pipelines" class="level2">
<h2 class="anchored" data-anchor-id="question-1.-what-is-a-feature-store-and-why-is-it-essential-in-modern-machine-learning-pipelines">Question: 1. What is a feature store and why is it essential in modern machine learning pipelines?</h2>
<p><strong>Best Answer</strong></p>
<p>A feature store is a centralized management layer for machine learning features. It serves as a single source of truth for feature definitions, storage, and access, making features discoverable and reusable across multiple models and teams. In essence, it’s the bridge between data engineering, data science, and MLOps. It addresses the challenges of feature engineering, consistency, and serving in complex ML pipelines.</p>
<p><strong>Key Components and Functionality:</strong></p>
<ol type="1">
<li><strong>Feature Definition &amp; Metadata Management:</strong>
<ul>
<li>Stores the definitions of features, including their data types, sources, transformations, and lineage. This ensures consistency and avoids feature drift. Metadata management allows easy discovery and tracking of features.</li>
<li>A well-defined schema, including data types, validation rules, and descriptions, ensures that features are consistent and reliable.</li>
</ul></li>
<li><strong>Feature Storage:</strong>
<ul>
<li>Provides both online and offline storage.
<ul>
<li><strong>Offline Store:</strong> Designed for batch processing, model training, and historical analysis. Typically uses data warehouses or data lakes like Snowflake, BigQuery, or S3.</li>
<li><strong>Online Store:</strong> Optimized for low-latency feature retrieval during real-time inference. Often implemented with key-value stores like Redis, Cassandra, or DynamoDB.</li>
</ul></li>
</ul></li>
<li><strong>Feature Serving:</strong>
<ul>
<li>Offers APIs or SDKs to retrieve features for training and inference. These interfaces abstract away the complexities of data access, transformation, and joining.</li>
<li>Supports both batch and real-time feature retrieval.</li>
</ul></li>
<li><strong>Feature Engineering &amp; Transformation:</strong>
<ul>
<li>Integrates with feature engineering tools and pipelines, allowing data scientists to define and apply transformations.</li>
<li>Some feature stores offer built-in transformation capabilities or integrate with external transformation engines like Apache Spark or Dask.</li>
</ul></li>
<li><strong>Monitoring &amp; Governance:</strong>
<ul>
<li>Provides tools for monitoring feature quality, usage, and performance.</li>
<li>Enforces access control and data governance policies.</li>
<li>Tracks feature lineage to understand the provenance of features and their impact on model performance.</li>
</ul></li>
</ol>
<p><strong>Why Feature Stores are Essential:</strong></p>
<ol type="1">
<li><p><strong>Feature Reuse:</strong> Without a feature store, teams often duplicate effort in engineering the same features, leading to inconsistencies and wasted resources. A feature store promotes reuse by making features discoverable and accessible across the organization.</p></li>
<li><p><strong>Consistency Between Training and Inference:</strong> One of the biggest challenges in ML is ensuring consistency between the training and inference environments. This is often referred to as training-serving skew.</p>
<ul>
<li><strong>Training:</strong> During training, models are trained using historical data, often processed in batch using frameworks like Spark.</li>
<li><strong>Inference:</strong> During inference, models need to make predictions in real-time based on fresh data. The data pipelines for training and inference are often different, leading to discrepancies in feature values.</li>
</ul>
<p>The feature store solves this by:</p>
<ul>
<li><strong>Centralized Feature Definition:</strong> Defines the feature transformations and logic in a single place.</li>
<li><strong>Consistent Data Pipelines:</strong> Enforces the same transformations and logic for both training and inference pipelines.</li>
<li><strong>Point-in-Time Correctness:</strong> Allows retrieving feature values as they existed at a specific point in time, crucial for training with historical data. This is often implemented using techniques like temporal joins. Consider a scenario where you are building a credit risk model. You want to know the customer’s account balance <em>at the time</em> they applied for the loan, not their current balance. A feature store provides this capability.</li>
</ul></li>
<li><p><strong>Reduced Latency for Real-Time Inference:</strong> The online store within a feature store is designed for low-latency feature retrieval, enabling real-time inference.</p></li>
<li><p><strong>Improved Model Reproducibility:</strong> By storing feature definitions, transformations, and lineage, feature stores improve model reproducibility. This is critical for auditing, debugging, and ensuring compliance.</p></li>
<li><p><strong>Increased Data Scientist Productivity:</strong> Feature stores automate many of the mundane tasks associated with feature engineering, freeing up data scientists to focus on model building and experimentation.</p></li>
</ol>
<p><strong>Mathematical Considerations &amp; Point-in-Time Correctness</strong></p>
<p>The key to point-in-time correctness lies in performing temporal joins. Suppose we have a table of events <span class="math inline">\(E\)</span> with columns <code>entity_id</code>, <code>event_time</code>, and <code>event_value</code>, and we want to join it with a table of entities <span class="math inline">\(X\)</span> with columns <code>entity_id</code> and <code>request_time</code>. We want to retrieve the <code>event_value</code> from the event table that is closest to the <code>request_time</code> but before it.</p>
<p>The SQL representation of a point-in-time join can be expressed as:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    X.<span class="op">*</span>,</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    E.event_value</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    Entities X</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">LEFT</span> <span class="kw">JOIN</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">Events</span> E <span class="kw">ON</span> X.entity_id <span class="op">=</span> E.entity_id</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">WHERE</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    E.event_time <span class="op">=</span> (</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">SELECT</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>            <span class="fu">MAX</span>(event_time)</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">FROM</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>            <span class="kw">Events</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>        <span class="kw">WHERE</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>            entity_id <span class="op">=</span> X.entity_id</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>            <span class="kw">AND</span> event_time <span class="op">&lt;=</span> X.request_time</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    );</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In mathematical terms, if <span class="math inline">\(f(e,t)\)</span> represents the feature value <span class="math inline">\(e\)</span> at time <span class="math inline">\(t\)</span>, a feature store ensures that during training with historical data <span class="math inline">\(D = \{(x_i, y_i)\}\)</span>, the feature values <span class="math inline">\(f(x_i, t_i)\)</span> used to train the model are the feature values at the time <span class="math inline">\(t_i\)</span> corresponding to the training example <span class="math inline">\(x_i\)</span>. This prevents using “future” information to predict the past.</p>
<p><strong>Real-World Considerations:</strong></p>
<ul>
<li><strong>Choosing the Right Feature Store:</strong> There are open-source, cloud-based, and commercial feature stores, each with its own strengths and weaknesses. The choice depends on the specific requirements of the organization. Examples include Feast (open source), AWS SageMaker Feature Store, Google Vertex AI Feature Store, Tecton, and Hopsworks.</li>
<li><strong>Data Governance and Security:</strong> Implementing proper access control and data governance policies is crucial for protecting sensitive data.</li>
<li><strong>Monitoring and Alerting:</strong> Implement robust monitoring and alerting to detect feature drift, data quality issues, and performance degradation.</li>
<li><strong>Feature Engineering Complexity:</strong> Complex feature engineering pipelines can be challenging to manage and maintain. It’s important to design these pipelines with modularity and reusability in mind.</li>
<li><strong>Scalability:</strong> The feature store needs to be able to scale to handle the demands of large datasets and high-throughput inference.</li>
</ul>
<p>In summary, a feature store is an essential component of modern ML pipelines, enabling feature reuse, ensuring consistency between training and inference, reducing latency, improving model reproducibility, and increasing data scientist productivity. By centralizing feature management, the feature store helps organizations deploy and maintain ML models at scale with greater efficiency and reliability.</p>
<p><strong>How to Narrate</strong></p>
<p>Here’s a step-by-step guide on how to articulate this to an interviewer:</p>
<ol type="1">
<li><p><strong>Start with a high-level definition:</strong> “A feature store is a centralized repository for managing and serving machine learning features. Think of it as the bridge between data engineering and machine learning, ensuring features are consistent, reusable, and readily available.”</p></li>
<li><p><strong>Explain the key components:</strong> “A feature store has several key components. First, it handles feature definition and metadata, keeping track of what each feature represents and how it’s calculated. Second, it provides both offline storage for training data and online storage for low-latency inference. Third, it includes mechanisms for feature serving - providing APIs to access those features. Ideally, it’ll also handle feature engineering and provide monitoring capabilities.”</p></li>
<li><p><strong>Emphasize the importance of feature reuse:</strong> “One of the biggest benefits is feature reuse. Without a feature store, different teams often reinvent the wheel, creating the same features multiple times with potentially different logic. This leads to inconsistencies and wasted effort.”</p></li>
<li><p><strong>Explain training-serving skew:</strong> “A critical challenge is ensuring consistency between training and inference. This is often called ‘training-serving skew’. During training, we use historical data, often processed in batch. But during inference, we need real-time features. If these pipelines aren’t aligned, the model’s performance can degrade significantly.”</p></li>
<li><p><strong>Explain how the feature store solves training-serving skew:</strong> “The feature store addresses this by centralizing feature definitions and ensuring the same transformations are applied in both the training and inference pipelines. Furthermore, features stores enable point-in-time correctness.”</p></li>
<li><p><strong>Explain point-in-time correctness with an example:</strong> “Point-in-time correctness is crucial for training with historical data. Imagine building a model to predict loan defaults. You want to use the customer’s account balance <em>at the time</em> they applied for the loan, not their current balance. The feature store allows you to retrieve feature values as they existed at a specific point in time, preventing you from using future information to predict the past.” Optionally provide the SQL snippet.</p></li>
<li><p><strong>Briefly touch on low latency and model reproducibility:</strong> “The online store enables low-latency feature retrieval for real-time inference, and the centralized metadata improves model reproducibility, making it easier to audit and debug models.”</p></li>
<li><p><strong>Mention real-world considerations:</strong> “Choosing the right feature store depends on the specific needs of the organization. There are open-source options like Feast, cloud-based services from AWS and Google, and commercial solutions. It’s also important to consider data governance, security, monitoring, and the complexity of the feature engineering pipelines.”</p></li>
<li><p><strong>Communication Tips:</strong></p>
<ul>
<li><strong>Pace yourself:</strong> Don’t rush through the explanation. Give the interviewer time to absorb the information.</li>
<li><strong>Use analogies:</strong> The “bridge between data engineering and machine learning” analogy is helpful.</li>
<li><strong>Check for understanding:</strong> Pause periodically and ask if the interviewer has any questions.</li>
<li><strong>Tailor to the audience:</strong> If the interviewer is less technical, focus on the benefits and high-level concepts. If they are more technical, you can delve into the details of the implementation.</li>
<li><strong>Don’t be afraid to say “it depends”:</strong> The best feature store solution depends on the specific needs of the organization.</li>
</ul></li>
</ol>
<p>By following these steps, you can effectively communicate your understanding of feature stores and their importance in modern machine learning pipelines. You demonstrate senior-level knowledge by discussing not only the basics but also advanced concepts like training-serving skew and point-in-time correctness, and you show practical awareness by mentioning real-world considerations.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>