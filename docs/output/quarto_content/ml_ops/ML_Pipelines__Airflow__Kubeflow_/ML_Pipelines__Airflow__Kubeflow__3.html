<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>ml_pipelines__airflow__kubeflow__3</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../../">
<script src="../../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../site_libs/bootstrap/bootstrap-5d3fd86dc4559d58e199c8cc4a79ed5b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<section id="question-4.-in-kubeflow-pipelines-how-do-you-integrate-hyperparameter-tuning-and-model-versioning-within-your-pipeline-what-design-patterns-or-tools-would-you-leverage" class="level2">
<h2 class="anchored" data-anchor-id="question-4.-in-kubeflow-pipelines-how-do-you-integrate-hyperparameter-tuning-and-model-versioning-within-your-pipeline-what-design-patterns-or-tools-would-you-leverage">Question: 4. In Kubeflow Pipelines, how do you integrate hyperparameter tuning and model versioning within your pipeline? What design patterns or tools would you leverage?</h2>
<p><strong>Best Answer</strong></p>
<p>Integrating hyperparameter tuning and model versioning into Kubeflow Pipelines is crucial for building robust and reproducible ML workflows. These capabilities enhance the efficiency of model development, deployment, and monitoring. Here’s how I would approach this integration, focusing on specific tools and design patterns:</p>
<p><strong>1. Hyperparameter Tuning with Katib:</strong></p>
<ul>
<li><p><strong>Integration:</strong> Katib, a Kubeflow sub-project, is designed for automated hyperparameter tuning. I would integrate Katib’s <code>Experiment</code> and <code>Trial</code> custom resources directly into my Kubeflow Pipeline components.</p></li>
<li><p><strong>Workflow:</strong></p>
<ol type="1">
<li>Define a Kubeflow Pipeline component responsible for training a model. This component should accept hyperparameters as input.</li>
<li>Create a Katib <code>Experiment</code> resource that specifies the search space for each hyperparameter, the optimization objective (e.g., maximize validation accuracy), and the search algorithm (e.g., Bayesian Optimization, Random Search, or Grid Search).</li>
<li>The <code>Experiment</code> controller automatically creates <code>Trial</code> resources, each representing a set of hyperparameter values.</li>
<li>Each <code>Trial</code> launches an instance of the training component with the assigned hyperparameters.</li>
<li>The training component reports the evaluation metric back to the <code>Trial</code>.</li>
<li>Katib uses the reported metrics to guide the search for the best hyperparameter configuration.</li>
</ol></li>
<li><p><strong>Mathematical Perspective:</strong> The hyperparameter tuning process can be viewed as an optimization problem:</p>
<p><span class="math display">\[\theta^* = \arg \max_{\theta \in \Theta} f(\theta)\]</span></p>
<p>where:</p>
<ul>
<li><span class="math inline">\(\theta\)</span> represents the hyperparameter vector.</li>
<li><span class="math inline">\(\Theta\)</span> is the hyperparameter search space.</li>
<li><span class="math inline">\(f(\theta)\)</span> is the objective function (e.g., validation accuracy) that we aim to maximize. This function is usually a black box, making derivative-free optimization algorithms like Bayesian Optimization appropriate.</li>
</ul>
<p>Bayesian Optimization uses a surrogate function, often a Gaussian Process (GP), to model <span class="math inline">\(f(\theta)\)</span>. The GP provides a predictive distribution <span class="math inline">\(p(f(\theta) | D)\)</span> where <span class="math inline">\(D\)</span> is the history of hyperparameter configurations and their corresponding objective values. An acquisition function, like Expected Improvement (EI), is then used to select the next hyperparameter configuration to evaluate:</p>
<p><span class="math display">\[\theta_{next} = \arg \max_{\theta} EI(\theta)\]</span></p>
<p>The EI balances exploration (trying new regions of the search space) and exploitation (focusing on regions known to yield good results).</p></li>
<li><p><strong>Katib Manifest Example (Conceptual):</strong> <code>yaml     apiVersion: "kubeflow.org/v1beta1"     kind: Experiment     metadata:       name: my-experiment     spec:       objective:         type: maximize         goal: 0.95         objectiveMetricName: validation_accuracy       algorithm:         algorithmName: bayesianoptimization       parameters:         - name: learning_rate           parameterType: double           feasibleSpace:             min: "0.0001"             max: "0.1"         - name: num_layers           parameterType: int           feasibleSpace:             min: "2"             max: "5"       trialTemplate:         primaryContainerName: training-container         trialParameters:           - name: learning_rate             reference: learning_rate           - name: num_layers             reference: num_layers         containers:           - name: training-container             image: my-training-image             command: ["python", "/app/train.py"]             args:               - "--learning_rate=$(trialParameters.learning_rate)"               - "--num_layers=$(trialParameters.num_layers)"</code></p></li>
</ul>
<p><strong>2. Model Versioning with Artifact Repositories and Metadata Tracking:</strong></p>
<ul>
<li><p><strong>ML Metadata (MLMD):</strong> Kubeflow integrates with MLMD, a library for tracking metadata about ML workflows. This includes tracking models, datasets, hyperparameters, and evaluation metrics.</p></li>
<li><p><strong>Artifact Repositories (e.g., MinIO, GCS, S3):</strong> Store trained models, datasets, and other artifacts in a versioned artifact repository.</p></li>
<li><p><strong>Workflow:</strong></p>
<ol type="1">
<li>After a training component completes, log the following metadata to MLMD:
<ul>
<li>Input dataset(s) used for training.</li>
<li>Hyperparameter values used for training.</li>
<li>Path to the trained model in the artifact repository.</li>
<li>Evaluation metrics (accuracy, F1-score, etc.).</li>
<li>Timestamp of the training run.</li>
<li>Git commit hash of the training code for reproducibility.</li>
</ul></li>
<li>Version the model in the artifact repository using a consistent naming convention that includes a version number or timestamp.</li>
<li>Create a separate pipeline component for model evaluation and deployment. This component retrieves the model from the artifact repository based on its version and the associated metadata.</li>
<li>Use MLMD to track which model versions are deployed in which environments (staging, production).</li>
</ol></li>
<li><p><strong>Mathematical/Statistical Perspective:</strong> Model evaluation metrics are crucial for selecting the best model version. Metrics such as accuracy, precision, recall, and F1-score provide insights into the model’s performance on different subsets of the data. We can also look at metrics like AUC-ROC (Area Under the Receiver Operating Characteristic curve), which is particularly useful for imbalanced datasets. The choice of metrics depends on the specific business problem and the relative costs of different types of errors (false positives vs.&nbsp;false negatives).</p></li>
<li><p><strong>Example Metadata Logging:</strong></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> ml_metadata <span class="im">import</span> metadata_store</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> ml_metadata.proto <span class="im">import</span> metadata_store_pb2</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> ml_metadata.proto <span class="im">import</span> artifact_pb2, value_pb2</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Configure ML Metadata store</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>connection_config <span class="op">=</span> metadata_store_pb2.ConnectionConfig()</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>connection_config.sqlite.filename_uri <span class="op">=</span> <span class="st">'metadata.db'</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>connection_config.sqlite.use_in_memory_store <span class="op">=</span> <span class="va">True</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>store <span class="op">=</span> metadata_store.MetadataStore(connection_config)</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Create an artifact type for the model</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>model_type <span class="op">=</span> artifact_pb2.ArtifactType()</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>model_type.name <span class="op">=</span> <span class="st">"TrainedModel"</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>model_type.properties[<span class="st">"version"</span>] <span class="op">=</span> metadata_store_pb2.STRING</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>model_type.properties[<span class="st">"accuracy"</span>] <span class="op">=</span> metadata_store_pb2.DOUBLE</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>model_type_id <span class="op">=</span> store.put_artifact_type(model_type)</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Create an artifact instance representing the trained model</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>model_artifact <span class="op">=</span> artifact_pb2.Artifact()</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>model_artifact.type_id <span class="op">=</span> model_type_id</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>model_artifact.properties[<span class="st">"version"</span>].string_value <span class="op">=</span> <span class="st">"v1.0"</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>model_artifact.properties[<span class="st">"accuracy"</span>].double_value <span class="op">=</span> <span class="fl">0.92</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>model_artifact.uri <span class="op">=</span> <span class="st">"gs://my-bucket/models/model-v1.0"</span>  <span class="co"># Path to the model in the artifact repository</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>[model_artifact_id] <span class="op">=</span> store.put_artifacts([model_artifact])</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a><span class="co"># Log additional information, such as input dataset(s), hyperparameter values, timestamp, etc.</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
</ul>
<p><strong>3. Design Patterns:</strong></p>
<ul>
<li><p><strong>Modular Pipeline Steps:</strong> Break down the pipeline into smaller, reusable components. This makes the pipeline easier to maintain and extend.</p></li>
<li><p><strong>Parameterization:</strong> Parameterize pipeline components using Kubeflow Pipeline’s input parameters. This allows you to easily change the behavior of the pipeline without modifying the code. For example, you can parameterize the model version, the hyperparameter search space, or the evaluation metric.</p></li>
<li><p><strong>Containerization:</strong> Package each pipeline component as a Docker container to ensure reproducibility. This isolates the component’s dependencies and ensures that it runs consistently across different environments.</p></li>
<li><p><strong>Metadata-Driven Workflow:</strong> Design the pipeline to be driven by metadata. This means that the pipeline components should rely on MLMD to retrieve information about the model, the dataset, and the hyperparameters. This promotes reproducibility and makes it easier to track the lineage of ML artifacts.</p></li>
</ul>
<p><strong>4. Tools:</strong></p>
<ul>
<li><strong>Katib:</strong> For hyperparameter tuning.</li>
<li><strong>ML Metadata (MLMD):</strong> For metadata tracking and lineage.</li>
<li><strong>Kubeflow Pipelines SDK:</strong> For defining and managing pipelines.</li>
<li><strong>Artifact Repositories (MinIO, GCS, S3):</strong> For storing and versioning models and datasets.</li>
<li><strong>TensorBoard:</strong> For visualizing training metrics and hyperparameter tuning results.</li>
</ul>
<p><strong>5. Real-World Considerations:</strong></p>
<ul>
<li><strong>Scalability:</strong> Design the pipeline to be scalable to handle large datasets and complex models. This may involve using distributed training techniques and optimizing the pipeline components for performance.</li>
<li><strong>Security:</strong> Secure the pipeline by implementing appropriate authentication and authorization mechanisms. This is especially important when dealing with sensitive data.</li>
<li><strong>Monitoring:</strong> Monitor the pipeline to ensure that it is running correctly and that the models are performing as expected. This may involve using tools like Prometheus and Grafana.</li>
<li><strong>Reproducibility:</strong> Ensure that the pipeline is fully reproducible by versioning all code, data, and configurations. This will allow you to easily reproduce the results of a past run.</li>
<li><strong>Cost Optimization:</strong> The choice of hyperparameter tuning algorithms can influence the cost. Consider using techniques like early stopping or resource allocation strategies in Katib to optimize the cost of tuning.</li>
</ul>
<p>By combining Katib for hyperparameter tuning, ML Metadata for tracking, and appropriate design patterns, Kubeflow Pipelines provide a powerful platform for building and managing end-to-end ML workflows.</p>
<p><strong>How to Narrate</strong></p>
<p>Here’s a step-by-step guide on how to articulate this in an interview:</p>
<ol type="1">
<li><p><strong>Start with a High-Level Overview (30 seconds):</strong></p>
<ul>
<li>“Integrating hyperparameter tuning and model versioning is crucial for robust ML pipelines. In Kubeflow, I’d use Katib for tuning and ML Metadata for versioning, along with key design patterns to ensure reproducibility.”</li>
</ul></li>
<li><p><strong>Dive into Hyperparameter Tuning (2-3 minutes):</strong></p>
<ul>
<li>“For hyperparameter tuning, I would leverage Katib. I’d define an <code>Experiment</code> custom resource, specifying the search space, objective function, and search algorithm. The <code>Experiment</code> automatically creates <code>Trial</code> resources.”</li>
<li>“Each <code>Trial</code> launches a training component with specific hyperparameters. The component then reports the evaluation metric back to the <code>Trial</code>, which Katib uses to guide the search.”</li>
<li><em>(Optional, if asked for more detail):</em> “Mathematically, this is an optimization problem where we’re trying to maximize an objective function <span class="math inline">\(f(\theta)\)</span> over the hyperparameter space <span class="math inline">\(\Theta\)</span>. Katib often uses Bayesian Optimization, which employs a Gaussian Process to model the objective function.”</li>
<li><em>(If asked for concrete examples):</em> “For example, I might define a search space for learning rate between 0.0001 and 0.1, and the number of layers between 2 and 5. Katib would then explore this space to find the best configuration.”</li>
</ul></li>
<li><p><strong>Explain Model Versioning (2-3 minutes):</strong></p>
<ul>
<li>“For model versioning, I’d integrate ML Metadata, or MLMD, to track key information like datasets, hyperparameters, model paths, and evaluation metrics.”</li>
<li>“Trained models would be stored in a versioned artifact repository, such as MinIO or GCS, using a consistent naming convention.”</li>
<li>“After training, I’d log metadata to MLMD, including the model’s location in the artifact repository, evaluation metrics like accuracy or F1-score, and the Git commit hash for reproducibility.”</li>
<li><em>(If asked for more detail):</em> “The evaluation metrics are essential for selecting the best model version, and the choice of metrics depends on the problem at hand. For example, we might use AUC-ROC for imbalanced datasets.”</li>
<li><em>(If asked for concrete examples):</em> “The path to the model, the version number (v1.0, v1.1, etc.), and the associated accuracy score would all be tracked in MLMD.”</li>
</ul></li>
<li><p><strong>Discuss Design Patterns (1-2 minutes):</strong></p>
<ul>
<li>“Key design patterns include modular pipeline steps for maintainability, parameterization for flexibility, and containerization for reproducibility.”</li>
<li>“I’d also emphasize a metadata-driven workflow, where components rely on MLMD for information, improving traceability and reproducibility.”</li>
</ul></li>
<li><p><strong>Mention Tools (15 seconds):</strong></p>
<ul>
<li>“The primary tools are Katib, ML Metadata, the Kubeflow Pipelines SDK, artifact repositories like MinIO, and visualization tools like TensorBoard.”</li>
</ul></li>
<li><p><strong>Address Real-World Considerations (30 seconds):</strong></p>
<ul>
<li>“Important considerations include scalability for large datasets, security for sensitive data, monitoring for performance, and cost optimization for resource usage.”</li>
<li>“Reproducibility is paramount, so I’d ensure all code, data, and configurations are versioned.”</li>
</ul></li>
</ol>
<p><strong>Communication Tips:</strong></p>
<ul>
<li><strong>Pace yourself:</strong> Don’t rush through the explanation. Give the interviewer time to absorb the information.</li>
<li><strong>Use clear and concise language:</strong> Avoid jargon and technical terms unless you’re confident the interviewer understands them.</li>
<li><strong>Provide examples:</strong> Concrete examples can help to illustrate complex concepts.</li>
<li><strong>Check for understanding:</strong> Ask the interviewer if they have any questions or if they’d like you to elaborate on a particular point.</li>
<li><strong>Be prepared to go deeper:</strong> The interviewer may ask follow-up questions about specific aspects of the integration.</li>
<li><strong>Stay confident:</strong> Even if you don’t know the answer to every question, demonstrate that you have a solid understanding of the core concepts and that you’re willing to learn.</li>
<li><strong>Relate it back to experience:</strong> If you have experience with these tools, briefly mention a relevant project or situation where you applied them.</li>
<li><strong>When discussing the mathematics, gauge the interviewer’s background:</strong> If they have a strong mathematical background, you can go into more detail. If not, focus on the intuition and the practical implications. Avoid overwhelming them with equations. For instance, say, “The underlying math involves concepts from Bayesian Optimization, where we model the objective function using a Gaussian Process to efficiently explore the hyperparameter space.”</li>
</ul>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>