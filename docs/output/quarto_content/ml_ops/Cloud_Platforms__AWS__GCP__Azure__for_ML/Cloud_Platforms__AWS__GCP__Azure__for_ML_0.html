<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>cloud_platforms__aws__gcp__azure__for_ml_0</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../../">
<script src="../../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../site_libs/bootstrap/bootstrap-5d3fd86dc4559d58e199c8cc4a79ed5b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="fullcontent">

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<section id="question-compare-and-contrast-the-ml-offerings-available-on-aws-gcp-and-azure-e.g.-aws-sagemaker-gcp-ai-platform-and-azure-machine-learning.-what-are-the-key-strengths-and-weaknesses-of-each-platform-in-terms-of-model-training-deployment-and-scalability" class="level2">
<h2 class="anchored" data-anchor-id="question-compare-and-contrast-the-ml-offerings-available-on-aws-gcp-and-azure-e.g.-aws-sagemaker-gcp-ai-platform-and-azure-machine-learning.-what-are-the-key-strengths-and-weaknesses-of-each-platform-in-terms-of-model-training-deployment-and-scalability">Question: Compare and contrast the ML offerings available on AWS, GCP, and Azure (e.g., AWS SageMaker, GCP AI Platform, and Azure Machine Learning). What are the key strengths and weaknesses of each platform in terms of model training, deployment, and scalability?</h2>
<p><strong>Best Answer</strong></p>
<p>Let’s break down the Machine Learning (ML) offerings of the three major cloud providers – AWS, GCP, and Azure – focusing on their strengths and weaknesses regarding model training, deployment, and scalability.</p>
<p><strong>1. AWS SageMaker:</strong></p>
<ul>
<li><p><strong>Overview:</strong> AWS SageMaker is a comprehensive, fully managed machine learning service. It covers the entire ML workflow, from data preparation and labeling to model building, training, tuning, deployment, and monitoring.</p></li>
<li><p><strong>Strengths:</strong></p>
<ul>
<li><strong>Mature Ecosystem:</strong> SageMaker is part of the broader AWS ecosystem, meaning seamless integration with services like S3, EC2, EMR, Lambda, and IAM. This allows for building complete data pipelines and applications around ML models.</li>
<li><strong>Feature-Rich:</strong> Offers a wide array of built-in algorithms (linear regression, XGBoost, etc.), pre-trained models, and frameworks (TensorFlow, PyTorch, MXNet, scikit-learn). Provides features like auto-scaling, model monitoring, and experiment tracking. SageMaker Studio provides a unified IDE.</li>
<li><strong>Ground Truth:</strong> Excellent service for data labeling, which is a crucial step in the ML pipeline.</li>
<li><strong>Scalability:</strong> Horizontally scalable training and inference infrastructure. SageMaker supports distributed training using techniques like data parallelism and model parallelism. It also supports various instance types (CPU, GPU, Inferentia) for optimal performance and cost.</li>
<li><strong>Inference Options:</strong> Supports real-time inference, batch transform, and serverless inference. SageMaker Inference Recommender is a useful feature for optimizing inference costs.</li>
<li><strong>Autopilot:</strong> Automates model building process, including feature selection, algorithm selection, and hyperparameter tuning.</li>
</ul></li>
<li><p><strong>Weaknesses:</strong></p>
<ul>
<li><strong>Complexity:</strong> Due to the breadth of features, SageMaker can be overwhelming for beginners. The sheer number of options and configurations can lead to a steeper learning curve.</li>
<li><strong>Cost:</strong> Can become expensive if not managed carefully. The pay-as-you-go model requires continuous monitoring and optimization of resource usage.</li>
<li><strong>Vendor Lock-In:</strong> While supporting open-source frameworks, the deep integration with AWS services makes it harder to migrate to other cloud providers.</li>
<li><strong>Debugging:</strong> Debugging distributed training jobs can be challenging.</li>
</ul></li>
</ul>
<p><strong>2. GCP AI Platform (now Vertex AI):</strong></p>
<ul>
<li><p><strong>Overview:</strong> GCP’s AI Platform (now consolidated under Vertex AI) aims to provide a unified platform for all stages of the ML lifecycle. It integrates well with other GCP services and offers a strong emphasis on Kubeflow for workflow orchestration.</p></li>
<li><p><strong>Strengths:</strong></p>
<ul>
<li><strong>Kubeflow Integration:</strong> Vertex AI is deeply integrated with Kubeflow, a Kubernetes-based platform for building and deploying portable, scalable ML workflows. This allows for reproducible and easily managed ML pipelines.</li>
<li><strong>Big Data Focus:</strong> Excellent integration with GCP’s Big Data services like BigQuery, Dataflow, and Dataproc. This makes it a strong choice for organizations that already have a data infrastructure on GCP.</li>
<li><strong>TPUs (Tensor Processing Units):</strong> GCP offers TPUs, which are custom-designed ASICs optimized for deep learning workloads, providing significantly faster training times compared to GPUs for certain models.</li>
<li><strong>Vertex AI Workbench:</strong> A managed notebook environment, based on JupyterLab, that integrates with Vertex AI services.</li>
<li><strong>Explainable AI:</strong> Provides tools and techniques for understanding and explaining model predictions, enhancing trust and transparency.</li>
<li><strong>Global Infrastructure:</strong> GCP’s global network ensures low-latency access to your models from anywhere in the world.</li>
</ul></li>
<li><p><strong>Weaknesses:</strong></p>
<ul>
<li><strong>Complexity (Kubeflow):</strong> While Kubeflow offers powerful workflow management, it adds complexity to the ML development process, requiring expertise in Kubernetes.</li>
<li><strong>Ecosystem Maturity:</strong> While rapidly improving, the overall ecosystem of pre-built algorithms and services may not be as extensive as AWS SageMaker.</li>
<li><strong>Cost:</strong> Similar to AWS, managing costs requires careful monitoring and optimization. TPUs, while powerful, can be expensive.</li>
<li><strong>Vendor Lock-In:</strong> Integration with GCP services can lead to vendor lock-in.</li>
</ul></li>
</ul>
<p><strong>3. Azure Machine Learning:</strong></p>
<ul>
<li><p><strong>Overview:</strong> Azure Machine Learning provides a cloud-based environment for developing, training, deploying, managing, and tracking ML models. It supports a wide range of frameworks and languages, including Python, R, and .NET.</p></li>
<li><p><strong>Strengths:</strong></p>
<ul>
<li><strong>Hybrid Cloud Focus:</strong> Azure is well-suited for organizations with hybrid cloud strategies, allowing them to train and deploy models both on-premises and in the cloud.</li>
<li><strong>Integration with Microsoft Ecosystem:</strong> Seamless integration with other Microsoft services like Azure Data Lake Storage, Azure Synapse Analytics, and Power BI. This makes it attractive for organizations that heavily use Microsoft products.</li>
<li><strong>Automated ML (AutoML):</strong> Provides AutoML capabilities to automatically train and tune models, making it easier for users with limited ML expertise.</li>
<li><strong>Designer:</strong> A drag-and-drop interface for building ML pipelines, simplifying the development process for visual learners.</li>
<li><strong>Responsible AI Tools:</strong> Includes tools for fairness assessment, explainability, and privacy, helping organizations build responsible AI systems.</li>
<li><strong>MLOps Capabilities:</strong> Strong focus on MLOps, providing tools for model versioning, deployment, monitoring, and governance.</li>
<li><strong>Azure Arc:</strong> Enables running Azure Machine Learning on any infrastructure, including on-premises, multi-cloud, and edge environments.</li>
</ul></li>
<li><p><strong>Weaknesses:</strong></p>
<ul>
<li><strong>Complexity:</strong> Azure Machine Learning can be complex, particularly for users new to the Azure ecosystem.</li>
<li><strong>Ecosystem Maturity:</strong> While rapidly evolving, the ecosystem of pre-built models and services may not be as extensive as AWS SageMaker or GCP Vertex AI in certain areas.</li>
<li><strong>Cost:</strong> Can be expensive if not managed carefully, especially when using specialized compute instances.</li>
<li><strong>Vendor Lock-In:</strong> Integration with Azure services can lead to vendor lock-in.</li>
</ul></li>
</ul>
<p><strong>Comparison Table:</strong></p>
<table class="caption-top table">
<colgroup>
<col style="width: 11%">
<col style="width: 27%">
<col style="width: 30%">
<col style="width: 30%">
</colgroup>
<thead>
<tr class="header">
<th>Feature</th>
<th>AWS SageMaker</th>
<th>GCP Vertex AI</th>
<th>Azure Machine Learning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Ecosystem</td>
<td>Mature, comprehensive</td>
<td>Strong Kubeflow integration, Big Data focus</td>
<td>Strong Microsoft integration, Hybrid Cloud</td>
</tr>
<tr class="even">
<td>Training</td>
<td>Scalable, wide range of algorithms</td>
<td>TPUs for accelerated training</td>
<td>AutoML, scalable compute</td>
</tr>
<tr class="odd">
<td>Deployment</td>
<td>Real-time, batch, serverless inference</td>
<td>Kubeflow-based, scalable</td>
<td>Real-time, batch, edge deployment</td>
</tr>
<tr class="even">
<td>Scalability</td>
<td>Excellent</td>
<td>Excellent</td>
<td>Excellent</td>
</tr>
<tr class="odd">
<td>Ease of Use</td>
<td>Can be complex</td>
<td>Kubeflow adds complexity</td>
<td>Can be complex</td>
</tr>
<tr class="even">
<td>Cost</td>
<td>Requires careful management</td>
<td>Requires careful management</td>
<td>Requires careful management</td>
</tr>
<tr class="odd">
<td>Vendor Lock-In</td>
<td>High</td>
<td>High</td>
<td>High</td>
</tr>
<tr class="even">
<td>Key Strength</td>
<td>Comprehensive feature set</td>
<td>Big Data and Kubeflow integration</td>
<td>Hybrid cloud and MLOps</td>
</tr>
<tr class="odd">
<td>Key Weakness</td>
<td>Complexity</td>
<td>Kubeflow complexity</td>
<td>Complexity</td>
</tr>
</tbody>
</table>
<p><strong>Scalability Considerations:</strong></p>
<p>All three platforms offer excellent scalability for both training and inference. They support:</p>
<ul>
<li><strong>Distributed Training:</strong> Techniques like data parallelism and model parallelism to train models on large datasets.</li>
<li><strong>Auto-Scaling:</strong> Automatically scaling compute resources based on demand to handle fluctuating workloads.</li>
<li><strong>GPU and TPU Support:</strong> Using specialized hardware to accelerate training and inference.</li>
<li><strong>Containerization:</strong> Deploying models in containers (e.g., using Docker) for portability and scalability.</li>
</ul>
<p><strong>Vendor Lock-In:</strong></p>
<p>Vendor lock-in is a significant consideration for all three platforms. Deep integration with cloud-specific services can make it difficult and costly to migrate to another provider. Strategies to mitigate vendor lock-in include:</p>
<ul>
<li><strong>Using Open-Source Frameworks:</strong> Relying on open-source ML frameworks (e.g., TensorFlow, PyTorch) and data formats.</li>
<li><strong>Containerization:</strong> Packaging models and dependencies in containers for portability.</li>
<li><strong>Abstraction Layers:</strong> Building abstraction layers that decouple your ML code from cloud-specific APIs.</li>
<li><strong>Multi-Cloud Strategy:</strong> Distributing workloads across multiple cloud providers to reduce reliance on any single vendor.</li>
</ul>
<p><strong>Conclusion:</strong></p>
<p>The best choice of platform depends on the specific needs and priorities of the organization. If you are heavily invested in the AWS ecosystem and need a comprehensive, feature-rich platform, SageMaker is a strong option. If you prioritize Big Data integration and workflow management with Kubeflow, GCP Vertex AI is a good choice. If you have a hybrid cloud strategy and a strong reliance on Microsoft technologies, Azure Machine Learning is a compelling option. In practice, many large organizations are adopting a multi-cloud strategy to leverage the strengths of each platform and avoid vendor lock-in.</p>
<p><strong>How to Narrate</strong></p>
<p>Here’s a suggested approach for presenting this information in an interview:</p>
<ol type="1">
<li><strong>Start with an Overview:</strong>
<ul>
<li>“I’ve worked extensively with all three major cloud providers for machine learning. Each platform has its strengths and weaknesses, and the best choice depends on the specific use case and organizational context.”</li>
<li>“I’ll focus on AWS SageMaker, GCP Vertex AI (formerly AI Platform), and Azure Machine Learning, covering their key features, strengths, weaknesses in model training, deployment, and scalability.”</li>
</ul></li>
<li><strong>Address AWS SageMaker:</strong>
<ul>
<li>“AWS SageMaker is a mature and comprehensive platform. Its biggest strength is its rich feature set and seamless integration with the broader AWS ecosystem.”</li>
<li>“For example, SageMaker Ground Truth is excellent for data labeling, and its integration with S3 and Lambda allows for building end-to-end ML pipelines.”</li>
<li>“However, the sheer number of features can make it complex, and cost management is crucial. Also, its deep integration with AWS can lead to vendor lock-in.”</li>
</ul></li>
<li><strong>Transition to GCP Vertex AI:</strong>
<ul>
<li>“GCP’s Vertex AI stands out for its strong integration with Kubeflow and its focus on Big Data. This makes it ideal for organizations already using GCP’s data services like BigQuery and Dataflow.”</li>
<li>“The availability of TPUs for accelerated training is another key advantage.”</li>
<li>“However, Kubeflow adds complexity, and while the ecosystem is growing, it may not be as extensive as SageMaker.”</li>
</ul></li>
<li><strong>Discuss Azure Machine Learning:</strong>
<ul>
<li>“Azure Machine Learning excels in hybrid cloud scenarios and integrates well with the Microsoft ecosystem. Its AutoML capabilities and designer interface make it more accessible to users with less ML expertise.”</li>
<li>“Azure also has a strong focus on MLOps, providing tools for model governance and responsible AI.”</li>
<li>“Like the other platforms, it can be complex and expensive if not managed carefully, and integration with Azure services can lead to vendor lock-in.”</li>
</ul></li>
<li><strong>Highlight Key Differences (use the table as a guide):</strong>
<ul>
<li>“To summarize, SageMaker offers the most comprehensive feature set, Vertex AI is strong in Big Data and Kubeflow, and Azure Machine Learning focuses on hybrid cloud and MLOps.”</li>
</ul></li>
<li><strong>Address Scalability:</strong>
<ul>
<li>“All three platforms provide excellent scalability for both training and inference. They support distributed training, auto-scaling, and the use of GPUs and TPUs.”</li>
<li>“They also leverage containerization for portable and scalable deployments.”</li>
</ul></li>
<li><strong>Discuss Vendor Lock-In Mitigation:</strong>
<ul>
<li>“Vendor lock-in is a crucial consideration. I recommend strategies like using open-source frameworks, containerization, and building abstraction layers to mitigate this risk.”</li>
<li>“A multi-cloud strategy can also help distribute risk and leverage the strengths of each platform.”</li>
</ul></li>
<li><strong>Conclude with a Summary:</strong>
<ul>
<li>“In conclusion, the best choice depends on the specific requirements. A comprehensive assessment of your organization’s needs, existing infrastructure, and budget is essential before making a decision.”</li>
<li>“Many organizations are now adopting a multi-cloud strategy to avoid lock-in and leverage the unique capabilities of each platform.”</li>
</ul></li>
</ol>
<p><strong>Communication Tips:</strong></p>
<ul>
<li><strong>Pace Yourself:</strong> Don’t rush through the explanation. Give the interviewer time to process the information.</li>
<li><strong>Use Concrete Examples:</strong> Illustrate your points with real-world examples of how you’ve used each platform.</li>
<li><strong>Avoid Jargon:</strong> Use technical terms judiciously and explain them if necessary.</li>
<li><strong>Engage the Interviewer:</strong> Ask if they have any questions along the way and encourage a dialogue.</li>
<li><strong>Highlight Trade-offs:</strong> Emphasize the trade-offs between different features and platforms to demonstrate your understanding of the nuances.</li>
<li><strong>Focus on Business Value:</strong> Connect the technical details to the business value that each platform can deliver.</li>
<li><strong>Be Prepared to Dive Deeper:</strong> The interviewer may ask follow-up questions about specific aspects of each platform. Be ready to provide more detailed explanations and examples.</li>
</ul>
<p><strong>Handling the Comparison Table Mentally:</strong></p>
<ul>
<li>You don’t need to explicitly read out a table. Use it as a mental checklist to ensure you cover the key areas consistently for each platform.</li>
<li>Refer to the table’s contents in your narrative, e.g., “In terms of scalability, all three platforms offer excellent capabilities…”</li>
</ul>
<p>By following this approach, you can effectively demonstrate your deep knowledge of cloud ML platforms and your ability to communicate complex technical concepts clearly and concisely.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>