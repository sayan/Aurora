<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>cloud_platforms__aws__gcp__azure__for_ml_1</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../../">
<script src="../../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../site_libs/bootstrap/bootstrap-5d3fd86dc4559d58e199c8cc4a79ed5b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<section id="question-how-would-you-manage-and-preprocess-messy-unstructured-data-to-prepare-it-for-an-ml-pipeline-on-a-cloud-platform" class="level2">
<h2 class="anchored" data-anchor-id="question-how-would-you-manage-and-preprocess-messy-unstructured-data-to-prepare-it-for-an-ml-pipeline-on-a-cloud-platform">Question: How would you manage and preprocess messy, unstructured data to prepare it for an ML pipeline on a cloud platform?</h2>
<p><strong>Best Answer</strong></p>
<p>Managing and preprocessing messy, unstructured data for an ML pipeline on a cloud platform is a multi-stage process, requiring a robust architecture and careful consideration of scalability, cost, and reliability. I’ll outline a solution leveraging cloud-native tools, focusing on both the general process and specific examples using AWS. Similar approaches can be adapted for GCP or Azure.</p>
<p><strong>1. Data Ingestion:</strong></p>
<ul>
<li><strong>Objective:</strong> Bring the raw, unstructured data into the cloud environment.</li>
<li><strong>Techniques:</strong>
<ul>
<li><strong>Object Storage:</strong> The first step is typically to ingest the data into a cloud object storage service like AWS S3, Azure Blob Storage, or Google Cloud Storage. This provides a durable and scalable repository for the raw data.</li>
<li><strong>Data Sources:</strong> Unstructured data can come from various sources:
<ul>
<li><strong>Logs:</strong> Web server logs, application logs.</li>
<li><strong>Text:</strong> Documents, emails, social media feeds.</li>
<li><strong>Images:</strong> Photographs, scans, medical imaging.</li>
<li><strong>Audio/Video:</strong> Recordings, streams.</li>
</ul></li>
<li><strong>Ingestion Methods:</strong>
<ul>
<li><strong>Batch Uploads:</strong> For large files, tools like the AWS CLI, Azure CLI, or <code>gsutil</code> can be used.</li>
<li><strong>Streaming Ingestion:</strong> For continuous data streams, services like AWS Kinesis, Azure Event Hubs, or Google Cloud Pub/Sub are appropriate. These services allow for real-time data ingestion and buffering.</li>
</ul></li>
<li><strong>Metadata:</strong> Capture essential metadata upon ingestion, like source, timestamp, and data type.</li>
</ul></li>
</ul>
<p><strong>2. Data Discovery and Profiling:</strong></p>
<ul>
<li><strong>Objective:</strong> Understand the characteristics of the unstructured data.</li>
<li><strong>Techniques:</strong>
<ul>
<li><strong>Data Sampling:</strong> Extract a representative sample of the data for analysis. The size of the sample depends on the overall data volume and variability.</li>
<li><strong>Schema Inference (if applicable):</strong> Even for unstructured data, attempt to infer any underlying structure. For instance, JSON or XML files have a schema, even if not strictly enforced.</li>
<li><strong>Data Profiling Tools:</strong> Utilize services or libraries to automatically analyze data characteristics:
<ul>
<li><strong>AWS Glue DataBrew:</strong> A visual data preparation tool allowing interactive data profiling.</li>
<li><strong>Pandas Profiling (with Spark):</strong> Create detailed reports on data distributions, missing values, and correlations.</li>
<li><strong>Custom Scripts:</strong> Write Python scripts (using libraries like <code>pandas</code>, <code>nltk</code>, <code>opencv</code>, etc.) to analyze data-specific characteristics (e.g., average text length, image color histograms).</li>
</ul></li>
<li><strong>Manual Inspection:</strong> Crucially, manually examine the data. This is essential for identifying patterns and anomalies that automated tools might miss.</li>
</ul></li>
</ul>
<p><strong>3. Data Cleaning and Transformation:</strong></p>
<ul>
<li><p><strong>Objective:</strong> Correct errors, handle missing values, and transform the data into a usable format.</p></li>
<li><p><strong>Techniques:</strong></p>
<ul>
<li><strong>Data Deduplication:</strong> Identify and remove duplicate records. This might involve fuzzy matching techniques for near-duplicates.</li>
<li><strong>Missing Value Handling:</strong> Strategies include:
<ul>
<li><strong>Imputation:</strong> Replace missing values with estimates (e.g., mean, median, mode).</li>
<li><strong>Deletion:</strong> Remove rows or columns with missing values (use carefully to avoid bias).</li>
<li><strong>Prediction:</strong> Train a model to predict missing values based on other features.</li>
</ul></li>
<li><strong>Error Correction:</strong> Fix inconsistencies and errors in the data. For text data, this might involve spell-checking, stemming, or lemmatization. For numerical data, it may involve outlier detection and removal or correction.</li>
<li><strong>Data Type Conversion:</strong> Ensure that data is in the correct format (e.g., converting strings to dates, numbers to categories).</li>
<li><strong>Data Standardization:</strong> Scale numerical features to a common range (e.g., using min-max scaling or z-score standardization) and handle different date and time formats. Z-score standardization involves calculating the mean <span class="math inline">\(\mu\)</span> and standard deviation <span class="math inline">\(\sigma\)</span> of a feature and then transforming each value <span class="math inline">\(x\)</span> as follows:</li>
</ul>
<p><span class="math display">\[z = \frac{x - \mu}{\sigma}\]</span></p>
<ul>
<li><strong>Text Processing:</strong>
<ul>
<li><strong>Tokenization:</strong> Split text into individual words or tokens.</li>
<li><strong>Stop Word Removal:</strong> Remove common words (e.g., “the”, “a”, “is”) that don’t contribute much meaning.</li>
<li><strong>Stemming/Lemmatization:</strong> Reduce words to their root form (e.g., “running” -&gt; “run”).</li>
</ul></li>
<li><strong>Image Processing:</strong>
<ul>
<li><strong>Resizing:</strong> Adjust image dimensions.</li>
<li><strong>Normalization:</strong> Scale pixel values to a common range (e.g., 0-1).</li>
<li><strong>Feature Extraction:</strong> Extract relevant features from images (e.g., edges, textures).</li>
</ul></li>
<li><strong>Data Transformation Pipelines:</strong> Use cloud-native data processing services to implement these cleaning and transformation steps in a scalable and reliable way:
<ul>
<li><strong>AWS Glue:</strong> A fully managed ETL (Extract, Transform, Load) service. Glue provides a data catalog to manage metadata, as well as a Spark-based ETL engine for data transformation. You can define ETL jobs using Python or Scala.</li>
<li><strong>Azure Data Factory:</strong> A similar ETL service for Azure, allowing you to create data pipelines with various data transformation activities.</li>
<li><strong>Google Cloud Dataflow:</strong> A fully managed stream and batch data processing service based on Apache Beam.</li>
<li><strong>AWS Lambda (for simple transformations):</strong> For smaller datasets or real-time transformations, you can use serverless functions to apply transformations on the fly.</li>
</ul></li>
</ul></li>
</ul>
<p><strong>4. Data Enrichment:</strong></p>
<ul>
<li><strong>Objective:</strong> Augment the data with additional information to improve the accuracy of the ML models.</li>
<li><strong>Techniques:</strong>
<ul>
<li><strong>External Data Sources:</strong> Integrate data from external APIs, databases, or publicly available datasets. For example, enriching customer data with demographic information.</li>
<li><strong>Geocoding:</strong> Convert addresses to geographic coordinates.</li>
<li><strong>Sentiment Analysis:</strong> Analyze the sentiment of text data (e.g., customer reviews).</li>
<li><strong>Feature Engineering:</strong> Create new features from existing data. For example, calculate the interaction between two features, create polynomial features, or use domain knowledge to derive meaningful indicators.</li>
</ul></li>
</ul>
<p><strong>5. Data Storage:</strong></p>
<ul>
<li><strong>Objective:</strong> Store the cleaned, transformed, and enriched data in a suitable format for ML training.</li>
<li><strong>Techniques:</strong>
<ul>
<li><strong>Feature Store:</strong> A specialized repository for storing and managing features for ML models. Feature stores provide a central location for feature definitions, feature values, and metadata. Examples include AWS SageMaker Feature Store, Azure Machine Learning Feature Store, and Feast (an open-source feature store).</li>
<li><strong>Data Warehouse:</strong> A relational database optimized for analytical queries. Data warehouses are suitable for structured data and complex analytical workloads. Examples include AWS Redshift, Azure Synapse Analytics, and Google BigQuery.</li>
<li><strong>Data Lake:</strong> A centralized repository for storing data in its native format. Data lakes are suitable for unstructured and semi-structured data and can be used to support a variety of analytical workloads.</li>
<li><strong>Parquet/ORC:</strong> Store the processed data in columnar formats like Parquet or ORC to optimize for read operations. Columnar formats significantly improve query performance for analytical workloads.</li>
</ul></li>
</ul>
<p><strong>6. Data Governance and Security:</strong></p>
<ul>
<li><strong>Objective:</strong> Ensure that the data is managed securely and in compliance with relevant regulations.</li>
<li><strong>Techniques:</strong>
<ul>
<li><strong>Access Control:</strong> Implement strict access controls to restrict access to sensitive data.</li>
<li><strong>Data Encryption:</strong> Encrypt data at rest and in transit.</li>
<li><strong>Data Masking:</strong> Mask sensitive data to protect privacy.</li>
<li><strong>Data Lineage:</strong> Track the origin and transformation of data.</li>
<li><strong>Compliance:</strong> Ensure compliance with relevant regulations (e.g., GDPR, HIPAA).</li>
</ul></li>
</ul>
<p><strong>Example Scenario (AWS):</strong></p>
<p>Let’s say we have a stream of unstructured text data from customer reviews ingested into S3. The following AWS services could be used:</p>
<ol type="1">
<li><strong>S3:</strong> Store the raw review data.</li>
<li><strong>AWS Kinesis Data Firehose:</strong> Optionally, deliver the streaming data to S3.</li>
<li><strong>AWS Glue:</strong> Create a Glue crawler to infer the schema (assuming the reviews are stored as JSON). Create a Glue ETL job using PySpark to:
<ul>
<li>Clean the text data (remove special characters, convert to lowercase).</li>
<li>Perform sentiment analysis using a pre-trained model (e.g., using the <code>nltk</code> library).</li>
<li>Extract key phrases using techniques like TF-IDF.</li>
</ul></li>
<li><strong>AWS Lambda:</strong> Optionally, use Lambda for smaller pre-processing jobs invoked by S3 events (e.g., to validate new data files).</li>
<li><strong>AWS Athena:</strong> Query the cleaned data directly in S3 using SQL for exploratory analysis.</li>
<li><strong>AWS SageMaker Feature Store:</strong> Store the engineered features (sentiment score, key phrases) for use in ML model training.</li>
</ol>
<p><strong>Scalability and Reliability:</strong></p>
<ul>
<li><strong>Auto-Scaling:</strong> Use auto-scaling features of cloud services to automatically scale resources up or down based on demand.</li>
<li><strong>Fault Tolerance:</strong> Design the pipeline to be fault-tolerant by using distributed processing frameworks (e.g., Spark) and by replicating data across multiple availability zones.</li>
<li><strong>Monitoring:</strong> Monitor the performance of the pipeline using cloud monitoring services (e.g., AWS CloudWatch, Azure Monitor, Google Cloud Monitoring) and set up alerts for potential issues.</li>
</ul>
<p><strong>Real-World Considerations:</strong></p>
<ul>
<li><strong>Cost Optimization:</strong> Optimize the pipeline for cost by using spot instances, reserved instances, and by choosing the right instance types.</li>
<li><strong>Data Volume and Velocity:</strong> The choice of services and techniques will depend on the volume and velocity of the data.</li>
<li><strong>Data Security and Privacy:</strong> Implement appropriate security measures to protect sensitive data.</li>
<li><strong>Data Governance:</strong> Establish clear data governance policies and procedures.</li>
<li><strong>Iterative Development:</strong> Data preprocessing is often an iterative process. It may require revisiting and refining steps as you learn more about the data.</li>
</ul>
<p><strong>Best Practices:</strong></p>
<ul>
<li><strong>Data Validation:</strong> Implement data validation checks at each stage of the pipeline to ensure data quality.</li>
<li><strong>Version Control:</strong> Use version control to track changes to the data preprocessing code.</li>
<li><strong>Documentation:</strong> Document the data preprocessing pipeline thoroughly.</li>
<li><strong>Testing:</strong> Test the data preprocessing pipeline thoroughly.</li>
</ul>
<p><strong>In summary, a well-designed data preprocessing pipeline on a cloud platform is essential for building accurate and reliable ML models. It requires careful planning, the use of appropriate cloud services, and adherence to best practices.</strong></p>
<p><strong>How to Narrate</strong></p>
<p>Here’s how to present this information effectively in an interview:</p>
<ol type="1">
<li><p><strong>Start with a High-Level Overview (30 seconds):</strong></p>
<ul>
<li>“Data preprocessing for unstructured data on the cloud is a multi-stage process involving ingestion, discovery, cleaning, transformation, enrichment, and secure storage. The goal is to prepare the data for ML pipelines in a scalable and cost-effective manner. I’ll use AWS as my primary example, but the principles apply to other cloud platforms as well.”</li>
<li><em>Communication Tip: Sets the stage. Avoid diving into specifics immediately.</em></li>
</ul></li>
<li><p><strong>Describe the Key Stages (2-3 minutes):</strong></p>
<ul>
<li>“First, we ingest the data into cloud object storage like S3 using batch uploads or streaming services like Kinesis. We capture metadata during ingestion. Then we perform data discovery and profiling, using tools like AWS Glue DataBrew or Pandas Profiling to understand the data’s characteristics and identify anomalies. Manual inspection is also critical.”</li>
<li>“The next crucial stage is data cleaning and transformation. This involves deduplication, missing value handling (using imputation or deletion), error correction, data type conversion, and standardization. For text, we might use tokenization, stop word removal, and stemming. For images, resizing and normalization are common. We implement these steps using ETL services like AWS Glue, Azure Data Factory, or Google Cloud Dataflow.”</li>
<li>“Data Enrichment follows, where we augment the data with external sources or perform feature engineering. Finally, we store the data in a feature store or data warehouse in optimized columnar format.”</li>
<li>“Throughout the process, data governance and security are paramount, including access control, encryption, and compliance with regulations.”</li>
<li><em>Communication Tip: Use clear transitions (“First,” “Then,” “Next”). Focus on </em>what* each stage does and <em>why</em> it’s important.*</li>
</ul></li>
<li><p><strong>Provide an AWS Example (1-2 minutes):</strong></p>
<ul>
<li>“For example, if we have a stream of customer reviews in S3, we could use Glue to crawl the data and infer the schema. Then, a PySpark ETL job in Glue could clean the text, perform sentiment analysis, and extract key phrases. AWS Lambda could be used for smaller, real-time pre-processing tasks invoked by S3 events. The cleaned data can then be stored in Athena for ad-hoc queries or in SageMaker Feature Store for model training.”</li>
<li><em>Communication Tip: This gives the interviewer a concrete scenario to relate to.</em></li>
</ul></li>
<li><p><strong>Address Scalability, Reliability, and Cost (1 minute):</strong></p>
<ul>
<li>“Scalability is achieved through auto-scaling, distributed processing with Spark, and data replication. Reliability is ensured through fault-tolerant design and monitoring with CloudWatch. Cost is optimized by using spot instances, reserved instances, and carefully selecting instance types.”</li>
<li><em>Communication Tip: Demonstrates awareness of practical considerations.</em></li>
</ul></li>
<li><p><strong>Handle Mathematical Details (Only if prompted, or if directly relevant to a specific point):</strong></p>
<ul>
<li>If asked about standardization, you could say: “For numerical standardization, Z-score scaling is common, where we subtract the mean and divide by the standard deviation. The formula is <span class="math inline">\(&lt;equation&gt; z = \frac{x - \mu}{\sigma} &lt;/equation&gt;\)</span>.”</li>
<li><em>Communication Tip: </em>Don’t* launch into mathematical derivations unless asked. If you do, explain the <em>purpose</em> of the equation before showing it. Keep it brief.*</li>
</ul></li>
<li><p><strong>End with Best Practices (30 seconds):</strong></p>
<ul>
<li>“Data validation, version control, thorough documentation, and testing are crucial best practices for maintaining data quality and ensuring the pipeline’s robustness.”</li>
<li><em>Communication Tip: Reinforces your understanding of a well-managed process.</em></li>
</ul></li>
<li><p><strong>Interaction Tips:</strong></p>
<ul>
<li><strong>Pause:</strong> Pause after each stage to allow the interviewer to ask questions.</li>
<li><strong>Enthusiasm:</strong> Show genuine interest in the topic.</li>
<li><strong>Adapt:</strong> Tailor your response to the interviewer’s background. If they’re more technical, you can go into more detail. If they’re more business-oriented, focus on the business value of data preprocessing.</li>
<li><strong>“What-If” Scenarios:</strong> Be prepared to discuss alternative approaches or how you would handle specific challenges.</li>
<li><strong>Ask Questions:</strong> Ask clarifying questions, such as “Are there any specific data types or sources you’d like me to address in more detail?”</li>
</ul></li>
</ol>
<p>By structuring your answer in this way, you’ll demonstrate your senior-level expertise in a clear, concise, and engaging manner. You’ll show not only that you understand the technical details but also that you can communicate them effectively and consider the practical aspects of building a data preprocessing pipeline on a cloud platform.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>