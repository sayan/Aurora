<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.41">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>momentum_0</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../../">
<script src="../../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../site_libs/quarto-html/quarto-syntax-highlighting-48ffa3e5b9d089919c6712c39e5b00f2.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../site_libs/bootstrap/bootstrap-a37d0bf9d509de95c1ba4621f20add8c.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<section id="question-1.-could-you-briefly-explain-the-concept-of-momentum-as-used-in-optimization-algorithms-such-as-sgd-with-momentum-please-discuss-the-role-of-the-momentum-coefficient-and-its-impact-on-gradient-descent-updates." class="level3">
<h3 class="anchored" data-anchor-id="question-1.-could-you-briefly-explain-the-concept-of-momentum-as-used-in-optimization-algorithms-such-as-sgd-with-momentum-please-discuss-the-role-of-the-momentum-coefficient-and-its-impact-on-gradient-descent-updates."><strong>Question:</strong> 1. Could you briefly explain the concept of momentum as used in optimization algorithms such as SGD with momentum? Please discuss the role of the momentum coefficient and its impact on gradient descent updates.</h3>
<p><strong>Best Answer</strong></p>
<p>Momentum, in the context of optimization algorithms like Stochastic Gradient Descent (SGD), is a technique used to accelerate learning, especially in scenarios where the loss function has high curvature, small but consistent gradients, or noisy gradients. It essentially adds inertia to the update steps, allowing the optimizer to “roll” through local minima and speed up convergence.</p>
<p><strong>Core Idea:</strong></p>
<p>The fundamental idea behind momentum is to accumulate a “velocity” vector that aggregates past gradients. This velocity vector is then used to update the parameters, rather than directly using the current gradient.</p>
<p><strong>Mathematical Formulation:</strong></p>
<p>The update rules for SGD with momentum can be defined as follows:</p>
<ol type="1">
<li><p><strong>Calculate Velocity:</strong> <span class="math display">\[v_t = \gamma v_{t-1} + \eta \nabla L(\theta_{t-1})\]</span> Where:</p>
<ul>
<li><span class="math inline">\(v_t\)</span> is the velocity vector at time step <span class="math inline">\(t\)</span>.</li>
<li><span class="math inline">\(\gamma\)</span> is the momentum coefficient (typically between 0 and 1).</li>
<li><span class="math inline">\(v_{t-1}\)</span> is the velocity vector at the previous time step.</li>
<li><span class="math inline">\(\eta\)</span> is the learning rate.</li>
<li><span class="math inline">\(\nabla L(\theta_{t-1})\)</span> is the gradient of the loss function <span class="math inline">\(L\)</span> with respect to the parameters <span class="math inline">\(\theta\)</span> at the previous time step <span class="math inline">\(t-1\)</span>.</li>
</ul></li>
<li><p><strong>Update Parameters:</strong> <span class="math display">\[\theta_t = \theta_{t-1} - v_t\]</span> Where:</p>
<ul>
<li><span class="math inline">\(\theta_t\)</span> is the parameter vector at time step <span class="math inline">\(t\)</span>.</li>
<li><span class="math inline">\(\theta_{t-1}\)</span> is the parameter vector at the previous time step <span class="math inline">\(t-1\)</span>.</li>
</ul></li>
</ol>
<p><strong>Role of the Momentum Coefficient (<span class="math inline">\(\gamma\)</span> or <span class="math inline">\(\beta\)</span>):</strong></p>
<p>The momentum coefficient, <span class="math inline">\(\gamma\)</span>, controls the influence of past gradients on the current update. It determines how much “memory” the optimizer retains.</p>
<ul>
<li><p><strong><span class="math inline">\(\gamma = 0\)</span>:</strong> In this case, the velocity vector becomes simply <span class="math inline">\(v_t = \eta \nabla L(\theta_{t-1})\)</span>, and the update rule reduces to standard SGD without momentum. The update is solely based on the current gradient.</p></li>
<li><p><strong><span class="math inline">\(0 &lt; \gamma &lt; 1\)</span>:</strong> This is the typical range for the momentum coefficient. The velocity vector is a weighted average of the past gradients. A larger <span class="math inline">\(\gamma\)</span> gives more weight to past gradients, resulting in smoother updates.</p></li>
<li><p><strong><span class="math inline">\(\gamma \approx 1\)</span> (e.g., 0.9 or 0.99):</strong> This setting gives a very high influence to past gradients. It can help the optimizer to overcome small local minima or plateaus, but it can also cause it to overshoot the global minimum if not tuned properly. The algorithm can become less responsive to changes in the current gradient.</p></li>
</ul>
<p><strong>Impact on Gradient Descent Updates:</strong></p>
<ol type="1">
<li><p><strong>Smoothing Effect:</strong> Momentum smooths out the updates, reducing oscillations. This is particularly helpful when the loss surface has narrow ravines or is highly curved. In standard SGD, the updates might bounce back and forth between the walls of the ravine, leading to slow convergence. With momentum, the accumulated velocity helps the optimizer to move along the ravine more directly.</p></li>
<li><p><strong>Faster Convergence:</strong> By accumulating gradients, momentum can accelerate convergence, especially in directions where the gradient is consistently pointing in the same general direction. The update becomes larger and more consistent in those directions.</p></li>
<li><p><strong>Escaping Local Minima:</strong> Momentum can help the optimizer to escape shallow local minima. The accumulated velocity can provide enough inertia to carry the optimizer over small bumps in the loss surface.</p></li>
<li><p><strong>Dealing with Noisy Gradients:</strong> In situations where the gradients are noisy (e.g., due to mini-batch sampling), momentum can reduce the impact of individual noisy gradients by averaging them over time.</p></li>
</ol>
<p><strong>Practical Considerations:</strong></p>
<ul>
<li><p><strong>Initialization:</strong> It’s common to initialize the velocity vector <span class="math inline">\(v_0\)</span> to zero.</p></li>
<li><p><strong>Tuning:</strong> The learning rate <span class="math inline">\(\eta\)</span> and momentum coefficient <span class="math inline">\(\gamma\)</span> are hyperparameters that need to be tuned. A common strategy is to start with a relatively large learning rate and a moderate momentum (e.g., <span class="math inline">\(\gamma = 0.9\)</span>) and then reduce the learning rate as training progresses.</p></li>
<li><p><strong>Nesterov Momentum:</strong> A more advanced version of momentum, called Nesterov accelerated gradient (NAG) or Nesterov momentum, improves the performance of standard momentum by evaluating the gradient at a “lookahead” position. The update rules are as follows: <span class="math display">\[v_t = \gamma v_{t-1} + \eta \nabla L(\theta_{t-1} - \gamma v_{t-1})\]</span> <span class="math display">\[\theta_t = \theta_{t-1} - v_t\]</span></p>
<p>Nesterov momentum often leads to faster convergence than standard momentum.</p></li>
<li><p><strong>Adaptive Methods:</strong> Algorithms like Adam, RMSprop, and Adagrad build on the idea of momentum and adaptively adjust the learning rate for each parameter, often providing even faster and more robust convergence.</p></li>
</ul>
<p>In summary, momentum is a powerful technique that can significantly improve the training of neural networks by accelerating convergence, smoothing updates, and helping the optimizer to escape local minima. The momentum coefficient <span class="math inline">\(\gamma\)</span> is a key hyperparameter that controls the influence of past gradients and needs to be carefully tuned.</p>
<p><strong>How to Narrate</strong></p>
<p>Here’s a guide on how to articulate this answer in an interview:</p>
<ol type="1">
<li><p><strong>Start with the basic idea:</strong></p>
<ul>
<li>“Momentum is a technique used in optimization algorithms like SGD to accelerate learning, especially when dealing with loss functions that have high curvature or noisy gradients. It’s like giving the optimizer ‘inertia’.”</li>
</ul></li>
<li><p><strong>Explain the core concept:</strong></p>
<ul>
<li>“The main idea is to accumulate a ‘velocity’ vector based on past gradients. Instead of updating the parameters directly with the current gradient, we update them using this velocity vector.”</li>
</ul></li>
<li><p><strong>Present the mathematical formulation:</strong></p>
<ul>
<li>“Mathematically, the update rules are as follows: First, we calculate the velocity: <span class="math inline">\(v_t = \gamma v_{t-1} + \eta \nabla L(\theta_{t-1})\)</span>. Here, <span class="math inline">\(v_t\)</span> is the velocity at time <span class="math inline">\(t\)</span>, <span class="math inline">\(\gamma\)</span> is the momentum coefficient, <span class="math inline">\(\eta\)</span> is the learning rate, and <span class="math inline">\(\nabla L(\theta_{t-1})\)</span> is the gradient of the loss function. Then, we update the parameters: <span class="math inline">\(\theta_t = \theta_{t-1} - v_t\)</span>.”</li>
<li><em>Communication Tip:</em> When presenting equations, speak slowly and clearly. Explain each term as you go. Avoid rushing through it.</li>
</ul></li>
<li><p><strong>Discuss the momentum coefficient (<span class="math inline">\(\gamma\)</span>):</strong></p>
<ul>
<li>“The momentum coefficient, <span class="math inline">\(\gamma\)</span>, is crucial. It controls how much influence past gradients have on the current update. If <span class="math inline">\(\gamma\)</span> is 0, we’re back to standard SGD. A typical value is around 0.9, which gives significant weight to past gradients.”</li>
</ul></li>
<li><p><strong>Explain the impact on gradient descent updates:</strong></p>
<ul>
<li>“Momentum has several important effects. First, it smooths out the updates, reducing oscillations. Imagine a ball rolling down a bumpy hill; momentum helps it to keep rolling instead of getting stuck. Second, it can lead to faster convergence because we’re accumulating gradients in consistent directions. Finally, it can help the optimizer escape shallow local minima by giving it enough ‘inertia’ to roll over small bumps.”</li>
</ul></li>
<li><p><strong>Mention practical considerations:</strong></p>
<ul>
<li>“In practice, we usually initialize the velocity to zero. Both the learning rate and the momentum coefficient need to be tuned. Also, it’s worth knowing about Nesterov momentum, which is an improvement over standard momentum and often converges faster. Algorithms like Adam and RMSProp build upon these concepts and adaptively adjust the learning rates for each parameter.”</li>
</ul></li>
<li><p><strong>Summarize:</strong></p>
<ul>
<li>“So, in short, momentum is a powerful technique that can significantly improve training by accelerating convergence, smoothing updates, and helping to escape local minima. The momentum coefficient is a key hyperparameter that needs to be tuned.”</li>
</ul></li>
</ol>
<p><em>Communication Tips:</em></p>
<ul>
<li><strong>Pace yourself:</strong> Don’t rush the explanation. Allow the interviewer time to process the information.</li>
<li><strong>Use analogies:</strong> The “ball rolling down a hill” analogy can be helpful for understanding the smoothing effect of momentum.</li>
<li><strong>Check for understanding:</strong> Pause occasionally and ask, “Does that make sense?” or “Are there any questions about that?”. This encourages interaction and ensures the interviewer is following along.</li>
<li><strong>Highlight key points:</strong> Emphasize the importance of the momentum coefficient and the benefits of momentum in terms of convergence speed and escaping local minima.</li>
<li><strong>Be prepared to elaborate:</strong> The interviewer might ask follow-up questions about Nesterov momentum, adaptive methods, or how to tune the hyperparameters. Be ready to discuss these topics in more detail.</li>
</ul>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>