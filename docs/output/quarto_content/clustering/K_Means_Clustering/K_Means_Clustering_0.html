<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>k_means_clustering_0</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../../">
<script src="../../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../site_libs/bootstrap/bootstrap-5d3fd86dc4559d58e199c8cc4a79ed5b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<section id="question-1.-what-is-the-objective-function-minimized-by-k-means-clustering-and-how-is-it-computed" class="level2">
<h2 class="anchored" data-anchor-id="question-1.-what-is-the-objective-function-minimized-by-k-means-clustering-and-how-is-it-computed">Question: 1. What is the objective function minimized by K-Means clustering, and how is it computed?</h2>
<p><strong>Best Answer</strong></p>
<p>K-Means clustering is an unsupervised learning algorithm aimed at partitioning <span class="math inline">\(n\)</span> data points into <span class="math inline">\(k\)</span> clusters, where each data point belongs to the cluster with the nearest mean (centroid). The primary objective of K-Means is to minimize the within-cluster sum of squares (WCSS), also known as the inertia. This is achieved by iteratively assigning data points to the nearest cluster and updating the cluster centroids based on the new assignments.</p>
<ul>
<li><p><strong>Objective Function:</strong></p>
<p>The objective function, often denoted as <span class="math inline">\(J\)</span>, is defined as the sum of the squared Euclidean distances between each data point and its assigned cluster centroid: <span class="math display">\[
J = \sum_{i=1}^{n} \sum_{j=1}^{k} r_{ij} ||x_i - \mu_j||^2
\]</span> where:</p>
<ul>
<li><span class="math inline">\(n\)</span> is the number of data points.</li>
<li><span class="math inline">\(k\)</span> is the number of clusters.</li>
<li><span class="math inline">\(x_i\)</span> represents the <span class="math inline">\(i\)</span>-th data point.</li>
<li><span class="math inline">\(\mu_j\)</span> represents the centroid of the <span class="math inline">\(j\)</span>-th cluster.</li>
<li><span class="math inline">\(r_{ij}\)</span> is a binary indicator variable that is 1 if data point <span class="math inline">\(x_i\)</span> belongs to cluster <span class="math inline">\(j\)</span>, and 0 otherwise. Effectively, <span class="math inline">\(r_{ij} = 1\)</span> if <span class="math inline">\(j = \arg\min_{l} ||x_i - \mu_l||^2\)</span>, meaning we select the cluster <span class="math inline">\(j\)</span> that minimizes the distance between the data point <span class="math inline">\(x_i\)</span> and the cluster center <span class="math inline">\(\mu_l\)</span> for all possible cluster centers <span class="math inline">\(l\)</span>.</li>
<li><span class="math inline">\(||x_i - \mu_j||^2\)</span> is the squared Euclidean distance between data point <span class="math inline">\(x_i\)</span> and centroid <span class="math inline">\(\mu_j\)</span>.</li>
</ul></li>
<li><p><strong>Computation of the Objective Function:</strong></p>
<p>The computation of the objective function is intertwined with the K-Means algorithm’s iterative process:</p>
<ol type="1">
<li><strong>Initialization:</strong>
<ul>
<li>Randomly initialize <span class="math inline">\(k\)</span> cluster centroids <span class="math inline">\(\mu_1, \mu_2, ..., \mu_k\)</span>. Common strategies include randomly selecting <span class="math inline">\(k\)</span> data points as initial centroids or using more sophisticated methods like K-Means++.</li>
</ul></li>
<li><strong>Assignment Step:</strong>
<ul>
<li>Assign each data point <span class="math inline">\(x_i\)</span> to the nearest cluster centroid <span class="math inline">\(\mu_j\)</span> based on the Euclidean distance: <span class="math display">\[
r_{ij} =
\begin{cases}
    1, &amp; \text{if } j = \arg\min_{l} ||x_i - \mu_l||^2 \\
    0, &amp; \text{otherwise}
\end{cases}
\]</span></li>
<li>This step aims to minimize the objective function <span class="math inline">\(J\)</span> with respect to the assignments <span class="math inline">\(r_{ij}\)</span>, keeping the centroids fixed.</li>
</ul></li>
<li><strong>Update Step:</strong>
<ul>
<li>Recalculate the centroids <span class="math inline">\(\mu_j\)</span> of each cluster by taking the mean of all data points assigned to that cluster: <span class="math display">\[
\mu_j = \frac{\sum_{i=1}^{n} r_{ij} x_i}{\sum_{i=1}^{n} r_{ij}}
\]</span></li>
<li>This step minimizes the objective function <span class="math inline">\(J\)</span> with respect to the centroids <span class="math inline">\(\mu_j\)</span>, keeping the assignments fixed. The new centroid is the sample mean of all the points assigned to the <span class="math inline">\(j\)</span>-th cluster.</li>
</ul></li>
<li><strong>Iteration and Convergence:</strong>
<ul>
<li>Repeat the assignment and update steps until the cluster assignments no longer change significantly, or a maximum number of iterations is reached. Convergence is typically assessed by monitoring the change in the objective function <span class="math inline">\(J\)</span> or the stability of the cluster assignments. The algorithm has converged when the assignments don’t change anymore.</li>
</ul></li>
</ol></li>
<li><p><strong>Why Minimize WCSS?</strong></p>
<p>Minimizing WCSS aims to create clusters that are as compact and well-separated as possible. Lower WCSS indicates that data points within each cluster are closer to their respective centroids, suggesting more coherent and distinct clusters. However, it is important to note that minimizing WCSS does not guarantee the discovery of “true” clusters that align with underlying data generating processes, especially when the data does not naturally conform to the assumptions of K-Means (e.g., spherical, equally sized clusters).</p></li>
<li><p><strong>Limitations and Considerations:</strong></p>
<ul>
<li><strong>Sensitivity to Initialization:</strong> K-Means is sensitive to the initial placement of centroids, which can lead to different clustering results. Techniques like K-Means++ address this by intelligently selecting initial centroids to improve convergence and solution quality.</li>
<li><strong>Assumption of Spherical Clusters:</strong> K-Means assumes that clusters are spherical and equally sized. It may not perform well on data with non-spherical or irregularly shaped clusters.</li>
<li><strong>Equal Variance:</strong> K-means assumes the variance of each of the clusters are similar, which may not be the case in real life situations.</li>
<li><strong>Requires Pre-defined K:</strong> The number of clusters <span class="math inline">\(k\)</span> needs to be specified in advance, which may not always be known. Techniques like the elbow method or silhouette analysis can help estimate the optimal number of clusters.</li>
<li><strong>Local Optima:</strong> K-Means is guaranteed to converge, but not necessarily to the global optimum. It can get stuck in local minima. Running the algorithm multiple times with different initializations and selecting the solution with the lowest WCSS is a common practice.</li>
</ul></li>
<li><p><strong>Mathematical Proof of Centroid Update:</strong></p>
<p>To show that updating the centroids by taking the mean of the assigned points minimizes the objective function <span class="math inline">\(J\)</span>, we can take the derivative of <span class="math inline">\(J\)</span> with respect to <span class="math inline">\(\mu_j\)</span> and set it to zero:</p>
<p><span class="math display">\[
\frac{\partial J}{\partial \mu_j} = \frac{\partial}{\partial \mu_j} \sum_{i=1}^{n} r_{ij} ||x_i - \mu_j||^2 = 0
\]</span></p>
<p>Expanding the squared Euclidean distance: <span class="math display">\[
\frac{\partial}{\partial \mu_j} \sum_{i=1}^{n} r_{ij} (x_i - \mu_j)^T (x_i - \mu_j) = 0
\]</span></p>
<p>Taking the derivative: <span class="math display">\[
\sum_{i=1}^{n} r_{ij} \frac{\partial}{\partial \mu_j} (x_i^T x_i - 2x_i^T \mu_j + \mu_j^T \mu_j) = 0
\]</span></p>
<p><span class="math display">\[
\sum_{i=1}^{n} r_{ij} (-2x_i + 2\mu_j) = 0
\]</span></p>
<p><span class="math display">\[
\sum_{i=1}^{n} r_{ij} x_i = \sum_{i=1}^{n} r_{ij} \mu_j
\]</span></p>
<p><span class="math display">\[
\sum_{i=1}^{n} r_{ij} x_i = \mu_j \sum_{i=1}^{n} r_{ij}
\]</span></p>
<p>Thus, <span class="math display">\[
\mu_j = \frac{\sum_{i=1}^{n} r_{ij} x_i}{\sum_{i=1}^{n} r_{ij}}
\]</span></p>
<p>This confirms that updating the centroids by taking the mean of the points assigned to the cluster minimizes the objective function.</p></li>
</ul>
<p><strong>How to Narrate</strong></p>
<p>Here’s a breakdown of how to present this answer effectively in an interview:</p>
<ol type="1">
<li><p><strong>Start with the Basics:</strong></p>
<ul>
<li>“K-Means clustering aims to partition data into <span class="math inline">\(k\)</span> clusters. The goal is to minimize the within-cluster sum of squares, often referred to as the inertia, which is the sum of the squared distances between each data point and its cluster’s centroid.”</li>
</ul></li>
<li><p><strong>Introduce the Objective Function:</strong></p>
<ul>
<li>“Mathematically, the objective function J can be represented as: [ J = <em>{i=1}^{n} </em>{j=1}^{k} r_{ij} ||x_i - _j||^2 ]. Here, <span class="math inline">\(x_i\)</span> is a data point, <span class="math inline">\(\mu_j\)</span> is the centroid of cluster <span class="math inline">\(j\)</span>, and <span class="math inline">\(r_{ij}\)</span> is an indicator variable showing if <span class="math inline">\(x_i\)</span> belongs to cluster <span class="math inline">\(j\)</span>.”</li>
<li><em>Communication Tip: Pause slightly after introducing the equation and highlight the key components. Make sure the interviewer understands what each term represents before moving on.</em></li>
</ul></li>
<li><p><strong>Explain the Iterative Process:</strong></p>
<ul>
<li>“The K-Means algorithm works iteratively. First, we initialize <span class="math inline">\(k\)</span> cluster centroids. Then, in the assignment step, each data point is assigned to the nearest centroid. Next, in the update step, the centroids are recalculated as the mean of all data points assigned to them. We repeat these two steps until convergence.”</li>
<li><em>Communication Tip: Use simple language to explain the steps. Visualizing the steps can also be helpful. For instance, imagine points being colored based on the closest center, then the centers moving to the average position of each color group.</em></li>
</ul></li>
<li><p><strong>Discuss the Rationale and Implications:</strong></p>
<ul>
<li>“Minimizing WCSS leads to compact, well-separated clusters. However, it relies on assumptions like spherical clusters and can be sensitive to initialization. It’s a useful metric but doesn’t guarantee ‘true’ clusters.”</li>
<li><em>Communication Tip: Mention the limitations to show awareness of the algorithm’s shortcomings. This demonstrates a deeper understanding than simply stating its advantages.</em></li>
</ul></li>
<li><p><strong>Address Limitations and Solutions (if time permits or prompted):</strong></p>
<ul>
<li>“K-Means has certain limitations. It assumes spherical clusters, requires pre-defining ‘k’, and is sensitive to initial centroid placement. Techniques like K-Means++ can mitigate the initialization issue, and methods like the elbow method help estimate the optimal ‘k’.”</li>
</ul></li>
<li><p><strong>Briefly Touch Upon the Derivative (if comfortable):</strong></p>
<ul>
<li>“To prove that updating centroids with the mean minimizes the objective, we can take the derivative of <span class="math inline">\(J\)</span> with respect to <span class="math inline">\(\mu_j\)</span>, set it to zero, and solve for <span class="math inline">\(\mu_j\)</span>. This confirms that the sample mean minimizes the objective function”.</li>
<li><em>Communication Tip: Only delve into the derivative if you feel confident and the interviewer seems interested. Offer it as an optional detail rather than making it a core part of the explanation.</em></li>
</ul></li>
<li><p><strong>Invite Questions:</strong></p>
<ul>
<li>“That’s an overview of the objective function in K-Means. Are there any specific areas you’d like me to elaborate on further?”</li>
<li><em>Communication Tip: End with an open invitation for more questions to show engagement and readiness to discuss the topic further.</em></li>
</ul></li>
</ol>
<p>By balancing a clear explanation of the core concepts with more advanced details and limitations, you demonstrate a strong understanding of K-Means clustering at a senior level.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>