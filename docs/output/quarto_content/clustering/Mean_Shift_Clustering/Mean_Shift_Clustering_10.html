<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>mean_shift_clustering_10</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../../">
<script src="../../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../site_libs/bootstrap/bootstrap-5d3fd86dc4559d58e199c8cc4a79ed5b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<section id="question-11.-can-you-provide-an-example-of-a-real-world-application-e.g.-in-computer-vision-or-signal-processing-where-mean-shift-clustering-has-been-effectively-used-how-does-its-theoretical-basis-translate-into-practical-benefits" class="level2">
<h2 class="anchored" data-anchor-id="question-11.-can-you-provide-an-example-of-a-real-world-application-e.g.-in-computer-vision-or-signal-processing-where-mean-shift-clustering-has-been-effectively-used-how-does-its-theoretical-basis-translate-into-practical-benefits">Question: 11. Can you provide an example of a real-world application (e.g., in computer vision or signal processing) where Mean-Shift Clustering has been effectively used? How does its theoretical basis translate into practical benefits?</h2>
<p><strong>Best Answer</strong></p>
<p>Mean-Shift Clustering is a versatile, non-parametric clustering algorithm used in various real-world applications, particularly in computer vision and signal processing. One prominent example is its application in <strong>object tracking</strong>, specifically <strong>Mean-Shift Tracking</strong>.</p>
<p><strong>1. Mean-Shift Tracking in Computer Vision:</strong></p>
<ul>
<li><p><strong>Problem:</strong> Object tracking involves locating an object of interest in a video sequence across multiple frames. This is challenging due to object motion, changes in appearance (illumination, pose, occlusion), and background clutter.</p></li>
<li><p><strong>Mean-Shift Approach:</strong> In Mean-Shift Tracking, we represent the object’s appearance in the initial frame as a probability density function (PDF), often using a color histogram. The algorithm then iteratively shifts a search window in subsequent frames to find the region that maximizes similarity (e.g., using the Bhattacharyya coefficient or other similarity measures) to the initial object PDF.</p></li>
</ul>
<p>Let’s delve into the mathematical details. Suppose we have a target model (the object to be tracked) represented by the probability density <span class="math inline">\(q_u\)</span>, <span class="math inline">\(u = 1, \dots, m\)</span> where <span class="math inline">\(m\)</span> is the number of bins in our feature space (e.g., color histogram bins). In the next frame, we have a candidate model at location <span class="math inline">\(y\)</span> represented by <span class="math inline">\(p_u(y)\)</span>. The similarity between the two can be measured using the Bhattacharyya coefficient:</p>
<p><span class="math display">\[
\rho(y) = \sum_{u=1}^{m} \sqrt{p_u(y)q_u}
\]</span></p>
<p>The goal is to maximize <span class="math inline">\(\rho(y)\)</span>. Using a Taylor expansion around the current location <span class="math inline">\(y_0\)</span>, we can approximate <span class="math inline">\(\rho(y)\)</span>:</p>
<p><span class="math display">\[
\rho(y) \approx \rho(y_0) + \frac{1}{2} (y - y_0)^T \nabla^2 \rho(y_0) (y - y_0)
\]</span></p>
<p>The mean-shift vector, which indicates the direction to move the search window, is then given by:</p>
<p><span class="math display">\[
\Delta y = \frac{\sum_{i=1}^{n} x_i w_i g( || \frac{y - x_i}{h} ||^2 ) }{\sum_{i=1}^{n} w_i g( || \frac{y - x_i}{h} ||^2 )} - y
\]</span></p>
<p>where:</p>
<ul>
<li><p><span class="math inline">\(x_i\)</span> are the pixel locations in the search window.</p></li>
<li><p><span class="math inline">\(w_i = \sqrt{\frac{q_u}{p_u(y)}}\)</span> are the weights derived from the target and candidate model probabilities. These weights are crucial because they emphasize the contribution of pixels that are more similar to the target distribution <span class="math inline">\(q_u\)</span>.</p></li>
<li><p><span class="math inline">\(h\)</span> is the bandwidth parameter of the kernel.</p></li>
<li><p><span class="math inline">\(g(x) = -k'(x)\)</span>, where <span class="math inline">\(k(x)\)</span> is the kernel profile (e.g., Epanechnikov kernel). The derivative of the kernel profile influences the weighting of nearby data points in the mean-shift calculation.</p></li>
<li><p><strong>Kernel Density Estimation (KDE):</strong> The algorithm utilizes KDE to estimate the probability density of data points, enabling it to adapt to complex, non-Gaussian distributions. The choice of kernel function and bandwidth parameter is critical for performance.</p></li>
<li><p><strong>Advantages:</strong></p>
<ul>
<li><strong>Non-parametric:</strong> It doesn’t assume any prior shape or distribution for the object, making it robust to changes in appearance and shape deformation.</li>
<li><strong>Mode-Seeking:</strong> It efficiently converges to the mode of the probability density function, allowing it to accurately locate the object even in cluttered scenes.</li>
<li><strong>Simple Implementation:</strong> Relatively easy to implement and computationally efficient.</li>
</ul></li>
<li><p><strong>Practical Benefits from Theoretical Basis:</strong></p>
<ul>
<li>The mode-seeking property, derived from the iterative mean-shift update, ensures convergence to the region of highest similarity, even with noisy data. The algorithm essentially climbs the density gradient.</li>
<li>The use of KDE allows the algorithm to handle complex object appearance models without assuming a specific parametric form. This is vital when objects undergo non-rigid deformations or illumination changes.</li>
<li>The weights <span class="math inline">\(w_i\)</span> derived from the Bhattacharyya coefficient emphasize relevant features during the tracking, making the algorithm robust to occlusions and background clutter.</li>
</ul></li>
</ul>
<p><strong>2. Other Applications and Considerations:</strong></p>
<ul>
<li><strong>Image Segmentation:</strong> Mean-Shift can be used to segment images by clustering pixels based on their color and spatial location. This can create visually meaningful segments, especially when combined with other techniques.</li>
<li><strong>Data Smoothing:</strong> In signal processing, Mean-Shift can be used to smooth data while preserving important features by shifting data points towards regions of higher density.</li>
<li><strong>Bandwidth Selection:</strong> A key parameter in Mean-Shift is the bandwidth <span class="math inline">\(h\)</span>. Choosing the right bandwidth is crucial for performance. Small bandwidths can lead to overfitting (detecting too many modes), while large bandwidths can oversmooth the data. Various bandwidth selection techniques exist, such as cross-validation.</li>
<li><strong>Computational Complexity:</strong> The computational complexity of Mean-Shift can be high, especially for large datasets. Approximation techniques, such as using tree-based search structures, can be used to speed up the algorithm.</li>
<li><strong>Initialization:</strong> The initial location of the search window in tracking significantly impacts performance. Poor initialization can lead to the algorithm tracking the wrong object.</li>
</ul>
<p>In summary, Mean-Shift Clustering, particularly Mean-Shift Tracking, is a powerful example of how the theoretical basis of a non-parametric clustering algorithm translates into practical benefits in real-world applications. Its mode-seeking behavior, combined with its ability to handle complex data distributions, makes it a valuable tool for various computer vision and signal processing tasks.</p>
<p><strong>How to Narrate</strong></p>
<p>Here’s a guide on how to articulate this answer in an interview:</p>
<ol type="1">
<li><p><strong>Start with the Application:</strong> “Mean-Shift clustering has many applications, and I’d like to focus on its use in object tracking, specifically Mean-Shift Tracking, as a real-world example.” This immediately grounds your answer in a practical context.</p></li>
<li><p><strong>Explain the Problem:</strong> “Object tracking is a challenging problem because objects move, their appearance changes, and there’s often background clutter.”</p></li>
<li><p><strong>Describe the Mean-Shift Approach:</strong> “In Mean-Shift Tracking, we represent the object’s appearance in the initial frame as a probability density function, often using a color histogram. The algorithm iteratively shifts a search window to find the region that maximizes similarity to the initial object’s PDF.”</p></li>
<li><p><strong>Introduce Key Mathematical Concepts (Judiciously):</strong> “To understand how this works, we can define the similarity between the target model and a candidate model using the Bhattacharyya coefficient. The goal is to maximize this coefficient. This leads to an iterative update rule for the search window’s location, which can be expressed mathematically…”</p>
<ul>
<li><strong>Pace yourself:</strong> Introduce the equations slowly, explaining each term. For instance, “Here, <span class="math inline">\(q_u\)</span> represents the probability density of the target model, and <span class="math inline">\(p_u(y)\)</span> represents the probability density of the candidate model at location <span class="math inline">\(y\)</span>.”</li>
<li><strong>Focus on intuition:</strong> Emphasize the underlying intuition rather than getting bogged down in every detail. “Essentially, this formula tells us how much to shift the window to better match the target object.”</li>
<li><strong>Offer to simplify:</strong> “I can go into more detail about the derivation if you’d like, but the key takeaway is that the algorithm iteratively moves the search window toward the mode of the probability density.”</li>
</ul></li>
<li><p><strong>Highlight Advantages and Practical Benefits:</strong> “The strength of Mean-Shift Tracking comes from its non-parametric nature – it doesn’t assume a specific shape or distribution for the object, making it robust to changes in appearance. Also, the mode-seeking property ensures it converges to the correct location, even in cluttered scenes.” Connect these back to the equations. “The weights we calculate emphasize features that are more similar to the target, helping to filter out noise.”</p></li>
<li><p><strong>Briefly Mention Other Applications and Considerations:</strong> “Mean-Shift is also used in image segmentation and data smoothing. However, choosing the right bandwidth is critical, and the computational complexity can be high, which are important considerations in practice.”</p></li>
<li><p><strong>Pause for Questions:</strong> “That’s a brief overview of Mean-Shift Clustering and its application to object tracking. Do you have any questions about specific aspects or other applications?”</p></li>
</ol>
<p><strong>Communication Tips:</strong></p>
<ul>
<li><strong>Confidence:</strong> Speak confidently and show that you understand the topic.</li>
<li><strong>Clarity:</strong> Use clear and concise language, avoiding jargon where possible.</li>
<li><strong>Engagement:</strong> Maintain eye contact and be attentive to the interviewer’s reactions.</li>
<li><strong>Flexibility:</strong> Be prepared to adjust your explanation based on the interviewer’s level of understanding.</li>
<li><strong>Enthusiasm:</strong> Show your passion for the topic!</li>
</ul>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>