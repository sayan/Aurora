<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.41">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>hierarchical_clustering_0</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../../">
<script src="../../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../site_libs/quarto-html/quarto-syntax-highlighting-48ffa3e5b9d089919c6712c39e5b00f2.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../site_libs/bootstrap/bootstrap-a37d0bf9d509de95c1ba4621f20add8c.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<section id="question-1.-what-is-hierarchical-clustering-and-what-are-its-two-main-types" class="level2">
<h2 class="anchored" data-anchor-id="question-1.-what-is-hierarchical-clustering-and-what-are-its-two-main-types">Question: 1. What is hierarchical clustering, and what are its two main types?</h2>
<p><strong>Best Answer</strong></p>
<p>Hierarchical clustering is a class of unsupervised machine learning algorithms that build a hierarchy of clusters. Unlike k-means clustering, which requires specifying the number of clusters <em>a priori</em>, hierarchical clustering aims to create a complete hierarchy, allowing the user to choose the most appropriate level of granularity after the clustering process. The result is often visualized as a dendrogram, a tree-like diagram that records the sequences of merges or splits.</p>
<p>The core principle is based on the idea that objects are more related to nearby objects than to objects farther away. This notion of proximity is quantified by a distance metric, such as Euclidean distance, Manhattan distance, or cosine similarity, and a linkage criterion that determines how the distance between clusters is calculated.</p>
<p>There are two main types of hierarchical clustering:</p>
<ol type="1">
<li><p><strong>Agglomerative (Bottom-Up) Clustering:</strong></p>
<ul>
<li><p>This approach starts by treating each data point as a single cluster.</p></li>
<li><p>It then iteratively merges the closest pairs of clusters until only one cluster remains or a termination condition is met (e.g., reaching a desired number of clusters).</p></li>
<li><p>The algorithm can be summarized as follows:</p>
<ol type="1">
<li><strong>Initialization:</strong> Assign each data point to its own cluster. Thus, if you have <span class="math inline">\(N\)</span> data points, you initially have <span class="math inline">\(N\)</span> clusters.</li>
<li><strong>Compute Proximity Matrix:</strong> Calculate the distance between every pair of clusters. Let <span class="math inline">\(D(C_i, C_j)\)</span> be the distance between clusters <span class="math inline">\(C_i\)</span> and <span class="math inline">\(C_j\)</span>. This forms an <span class="math inline">\(N \times N\)</span> matrix.</li>
<li><strong>Merge Clusters:</strong> Find the two closest clusters according to the proximity matrix and merge them into a single cluster.</li>
<li><strong>Update Proximity Matrix:</strong> Recalculate the distances between the new cluster and all remaining clusters. This is where different linkage methods come into play.</li>
<li><strong>Repeat:</strong> Repeat steps 3 and 4 until all data points are in a single cluster or a specified number of clusters is reached.</li>
</ol></li>
<li><p><strong>Linkage Criteria:</strong> The method for determining the distance between clusters is crucial. Common linkage criteria include:</p>
<ul>
<li><strong>Single Linkage (Minimum):</strong> The distance between two clusters is defined as the shortest distance between any two points in the clusters. <span class="math inline">\(D(C_i, C_j) = \min_{x \in C_i, y \in C_j} d(x, y)\)</span>. Single linkage can suffer from the “chaining effect,” where clusters can become long and straggly.</li>
<li><strong>Complete Linkage (Maximum):</strong> The distance between two clusters is defined as the longest distance between any two points in the clusters. <span class="math inline">\(D(C_i, C_j) = \max_{x \in C_i, y \in C_j} d(x, y)\)</span>. Complete linkage tends to produce more compact clusters.</li>
<li><strong>Average Linkage:</strong> The distance between two clusters is the average distance between all pairs of points, one from each cluster. <span class="math inline">\(D(C_i, C_j) = \frac{1}{|C_i||C_j|} \sum_{x \in C_i} \sum_{y \in C_j} d(x, y)\)</span>, where <span class="math inline">\(|C_i|\)</span> and <span class="math inline">\(|C_j|\)</span> represent the number of points in clusters <span class="math inline">\(C_i\)</span> and <span class="math inline">\(C_j\)</span>, respectively. It strikes a balance between single and complete linkage.</li>
<li><strong>Centroid Linkage:</strong> The distance between two clusters is the distance between their centroids (means). <span class="math inline">\(D(C_i, C_j) = d(\mu_i, \mu_j)\)</span>, where <span class="math inline">\(\mu_i\)</span> and <span class="math inline">\(\mu_j\)</span> are the centroids of clusters <span class="math inline">\(C_i\)</span> and <span class="math inline">\(C_j\)</span>, respectively.</li>
<li><strong>Ward’s Linkage:</strong> This method minimizes the increase in the total within-cluster variance after merging. It tends to produce more balanced cluster sizes. Ward’s linkage is based on minimizing the increase in the error sum of squares (ESS). The ESS is calculated as: <span class="math display">\[ESS = \sum_{i=1}^{k} \sum_{x \in C_i} ||x - \mu_i||^2\]</span> where <span class="math inline">\(k\)</span> is the number of clusters and <span class="math inline">\(\mu_i\)</span> is the centroid of cluster <span class="math inline">\(C_i\)</span>. Ward’s linkage chooses the merge that minimizes the increase in ESS. The distance between clusters <span class="math inline">\(C_i\)</span> and <span class="math inline">\(C_j\)</span> is defined as the increase in ESS if the two clusters are merged. This can be expressed as: <span class="math display">\[D(C_i, C_j) = \frac{|C_i| |C_j|}{|C_i| + |C_j|} ||\mu_i - \mu_j||^2\]</span></li>
</ul></li>
<li><p><strong>Advantages:</strong> Simple to implement, provides a hierarchy of clusters. Doesn’t require specifying the number of clusters beforehand.</p></li>
<li><p><strong>Disadvantages:</strong> Can be computationally expensive, especially for large datasets. Sensitive to noise and outliers. The choice of linkage criterion can significantly impact the results. Once a merge happens, it cannot be undone.</p></li>
</ul></li>
<li><p><strong>Divisive (Top-Down) Clustering:</strong></p>
<ul>
<li><p>This approach starts with all data points in a single cluster.</p></li>
<li><p>It then iteratively divides the cluster into smaller clusters until each data point forms its own cluster or a termination condition is met.</p></li>
<li><p>The algorithm can be summarized as follows:</p>
<ol type="1">
<li><strong>Initialization:</strong> Assign all data points to a single cluster.</li>
<li><strong>Choose Cluster to Split:</strong> Select a cluster to split, usually based on some criterion such as the cluster with the largest diameter or variance.</li>
<li><strong>Split Cluster:</strong> Divide the chosen cluster into two or more sub-clusters, often using a partitioning method like k-means or by finding the most dissimilar points.</li>
<li><strong>Repeat:</strong> Repeat steps 2 and 3 until each data point is in its own cluster or a stopping criterion is satisfied (e.g., reaching a desired number of clusters).</li>
</ol></li>
<li><p><strong>Splitting Strategies:</strong> The key challenge in divisive clustering is determining which cluster to split and how to split it. Common strategies include:</p>
<ul>
<li><strong>Monothetic Divisive Clustering:</strong> Splits clusters based on a single variable at a time. This is useful when interpretability is crucial.</li>
<li><strong>Polythetic Divisive Clustering:</strong> Considers all variables simultaneously to determine the best split. This is generally more accurate but less interpretable. A common approach is to use a flat clustering algorithm (like k-means) to divide the cluster.</li>
<li><strong>DIANA (Divisive Analysis Clustering):</strong> One of the most known algorithm. It starts by finding the data point with the largest average dissimilarity to all other points in the cluster (this is considered the most “eccentric” point). Then it forms a “splinter group” by moving points that are more similar to the eccentric point than to the remaining cluster. This process is repeated until all data points are in their own cluster or a stopping criterion is reached.</li>
</ul></li>
<li><p><strong>Advantages:</strong> Can be more efficient than agglomerative clustering in certain cases, especially when the top levels of the hierarchy are of interest. Can identify larger, more natural clusters early on.</p></li>
<li><p><strong>Disadvantages:</strong> More complex to implement than agglomerative clustering. The choice of splitting criterion can significantly impact the results. Can be computationally expensive for very large datasets, especially if all levels of the hierarchy are needed.</p></li>
</ul></li>
</ol>
<p><strong>Scenarios:</strong></p>
<ul>
<li><p><strong>Agglomerative:</strong> Commonly used in bioinformatics (e.g., clustering gene expression data), customer segmentation, and document clustering. The varying linkage criteria provide flexibility in capturing different cluster shapes.</p></li>
<li><p><strong>Divisive:</strong> Useful when there is a clear global structure that needs to be successively refined. Can be more appropriate when the dataset is very large and only the top-level clusters are of interest.</p></li>
</ul>
<p>In summary, hierarchical clustering provides a flexible framework for exploring the structure of data without requiring prior knowledge of the number of clusters. The choice between agglomerative and divisive approaches, as well as the selection of distance metrics and linkage criteria, depends on the specific characteristics of the data and the goals of the analysis.</p>
<p><strong>How to Narrate</strong></p>
<p>Here’s a step-by-step guide on how to deliver this answer in an interview:</p>
<ol type="1">
<li><p><strong>Start with the Definition:</strong></p>
<ul>
<li>“Hierarchical clustering is an unsupervised machine learning technique that builds a hierarchy of clusters, unlike methods like k-means which require you to pre-define the number of clusters. The key idea is to create a nested structure, often represented as a dendrogram, that shows how data points group together at different levels of similarity.”</li>
<li><em>Communication Tip:</em> Set the stage by clearly defining the concept and its purpose.</li>
</ul></li>
<li><p><strong>Introduce the Two Main Types:</strong></p>
<ul>
<li>“There are two main approaches: agglomerative, which is a bottom-up approach, and divisive, which is a top-down approach.”</li>
<li><em>Communication Tip:</em> Clearly signal that you are about to discuss two distinct categories.</li>
</ul></li>
<li><p><strong>Explain Agglomerative Clustering:</strong></p>
<ul>
<li>“Agglomerative clustering starts with each data point as its own cluster and then iteratively merges the closest clusters until you have a single cluster containing all the data. The core steps are initialization, computing a proximity matrix, merging the closest clusters, updating the proximity matrix, and repeating this process until a stopping criterion is met.”</li>
<li>“The choice of <em>linkage criterion</em> significantly affects the resulting clusters. Single linkage considers the shortest distance between points in two clusters, complete linkage considers the longest distance, average linkage uses the average distance, centroid linkage uses the distance between cluster centroids, and Ward’s linkage minimizes the increase in within-cluster variance.”</li>
<li>“For example, single linkage can lead to elongated, ‘chaining’ clusters, while complete linkage tends to produce more compact clusters.”</li>
<li><em>Communication Tip:</em> Break down the algorithm into manageable steps. Briefly explain the common linkage criteria and the implications of using one over another. Try to avoid getting bogged down in the math <em>unless</em> the interviewer specifically asks.</li>
</ul></li>
<li><p><strong>Explain Divisive Clustering:</strong></p>
<ul>
<li>“Divisive clustering, conversely, starts with all data points in one large cluster and recursively divides it into smaller clusters until each data point is in its own cluster. The main challenge is deciding which cluster to split and how to split it.”</li>
<li>“There are different splitting strategies, such as monothetic (splitting based on a single variable) and polythetic (considering all variables simultaneously). One of the most well-known algorithms is DIANA, which iteratively identifies and removes ‘splinter groups’ from the main cluster.”</li>
<li><em>Communication Tip:</em> Draw the contrast between agglomerative and divisive. Highlight the complexities in divisive clustering, particularly the splitting strategies.</li>
</ul></li>
<li><p><strong>Discuss Advantages and Disadvantages:</strong></p>
<ul>
<li>“Agglomerative clustering is relatively simple to implement and doesn’t require specifying the number of clusters in advance, but it can be computationally expensive for large datasets and is sensitive to noise. Divisive clustering can be more efficient for large datasets when you’re only interested in the top-level clusters, but it’s generally more complex to implement.”</li>
<li><em>Communication Tip:</em> Briefly summarize the trade-offs of each approach.</li>
</ul></li>
<li><p><strong>Provide Real-World Scenarios:</strong></p>
<ul>
<li>“Agglomerative clustering is often used in bioinformatics for clustering gene expression data and in marketing for customer segmentation. Divisive clustering can be useful when there’s a clear global structure to the data that you want to refine.”</li>
<li><em>Communication Tip:</em> Give concrete examples to demonstrate practical knowledge and application.</li>
</ul></li>
<li><p><strong>Conclude with a Summary:</strong></p>
<ul>
<li>“In summary, hierarchical clustering offers a flexible way to explore data structure without needing to pre-define the number of clusters. The choice between agglomerative and divisive, as well as the selection of distance metrics and linkage criteria, depends on the specific dataset and the goals of the analysis.”</li>
<li><em>Communication Tip:</em> Reiterate the key points and emphasize the flexibility of hierarchical clustering.</li>
</ul></li>
</ol>
<p><strong>Handling Mathematical Sections:</strong></p>
<ul>
<li><strong>Pace Yourself:</strong> Speak slowly and clearly when explaining formulas.</li>
<li><strong>Explain the Intuition:</strong> Focus on the <em>meaning</em> of the formulas rather than just reciting them. For example, when discussing Ward’s linkage, say, “Ward’s linkage aims to minimize the increase in variance within the clusters after merging.”</li>
<li><strong>Use Visual Aids (If Possible):</strong> If you are in a virtual interview, consider quickly sketching a simple dendrogram or cluster diagram on a whiteboard (virtual or physical) to illustrate the merging process.</li>
<li><strong>Pause for Questions:</strong> After presenting a formula, pause briefly and ask, “Does that make sense?” or “Any questions about that?” This allows the interviewer to guide you if they need more clarification.</li>
</ul>
<p>By following these guidelines, you can deliver a comprehensive and clear explanation of hierarchical clustering that demonstrates your senior-level expertise. Remember to adjust your explanation based on the interviewer’s background and level of understanding.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>