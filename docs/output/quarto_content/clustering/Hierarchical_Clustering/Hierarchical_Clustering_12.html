<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>hierarchical_clustering_12</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../../">
<script src="../../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../site_libs/bootstrap/bootstrap-5d3fd86dc4559d58e199c8cc4a79ed5b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<section id="question-13.-how-might-hierarchical-clustering-be-utilized-for-exploratory-data-analysis-in-cases-where-cluster-boundaries-are-not-well-defined" class="level2">
<h2 class="anchored" data-anchor-id="question-13.-how-might-hierarchical-clustering-be-utilized-for-exploratory-data-analysis-in-cases-where-cluster-boundaries-are-not-well-defined">Question: 13. How might hierarchical clustering be utilized for exploratory data analysis in cases where cluster boundaries are not well-defined?</h2>
<p><strong>Best Answer</strong></p>
<p>Hierarchical clustering is a powerful technique for exploratory data analysis (EDA), particularly when cluster boundaries are not well-defined. Unlike partitioning methods like k-means, which require a pre-specified number of clusters and often struggle with non-spherical or overlapping clusters, hierarchical clustering builds a hierarchy of clusters without assuming a particular structure upfront. This makes it extremely useful for uncovering potentially hidden structures and relationships within data.</p>
<p>Here’s a detailed explanation of how hierarchical clustering can be utilized for EDA in cases where cluster boundaries are ambiguous:</p>
<ul>
<li><p><strong>Dendrogram Visualization:</strong> The primary output of hierarchical clustering is a dendrogram, a tree-like diagram that illustrates the merging of clusters at different levels of similarity. The x-axis represents the data points, and the y-axis represents the distance or dissimilarity between clusters. The height at which two clusters merge indicates their dissimilarity – higher mergers indicate less similar clusters. By examining the dendrogram, we can:</p>
<ul>
<li><strong>Identify potential clusters:</strong> Even if clear boundaries are lacking, the dendrogram can reveal suggestions of possible clusters. We look for branches that merge at relatively low heights, indicating groups of points that are more similar to each other than to other points in the dataset.</li>
<li><strong>Understand nested relationships:</strong> Hierarchical clustering naturally reveals nested cluster structures. A large cluster might be composed of several smaller, tighter clusters. This is extremely useful for understanding the relationships between data points at multiple levels of granularity.</li>
<li><strong>Assess cluster cohesiveness:</strong> The “tightness” of a cluster can be visually assessed based on the height of the merger in the dendrogram. Tighter clusters merge earlier (lower height). Regions of the dendrogram with long, uninterrupted vertical lines suggest that the points within those regions are relatively dissimilar.</li>
</ul></li>
<li><p><strong>Linkage Methods and Distance Metrics:</strong> The choice of linkage method and distance metric significantly impacts the resulting dendrogram and cluster structure.</p>
<ul>
<li><strong>Linkage Methods:</strong> Different linkage methods define how the distance between two clusters is calculated. Common methods include:
<ul>
<li><strong>Single Linkage (Nearest Neighbor):</strong> The distance between two clusters is the shortest distance between any two points in the clusters. Formula: <span class="math display">\[d(C_1, C_2) = \min_{x \in C_1, y \in C_2} d(x, y)\]</span> where <span class="math inline">\(d(x,y)\)</span> is the distance between points x and y.</li>
<li><strong>Complete Linkage (Farthest Neighbor):</strong> The distance between two clusters is the longest distance between any two points in the clusters. Formula: <span class="math display">\[d(C_1, C_2) = \max_{x \in C_1, y \in C_2} d(x, y)\]</span></li>
<li><strong>Average Linkage:</strong> The distance between two clusters is the average distance between all pairs of points, one from each cluster. Formula: <span class="math display">\[d(C_1, C_2) = \frac{1}{|C_1||C_2|} \sum_{x \in C_1} \sum_{y \in C_2} d(x, y)\]</span></li>
<li><strong>Ward’s Linkage:</strong> Minimizes the increase in the total within-cluster variance after merging. This method tends to produce more compact clusters. The objective is to minimize the increase in the error sum of squares (ESS).</li>
</ul></li>
<li><strong>Distance Metrics:</strong> Common distance metrics include:
<ul>
<li><strong>Euclidean Distance:</strong> The straight-line distance between two points. Formula: <span class="math display">\[d(x, y) = \sqrt{\sum_{i=1}^{n} (x_i - y_i)^2}\]</span></li>
<li><strong>Manhattan Distance:</strong> The sum of the absolute differences of their coordinates. Formula: <span class="math display">\[d(x, y) = \sum_{i=1}^{n} |x_i - y_i|\]</span></li>
<li><strong>Cosine Similarity:</strong> Measures the cosine of the angle between two vectors, often used for text data. Formula: <span class="math display">\[similarity(x, y) = \frac{x \cdot y}{||x|| \cdot ||y||}\]</span></li>
</ul></li>
</ul>
<p>The choice of linkage and distance can drastically alter the resulting clusters. Experimenting with different combinations is crucial in EDA to uncover potentially meaningful structures. For example, single linkage can reveal elongated, chain-like clusters, while complete linkage tends to produce more compact clusters.</p></li>
<li><p><strong>Cutting the Dendrogram:</strong> To obtain discrete clusters from the hierarchical structure, we need to “cut” the dendrogram at a certain height. This determines the number of clusters. In cases where boundaries are not clear, this decision can be subjective. Several approaches can be used to guide this selection:</p>
<ul>
<li><strong>Visual inspection of the dendrogram:</strong> Look for significant “jumps” in the merging heights. A large jump suggests that merging the clusters at that level would result in a significant loss of within-cluster similarity.</li>
<li><strong>Cophenetic Correlation Coefficient:</strong> This measures how faithfully the dendrogram preserves the pairwise distances between the original data points. A higher cophenetic correlation indicates a better representation of the original data structure. We might choose a cutting point that maximizes this coefficient.</li>
<li><strong>External Validation:</strong> Compare the resulting clusters with external information or labels, if available. This can help assess whether the clusters are meaningful in the context of the problem.</li>
</ul></li>
<li><p><strong>Limitations and Considerations:</strong></p>
<ul>
<li><strong>Sensitivity to Noise and Outliers:</strong> Hierarchical clustering can be sensitive to noise and outliers, which can distort the dendrogram and affect the resulting cluster structure. Preprocessing steps like outlier removal might be necessary.</li>
<li><strong>Computational Complexity:</strong> The time complexity of hierarchical clustering is typically <span class="math inline">\(O(n^3)\)</span> for naive implementations and can be reduced to <span class="math inline">\(O(n^2 log(n))\)</span> using efficient algorithms. This can be a limitation for very large datasets.</li>
<li><strong>Subjectivity in Cutting:</strong> As mentioned before, the decision of where to cut the dendrogram can be subjective. This requires careful consideration and possibly the use of validation techniques or domain expertise.</li>
</ul></li>
<li><p><strong>Integration with Other Techniques:</strong> Hierarchical clustering is often used in conjunction with other EDA techniques to gain a more comprehensive understanding of the data:</p>
<ul>
<li><strong>Dimensionality Reduction:</strong> Techniques like PCA or t-SNE can be used to reduce the dimensionality of the data before applying hierarchical clustering. This can improve performance and reveal clearer cluster structures in lower-dimensional space.</li>
<li><strong>Visualizations:</strong> Scatter plots, box plots, and other visualizations can be used to examine the characteristics of the clusters identified by hierarchical clustering.</li>
<li><strong>Statistical Tests:</strong> Statistical tests can be used to assess the significance of the differences between the clusters.</li>
</ul></li>
</ul>
<p>In summary, hierarchical clustering is an invaluable tool for exploratory data analysis, particularly when cluster boundaries are not well-defined. By leveraging the dendrogram visualization, experimenting with different linkage methods and distance metrics, and integrating with other EDA techniques, we can uncover hidden structures and gain valuable insights into the data. The ultimate goal is to iteratively refine our understanding of the data and generate hypotheses that can be further investigated.</p>
<p><strong>How to Narrate</strong></p>
<p>Here’s a step-by-step guide on how to articulate this answer in an interview:</p>
<ol type="1">
<li><strong>Start with a High-Level Overview:</strong>
<ul>
<li>“Hierarchical clustering is especially helpful in exploratory data analysis when clear cluster boundaries are absent because, unlike methods like k-means, it doesn’t require specifying the number of clusters beforehand and it reveals the data’s inherent hierarchical structure.”</li>
</ul></li>
<li><strong>Explain the Dendrogram (Visual Aid):</strong>
<ul>
<li>“The core output is a dendrogram. Think of it as a tree where each leaf is a data point, and the branches show how clusters merge. The height of the merge indicates dissimilarity.”</li>
<li>“I’d use a whiteboard or ask if there’s a way to visualize a simple dendrogram here. Visually, a good cluster will merge early (lower height) on the dendrogram.”</li>
<li>“Even without obvious separations, the dendrogram can suggest potential clusters, reveal nested relationships, and visually show the cohesiveness of data groupings.”</li>
</ul></li>
<li><strong>Discuss Linkage Methods &amp; Distance Metrics (Technical Depth):</strong>
<ul>
<li>“The linkage method determines how the ‘distance’ between clusters is calculated. For example, single linkage uses the shortest distance between points in clusters, while complete linkage uses the longest. Ward’s linkage minimizes the increase in variance within clusters after merging.”</li>
<li>“Distance metrics also matter. Euclidean distance is common, but Manhattan distance or cosine similarity might be better depending on the data. For instance, cosine similarity is excellent for text data.”</li>
<li>“I’d mention the formulas <em>only</em> if asked for specifics, emphasizing their purpose: Single Linkage <span class="math inline">\(d(C_1, C_2) = \min_{x \in C_1, y \in C_2} d(x, y)\)</span>, Complete Linkage <span class="math inline">\(d(C_1, C_2) = \max_{x \in C_1, y \in C_2} d(x, y)\)</span>, or Cosine Similarity <span class="math inline">\(similarity(x, y) = \frac{x \cdot y}{||x|| \cdot ||y||}\)</span>. Avoid diving too deep unless prompted.</li>
</ul></li>
<li><strong>Explain Cutting the Dendrogram (Decision-Making):</strong>
<ul>
<li>“To get concrete clusters, you ‘cut’ the dendrogram at a certain height. The question is <em>where</em> to cut when boundaries are vague. Visual inspection helps—look for big ‘jumps’ in merging heights, as these indicate a significant loss of within-cluster similarity if we cut there.”</li>
<li>“Other approaches include maximizing the cophenetic correlation coefficient or using external validation if external data/labels exist.”</li>
</ul></li>
<li><strong>Acknowledge Limitations (Critical Thinking):</strong>
<ul>
<li>“Hierarchical clustering isn’t perfect. It can be sensitive to noise and outliers, which can distort the results. Also, it can be computationally expensive, especially for large datasets. The subjective choice of where to cut the dendrogram is another challenge.”</li>
</ul></li>
<li><strong>Highlight Integration with Other Techniques (Holistic View):</strong>
<ul>
<li>“Hierarchical clustering works best when combined with other EDA tools. For example, dimensionality reduction like PCA can simplify the data before clustering. Visualizations like scatter plots can then help understand the resulting clusters.”</li>
</ul></li>
<li><strong>Conclude with a Summary:</strong>
<ul>
<li>“So, in summary, hierarchical clustering is a versatile method for exploring data, especially when you’re not sure what cluster structure to expect. It provides insights through the dendrogram and becomes even more powerful when used alongside other data analysis techniques.”</li>
</ul></li>
</ol>
<p><strong>Communication Tips:</strong></p>
<ul>
<li><strong>Pace yourself:</strong> Don’t rush through the explanation. Allow time for the interviewer to process the information.</li>
<li><strong>Use visuals:</strong> If possible, use a whiteboard or ask if there’s a way to share your screen to draw a simple dendrogram.</li>
<li><strong>Check for understanding:</strong> Pause periodically and ask if the interviewer has any questions.</li>
<li><strong>Be flexible:</strong> Adjust your level of detail based on the interviewer’s background and interest. If they seem particularly interested in a specific aspect (e.g., linkage methods), delve into it further.</li>
<li><strong>Maintain eye contact:</strong> Engage with the interviewer and show enthusiasm for the topic.</li>
<li><strong>Be confident:</strong> You’ve prepared thoroughly, so trust your knowledge and present your answer with confidence.</li>
</ul>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>