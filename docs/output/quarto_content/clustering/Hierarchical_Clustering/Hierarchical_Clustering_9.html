<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.41">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>hierarchical_clustering_9</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../../">
<script src="../../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../site_libs/quarto-html/quarto-syntax-highlighting-48ffa3e5b9d089919c6712c39e5b00f2.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../site_libs/bootstrap/bootstrap-a37d0bf9d509de95c1ba4621f20add8c.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<section id="question-10.-can-you-describe-a-real-world-scenario-where-hierarchical-clustering-offers-more-nuanced-insights-compared-to-partition-based-methods-like-k-means" class="level2">
<h2 class="anchored" data-anchor-id="question-10.-can-you-describe-a-real-world-scenario-where-hierarchical-clustering-offers-more-nuanced-insights-compared-to-partition-based-methods-like-k-means">Question: 10. Can you describe a real-world scenario where hierarchical clustering offers more nuanced insights compared to partition-based methods like K-Means?</h2>
<p><strong>Best Answer</strong></p>
<p>Hierarchical clustering and partition-based methods, like K-Means, are both unsupervised machine learning techniques used to group similar data points together. However, they differ significantly in their approach and the type of insights they provide. Hierarchical clustering builds a hierarchy of clusters, while K-Means aims to partition the data into a predefined number of non-overlapping clusters. The choice between them depends on the data and the specific goals of the analysis.</p>
<p>A real-world scenario where hierarchical clustering offers more nuanced insights is in <strong>analyzing customer segmentation for a luxury brand with a wide range of products and services.</strong></p>
<p>Here’s why hierarchical clustering is advantageous in this scenario:</p>
<ol type="1">
<li><p><strong>Understanding Nested Customer Segments:</strong></p>
<ul>
<li><p>Luxury brands often have diverse customer bases, ranging from occasional buyers of smaller items to high-net-worth individuals who purchase exclusive, high-value products and services. These segments can be thought of as being nested within each other. For instance, a large group of “entry-level luxury buyers” might purchase items under $500. Within this segment, a smaller subset might be “frequent entry-level buyers.” K-means, with its flat partitioning, might struggle to capture these nested relationships effectively.</p></li>
<li><p>Hierarchical clustering, especially agglomerative (bottom-up) clustering, constructs a dendrogram which visually represents these nested relationships. Each level of the hierarchy shows a different granularity of segmentation. This allows the luxury brand to see how customer segments are related and how they evolve.</p></li>
</ul></li>
<li><p><strong>Adaptive Segmentation Based on Business Needs:</strong></p>
<ul>
<li>With hierarchical clustering, the brand can choose the number of clusters <em>after</em> observing the dendrogram, allowing for more flexibility. If the business wants a high-level overview, they can “cut” the dendrogram higher up. If they need more granular segments for targeted marketing, they can cut lower down. K-Means requires the number of clusters, <span class="math inline">\(k\)</span>, to be specified <em>before</em> the analysis. Choosing the wrong <span class="math inline">\(k\)</span> can lead to suboptimal or misleading results. Methods exist to estimate the optimal <span class="math inline">\(k\)</span>, such as the elbow method (plotting variance explained vs.&nbsp;<span class="math inline">\(k\)</span>), but these methods are not always accurate or applicable.</li>
</ul></li>
<li><p><strong>Data-Driven Decision Making for Personalized Marketing:</strong></p>
<ul>
<li><p>Consider a luxury fashion brand. Some customers might buy accessories, others might focus on ready-to-wear clothing, and still others might engage with bespoke tailoring services. Hierarchical clustering can reveal these distinct patterns. A dendrogram might show a branch dedicated to “bespoke tailoring clients,” which could be further subdivided into “formal wear clients” and “casual wear clients.” K-Means would likely force these diverse behaviors into a limited number of clusters, potentially obscuring these critical nuances.</p></li>
<li><p>The brand can then tailor its marketing strategies based on these hierarchical relationships. For instance, they might offer entry-level buyers exclusive deals on their next purchase to encourage them to move up the hierarchy. Bespoke tailoring clients might receive invitations to private fashion shows or previews of new collections.</p></li>
</ul></li>
<li><p><strong>Greater Interpretability</strong>:</p>
<ul>
<li><p>The dendrogram provides a visual representation of how the clusters are formed, making it easier to interpret the relationships between the different customer segments. This is especially useful for stakeholders who are not data scientists but need to understand the customer base.</p></li>
<li><p>With K-Means, interpreting the clusters can be more challenging, especially in high-dimensional data. Each cluster is represented by its centroid, which might not be easily interpretable in terms of the original features.</p></li>
</ul></li>
<li><p><strong>Mathematical Justification</strong>:</p>
<ul>
<li><p>Hierarchical clustering builds a distance matrix <span class="math inline">\(D\)</span> representing the pairwise distances between all data points. The algorithm iteratively merges the closest clusters until all data points belong to a single cluster.</p></li>
<li><p>The choice of linkage criterion (e.g., single, complete, average, Ward) affects how the distance between clusters is calculated. Ward’s linkage, for example, minimizes the variance within each cluster, while complete linkage minimizes the maximum distance between points in different clusters. The mathematical formulation of Ward’s linkage can be represented as: <span class="math display">\[ d(A, B) = \sqrt{\frac{2n_A n_B}{n_A + n_B}} ||\bar{x}_A - \bar{x}_B||_2 \]</span> where <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are the clusters being merged, <span class="math inline">\(n_A\)</span> and <span class="math inline">\(n_B\)</span> are the number of points in each cluster, and <span class="math inline">\(\bar{x}_A\)</span> and <span class="math inline">\(\bar{x}_B\)</span> are the centroids of the clusters. This is mathematically grounded in minimizing within-cluster variance which makes it appropriate when the underlying assumption is variance reduction with each merge.</p></li>
<li><p>In contrast, K-Means aims to minimize the within-cluster sum of squares (WCSS): <span class="math display">\[ \underset{S}{\arg\min} \sum_{i=1}^{k} \sum_{x \in S_i} ||x - \mu_i||^2 \]</span> where <span class="math inline">\(S_i\)</span> represents the <span class="math inline">\(i\)</span>-th cluster, <span class="math inline">\(x\)</span> are the data points within the cluster, and <span class="math inline">\(\mu_i\)</span> is the centroid of the cluster. The objective function directly minimizes distance to the centroids, leading to spherical clusters in high dimensional spaces.</p></li>
<li><p>The key difference is that hierarchical clustering doesn’t optimize a global objective function like WCSS, instead relying on pairwise distances and linkage criteria, making it more adaptable to complex, non-spherical cluster shapes often found in real-world customer data.</p></li>
</ul></li>
</ol>
<p>In summary, while K-Means can be useful for quick and simple segmentation, hierarchical clustering offers a more nuanced and interpretable view of customer segments for a luxury brand, allowing for more targeted and effective marketing strategies. The dendrogram provides a valuable visual tool for understanding the relationships between different customer segments and adapting marketing strategies accordingly.</p>
<p><strong>How to Narrate</strong></p>
<p>Here’s a step-by-step guide on how to articulate this answer in an interview:</p>
<ol type="1">
<li><p><strong>Start with the basics</strong>: “Both hierarchical clustering and K-Means are unsupervised learning methods for grouping similar data points, but they differ in their approach. Hierarchical clustering builds a hierarchy of clusters, while K-Means partitions data into a predefined number of clusters.”</p></li>
<li><p><strong>Introduce the Scenario</strong>: “A great example of where hierarchical clustering excels is in customer segmentation for a luxury brand. These brands often have diverse customer bases with nested relationships.”</p></li>
<li><p><strong>Explain the Nested Segments</strong>: “Luxury brands can have customers ranging from those buying small, occasional items to high-net-worth individuals. Hierarchical clustering can capture these nested relationships – like a group of ‘entry-level buyers’ who spend under $500, and within that, a group of ‘frequent entry-level buyers.’”</p></li>
<li><p><strong>Highlight the Advantages</strong>: “Hierarchical clustering allows you to choose the number of clusters <em>after</em> observing the dendrogram, providing flexibility. K-Means requires you to specify the number beforehand, and choosing the wrong number can be problematic. The dendrogram also provides a visual representation of how the clusters are formed making it easier to interpret the relationships.”</p></li>
<li><p><strong>Offer a Concrete Example</strong>: “Imagine a luxury fashion brand: some customers buy accessories, others clothing, and some bespoke tailoring. Hierarchical clustering can reveal these distinct patterns, which K-Means might obscure.”</p></li>
<li><p><strong>Explain Marketing Applications</strong>: “The brand can then tailor marketing strategies based on the hierarchy. Entry-level buyers might receive exclusive deals to encourage upgrades, while bespoke clients get invited to fashion shows.”</p></li>
<li><p><strong>Introduce Math (Optional, gauge interviewer’s interest)</strong>: “Mathematically, hierarchical clustering builds a distance matrix and iteratively merges clusters based on a linkage criterion, such as Ward’s linkage, which aims to minimize within-cluster variance. K-Means, on the other hand, minimizes the within-cluster sum of squares. Therefore, hierarchical clustering is more adaptable to complex shapes.” Be prepared to explain the equations in detail if asked, but start with a high-level explanation and offer to delve deeper.</p></li>
<li><p><strong>Summarize</strong>: “In essence, while K-Means is useful for quick segmentation, hierarchical clustering offers a more nuanced and interpretable view for a luxury brand, enabling more effective marketing strategies.”</p></li>
</ol>
<p><strong>Communication Tips:</strong></p>
<ul>
<li><strong>Pace yourself:</strong> Don’t rush through the explanation. Give the interviewer time to process the information.</li>
<li><strong>Use visual aids mentally</strong>: When discussing the dendrogram, visualize it in your mind and describe what it would look like.</li>
<li><strong>Check for understanding</strong>: Pause periodically and ask if the interviewer has any questions.</li>
<li><strong>Don’t be afraid to simplify</strong>: If you sense that the interviewer is not familiar with the technical details, simplify the explanation.</li>
<li><strong>Be enthusiastic:</strong> Show your passion for the subject matter.</li>
<li><strong>Be structured</strong>: Provide a logical structure to your answer to make it easy to follow.</li>
<li><strong>Mathematical Depth</strong>: The mathematical portion is to demonstrate expertise. Only introduce it if it flows naturally and the interviewer seems technically inclined. Be ready to explain the components if asked. Don’t just state equations; explain their purpose within the context of the algorithms.</li>
</ul>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>