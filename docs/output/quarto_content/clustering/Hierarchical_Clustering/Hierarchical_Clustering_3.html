<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>hierarchical_clustering_3</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../../">
<script src="../../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../site_libs/bootstrap/bootstrap-5d3fd86dc4559d58e199c8cc4a79ed5b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<section id="question-4.-how-is-the-dendrogram-used-in-hierarchical-clustering-and-what-strategies-can-be-applied-to-decide-on-the-optimal-number-of-clusters" class="level2">
<h2 class="anchored" data-anchor-id="question-4.-how-is-the-dendrogram-used-in-hierarchical-clustering-and-what-strategies-can-be-applied-to-decide-on-the-optimal-number-of-clusters">Question: 4. How is the dendrogram used in hierarchical clustering, and what strategies can be applied to decide on the optimal number of clusters?</h2>
<p><strong>Best Answer</strong></p>
<p>Hierarchical clustering is a class of clustering algorithms that builds a hierarchy of clusters. This hierarchy can be visualized as a tree-like diagram called a dendrogram. Understanding the dendrogram is crucial for interpreting the results of hierarchical clustering and, importantly, deciding on the appropriate number of clusters for a given dataset.</p>
<p><strong>Dendrograms: Visualizing Hierarchical Clustering</strong></p>
<p>A dendrogram illustrates how data points are successively grouped into clusters at different levels of similarity. The vertical axis of the dendrogram represents the distance or dissimilarity between clusters, while the horizontal axis represents the data points or clusters themselves.</p>
<ul>
<li><strong>Leaves:</strong> The leaves of the dendrogram represent individual data points.</li>
<li><strong>Branches:</strong> The branches connect data points or clusters, indicating their fusion into larger clusters. The height of the branch represents the distance (or dissimilarity) between the two clusters being merged. Clusters that are merged lower in the dendrogram are more similar than those merged higher up.</li>
<li><strong>Root:</strong> The root of the dendrogram represents the single cluster containing all data points.</li>
</ul>
<p><strong>Interpreting the Dendrogram:</strong></p>
<p>The key to using a dendrogram lies in understanding that each horizontal “cut” across the dendrogram represents a specific clustering solution. The number of vertical lines intersected by the cut corresponds to the number of clusters. The height at which the cut is made dictates the dissimilarity threshold for cluster membership. Lower cuts yield more clusters, while higher cuts yield fewer clusters.</p>
<p><strong>Strategies for Determining the Optimal Number of Clusters</strong></p>
<p>Choosing the optimal number of clusters from a dendrogram is often subjective, but several strategies can aid in the decision:</p>
<ol type="1">
<li><p><strong>Visual Inspection:</strong></p>
<ul>
<li>The most straightforward method is to visually inspect the dendrogram and look for a “natural” or significant gap in the branch lengths. A large vertical distance suggests that the clusters being merged are dissimilar, indicating a potentially good cut-off point.</li>
<li>Look for the longest vertical line which is not intersected by any horizontal line. The number of such lines are then the optimal number of clusters.</li>
<li><strong>Limitations:</strong> This method is subjective and can be challenging for complex datasets with less clear structure.</li>
</ul></li>
<li><p><strong>Inconsistency Coefficient (or Cophenetic Distance):</strong></p>
<ul>
<li><p>The inconsistency coefficient quantifies how different the height of a link in the dendrogram is compared to the average height of other links at the same level of the hierarchy. A higher inconsistency coefficient suggests a less consistent merge, implying a potential cluster boundary.</p></li>
<li><p>The inconsistency coefficient for a link <span class="math inline">\(l\)</span> is calculated as:</p>
<p><span class="math display">\[
\text{Inconsistency}(l) = \frac{h(l) - \text{mean}(h_{\text{descendants}})}{\text{std}(h_{\text{descendants}})}
\]</span></p>
<p>where:</p>
<ul>
<li><span class="math inline">\(h(l)\)</span> is the height of the link <span class="math inline">\(l\)</span></li>
<li><span class="math inline">\(h_{\text{descendants}}\)</span> is the set of heights of descendant links of link <span class="math inline">\(l\)</span></li>
<li>mean<span class="math inline">\((h_{\text{descendants}})\)</span> is the mean of these heights</li>
<li>std<span class="math inline">\((h_{\text{descendants}})\)</span> is the standard deviation of these heights.</li>
</ul></li>
<li><p>A threshold can be set for the inconsistency coefficient (e.g., 0.8 or 1.0), and clusters are formed by cutting the dendrogram at the level where the inconsistency exceeds this threshold.</p></li>
<li><p><strong>Implementation Notes:</strong> Most hierarchical clustering implementations (e.g., in SciPy) provide functions to calculate inconsistency coefficients.</p></li>
</ul></li>
<li><p><strong>Elbow Method (applied to hierarchical clustering metrics):</strong></p>
<ul>
<li><p>Although primarily associated with K-means, the elbow method can be adapted to hierarchical clustering. After performing hierarchical clustering and obtaining different clustering solutions (corresponding to different cuts on the dendrogram), a metric like the average silhouette score or the Calinski-Harabasz index can be computed for each solution.</p></li>
<li><p><span class="math display">\[
\text{Silhouette Score} = \frac{1}{N} \sum_{i=1}^{N} \frac{b_i - a_i}{max(a_i, b_i)}
\]</span></p>
<p>where:</p>
<ul>
<li><span class="math inline">\(a_i\)</span> is the average distance of the <span class="math inline">\(i\)</span>-th point to the other points in the same cluster.</li>
<li><span class="math inline">\(b_i\)</span> is the average distance of the <span class="math inline">\(i\)</span>-th point to the points in the nearest other cluster.</li>
<li><span class="math inline">\(N\)</span> is the total number of samples.</li>
</ul></li>
<li><p><span class="math display">\[
\text{Calinski-Harabasz Index} = \frac{SS_B / (k-1)}{SS_W / (N-k)}
\]</span></p>
<p>where:</p>
<ul>
<li><span class="math inline">\(SS_B\)</span> is the between-cluster sum of squares.</li>
<li><span class="math inline">\(SS_W\)</span> is the within-cluster sum of squares.</li>
<li><span class="math inline">\(k\)</span> is the number of clusters.</li>
<li><span class="math inline">\(N\)</span> is the number of samples.</li>
</ul></li>
<li><p>The number of clusters corresponding to the “elbow” in the plot of the metric vs.&nbsp;the number of clusters is then selected. The elbow represents the point where adding more clusters yields diminishing returns in terms of the metric’s improvement.</p></li>
<li><p><strong>Considerations:</strong> The elbow might not always be sharply defined, requiring subjective judgment.</p></li>
</ul></li>
<li><p><strong>Statistical Tests &amp; Information Criteria (Advanced):</strong></p>
<ul>
<li><p>More sophisticated approaches involve statistical tests to assess the significance of cluster merges. These tests often compare the within-cluster variance to the between-cluster variance at different levels of the hierarchy.</p></li>
<li><p>Information criteria, such as the Bayesian Information Criterion (BIC) or the Akaike Information Criterion (AIC), can also be adapted. These criteria balance the goodness of fit of the clustering solution with the complexity (number of clusters). The clustering solution with the lowest BIC or AIC is typically preferred. The BIC is given by: <span class="math display">\[
BIC = -2 \cdot \text{Log-Likelihood} + k \cdot log(n)
\]</span> where <span class="math inline">\(k\)</span> is the number of parameters in the model (related to the number of clusters) and <span class="math inline">\(n\)</span> is the number of data points.</p></li>
<li><p><strong>Challenges:</strong> These methods often require stronger assumptions about the data distribution and can be computationally expensive.</p></li>
</ul></li>
</ol>
<p><strong>Real-World Considerations:</strong></p>
<ul>
<li><strong>Domain Knowledge:</strong> Ultimately, the choice of the number of clusters should be guided by domain knowledge and the goals of the analysis. A clustering solution that aligns with existing knowledge or provides actionable insights is more valuable than one chosen solely based on statistical criteria.</li>
<li><strong>Sensitivity to Linkage Method:</strong> The structure of the dendrogram and the resulting clusters are highly sensitive to the choice of linkage method (e.g., single, complete, average, Ward). Experimenting with different linkage methods is crucial to find a stable and meaningful clustering solution. Ward linkage minimizes the variance within each cluster.</li>
<li><strong>Computational Cost:</strong> Hierarchical clustering can be computationally expensive, especially for large datasets. Approximations and optimizations may be necessary in such cases.</li>
<li><strong>Data Preprocessing:</strong> The scale of the data can have a big effect. Standardization or Normalization might be necessary as the data scales can influence the distance measure used in Hierarchical Clustering.</li>
<li><strong>Scalability</strong>: Hierarchical clustering can be computationally expensive, especially for large datasets, with time complexity ranging from <span class="math inline">\(O(n^2)\)</span> to <span class="math inline">\(O(n^3)\)</span> depending on the specific implementation and linkage method.</li>
<li><strong>Interpretability</strong>: Dendrograms provide a clear visualization of the clustering hierarchy, aiding in the interpretation of the relationships between clusters and individual data points.</li>
<li><strong>Assumptions</strong>: Hierarchical clustering makes no strong assumptions about the shape or distribution of the clusters, making it versatile for various types of data. However, the choice of distance metric and linkage method can significantly impact the clustering results.</li>
</ul>
<p>In summary, dendrograms are essential tools for visualizing and interpreting hierarchical clustering. Determining the optimal number of clusters involves a combination of visual inspection, statistical measures, and, most importantly, domain knowledge.</p>
<p><strong>How to Narrate</strong></p>
<p>Here’s a guide on how to present this information in an interview:</p>
<ol type="1">
<li><strong>Start with the Basics (Dendrogram Definition):</strong>
<ul>
<li>“Hierarchical clustering produces a hierarchy of clusters, which we can visualize using a dendrogram. Think of it as a tree where each leaf is a data point, and branches show how clusters merge.”</li>
<li>“The height of the branches represents the distance between the clusters being merged. Shorter branches indicate more similar clusters.”</li>
</ul></li>
<li><strong>Explain Dendrogram Interpretation (Walk Through Visual Elements):</strong>
<ul>
<li>“Imagine drawing a horizontal line across the dendrogram. The number of vertical lines it intersects tells you the number of clusters you’d get at that level of dissimilarity.”</li>
<li>“So, a lower cut means more clusters, and a higher cut means fewer, more general clusters.”</li>
</ul></li>
<li><strong>Introduce Strategies (Overview):</strong>
<ul>
<li>“Deciding where to ‘cut’ the dendrogram is how we choose the number of clusters. There are several strategies, ranging from simple visual inspection to more complex statistical methods.”</li>
</ul></li>
<li><strong>Describe Visual Inspection (Keep it Intuitive):</strong>
<ul>
<li>“The most intuitive approach is simply looking for the largest ‘gap’ in the dendrogram – a big jump in branch length suggests we’re merging dissimilar clusters. But, this can be subjective.”</li>
</ul></li>
<li><strong>Explain Inconsistency Coefficient (Explain Formula Concisely):</strong>
<ul>
<li>“The inconsistency coefficient is more objective. It measures how different a merge is compared to other merges at similar levels. We can set a threshold, and cut the dendrogram where the inconsistency exceeds that threshold.”</li>
<li>“Mathematically, it’s the height of a link minus the mean height of its descendants, all divided by the standard deviation of those descendants. A higher value indicates a less consistent merge.” <em>Avoid writing out the full formula unless asked. Instead say what the components represent.</em></li>
</ul></li>
<li><strong>Mention Elbow Method (Connect to K-Means):</strong>
<ul>
<li>“While often used with K-means, the elbow method can be adapted. We calculate metrics like the Silhouette score for different numbers of clusters (derived from different dendrogram cuts) and look for the ‘elbow’ in the plot. The elbow number of clusters is where the score’s improvement diminishes.”</li>
</ul></li>
<li><strong>Briefly Discuss Statistical Tests/Information Criteria (Acknowledge Complexity):</strong>
<ul>
<li>“More advanced methods involve statistical tests or information criteria like BIC, which balance the goodness of fit with the complexity of the clustering solution. However, these can be computationally intensive and require stronger assumptions about the data.”</li>
</ul></li>
<li><strong>Emphasize Domain Knowledge (Highlight Practical Relevance):</strong>
<ul>
<li>“Ultimately, the best number of clusters depends on the specific problem and domain knowledge. We want a solution that’s not only statistically sound but also meaningful and actionable.”</li>
</ul></li>
<li><strong>Acknowledge Sensitivity and Limitations (Show Awareness):</strong>
<ul>
<li>“It’s important to remember that the dendrogram and the resulting clusters are sensitive to the linkage method used. We should experiment with different methods. Also, hierarchical clustering can be computationally expensive, so we might need to use approximations for large datasets. And it is important to consider the data scaling before performing hierarchical clustering.”</li>
</ul></li>
</ol>
<p><strong>Communication Tips:</strong></p>
<ul>
<li><strong>Pace yourself:</strong> Don’t rush through the explanation, especially when discussing the inconsistency coefficient or other mathematical concepts.</li>
<li><strong>Use analogies:</strong> Relating the dendrogram to a family tree or organizational chart can make it more relatable.</li>
<li><strong>Check for understanding:</strong> Pause periodically and ask the interviewer if they have any questions.</li>
<li><strong>Be honest about limitations:</strong> Acknowledge the subjective nature of choosing the number of clusters and the limitations of each method.</li>
<li><strong>Tailor to the interviewer:</strong> Adjust the level of detail based on the interviewer’s background and the flow of the conversation. If they seem particularly interested in a specific method, delve deeper into the details.</li>
<li><strong>If you use a specific library such as SciPy, mention it. It shows practical knowledge.</strong></li>
</ul>
<p>By following these guidelines, you can effectively demonstrate your understanding of dendrograms and hierarchical clustering, while also showcasing your communication skills and senior-level expertise.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>