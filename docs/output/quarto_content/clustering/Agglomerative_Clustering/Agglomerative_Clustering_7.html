<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.41">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>agglomerative_clustering_7</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../../">
<script src="../../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../site_libs/quarto-html/quarto-syntax-highlighting-48ffa3e5b9d089919c6712c39e5b00f2.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../site_libs/bootstrap/bootstrap-a37d0bf9d509de95c1ba4621f20add8c.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<section id="question-8.-how-would-you-implement-agglomerative-clustering-in-a-distributed-computing-environment-to-handle-scalability-and-what-special-considerations-would-you-need-to-account-for" class="level2">
<h2 class="anchored" data-anchor-id="question-8.-how-would-you-implement-agglomerative-clustering-in-a-distributed-computing-environment-to-handle-scalability-and-what-special-considerations-would-you-need-to-account-for">Question: 8. How would you implement agglomerative clustering in a distributed computing environment to handle scalability, and what special considerations would you need to account for?</h2>
<p><strong>Best Answer</strong></p>
<p>Agglomerative clustering, also known as hierarchical agglomerative clustering (HAC), is a bottom-up clustering approach where each data point initially starts as its own cluster, and then iteratively merges the closest pairs of clusters until a single cluster is formed or a stopping criterion is met. While effective for smaller datasets, its computational complexity of <span class="math inline">\(O(n^3)\)</span> in the naive implementation or <span class="math inline">\(O(n^2 log(n))\)</span> with optimized approaches like using a heap, makes it challenging to scale to large datasets in a single-machine environment. Distributed computing offers a way to address this scalability issue. Here’s how I would approach implementing agglomerative clustering in a distributed setting, along with the special considerations:</p>
<section id="parallelization-strategies" class="level3">
<h3 class="anchored" data-anchor-id="parallelization-strategies">1. Parallelization Strategies</h3>
<p>Several strategies can be employed to parallelize agglomerative clustering:</p>
<ul>
<li><strong>Data Partitioning and Local Clustering:</strong> The dataset is divided into multiple partitions, each handled by a different compute node. Each node performs agglomerative clustering on its local data, resulting in a set of local clusters. The key idea is to reduce the size of the problem each node must solve and thus speed up the overall process.</li>
<li><strong>Distributed Merge Step:</strong> After the local clustering, a distributed merge step combines the local clusters into a global clustering. This step is the most challenging and requires careful consideration of communication costs.</li>
</ul>
</section>
<section id="algorithms-and-frameworks" class="level3">
<h3 class="anchored" data-anchor-id="algorithms-and-frameworks">2. Algorithms and Frameworks</h3>
<ul>
<li><strong>Spark:</strong> Apache Spark is well-suited for distributed data processing. We can leverage Spark’s resilient distributed datasets (RDDs) or DataFrames to represent and manipulate the data.</li>
<li><strong>Dask:</strong> Dask offers parallel execution using Python and can handle out-of-core datasets well. It’s a good alternative if the workflow is primarily Python-based.</li>
</ul>
</section>
<section id="implementation-steps-in-spark" class="level3">
<h3 class="anchored" data-anchor-id="implementation-steps-in-spark">3. Implementation Steps in Spark</h3>
<p>Here’s a conceptual outline of how to implement distributed agglomerative clustering using Spark:</p>
<ol type="1">
<li><p><strong>Data Loading and Partitioning:</strong> Load the data into a Spark RDD/DataFrame and partition it across the cluster nodes. The number of partitions should be chosen to balance the workload across nodes.</p></li>
<li><p><strong>Local Clustering:</strong> On each partition, perform agglomerative clustering using a standard single-machine algorithm (e.g., using <code>scipy.cluster.hierarchy</code> in Python). The result will be a set of local cluster representatives for each partition.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> local_clustering(partition):</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    data <span class="op">=</span> <span class="bu">list</span>(partition)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> data:</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> [] <span class="co"># Handle empty partition</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Perform agglomerative clustering using scipy</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="im">from</span> scipy.cluster.hierarchy <span class="im">import</span> linkage, fcluster</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    X <span class="op">=</span> np.array([x[<span class="dv">1</span>] <span class="cf">for</span> x <span class="kw">in</span> data]) <span class="co"># Assuming (id, feature_vector)</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(X) <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> [(data[<span class="dv">0</span>][<span class="dv">0</span>], <span class="dv">0</span>)] <span class="co"># special handling for partitions with size 1</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    linked <span class="op">=</span> linkage(X, <span class="st">'ward'</span>)</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    threshold <span class="op">=</span> <span class="fl">0.5</span> <span class="op">*</span> np.<span class="bu">max</span>(linked[:,<span class="dv">2</span>]) <span class="co"># Adaptive Threshold</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    clusters <span class="op">=</span> fcluster(linked, threshold, criterion<span class="op">=</span><span class="st">'distance'</span>)</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [(data[i][<span class="dv">0</span>], clusters[i]<span class="op">-</span><span class="dv">1</span>) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(data))] <span class="co"># Return (id, cluster_id) pairs</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
<li><p><strong>Representative Selection:</strong> Select representative points from each local cluster. Common choices include centroids, medoids, or random sampling. This dramatically reduces the amount of data that needs to be compared in the global merge step.</p>
<p>The centroid can be computed as: <span class="math display">\[
\mu_k = \frac{1}{N_k} \sum_{x_i \in C_k} x_i
\]</span> where <span class="math inline">\(C_k\)</span> represents the <span class="math inline">\(k\)</span>-th cluster, <span class="math inline">\(N_k\)</span> is the number of points in the <span class="math inline">\(k\)</span>-th cluster, and <span class="math inline">\(x_i\)</span> are the data points belonging to that cluster.</p></li>
<li><p><strong>Distributed Distance Computation:</strong> Compute the distance matrix between the representative points from all local clusters. This is a crucial step for determining which clusters to merge globally. Due to the distributed nature, this involves exchanging representative points between nodes. The complexity of the distributed distance computation is <span class="math inline">\(O(M^2)\)</span>, where M is the total number of representatives.</p>
<p>The distance between clusters <span class="math inline">\(C_i\)</span> and <span class="math inline">\(C_j\)</span> can be calculated using various linkage criteria, such as:</p>
<ul>
<li><strong>Single Linkage:</strong> <span class="math inline">\(d(C_i, C_j) = \min_{x \in C_i, y \in C_j} d(x, y)\)</span></li>
<li><strong>Complete Linkage:</strong> <span class="math inline">\(d(C_i, C_j) = \max_{x \in C_i, y \in C_j} d(x, y)\)</span></li>
<li><strong>Average Linkage:</strong> <span class="math inline">\(d(C_i, C_j) = \frac{1}{|C_i||C_j|} \sum_{x \in C_i} \sum_{y \in C_j} d(x, y)\)</span></li>
<li><strong>Ward’s Linkage:</strong> Minimizes the increase in variance when merging clusters.</li>
</ul></li>
<li><p><strong>Global Cluster Merging:</strong> Iteratively merge the closest pairs of clusters based on the distributed distance matrix. This can be done using a priority queue to efficiently find the closest pairs. This step involves updating cluster assignments and the distance matrix. Broadcast the merge information to all nodes.</p></li>
<li><p><strong>Iteration and Convergence:</strong> Repeat steps 4 and 5 until a stopping criterion is met (e.g., a desired number of clusters is reached or the distance between the closest clusters exceeds a threshold).</p></li>
<li><p><strong>Assignment to Original Points:</strong> Assign each original data point to its corresponding global cluster. This can be done by broadcasting the final cluster assignments and having each node assign its local points based on the mappings from local clusters to global clusters.</p></li>
</ol>
</section>
<section id="special-considerations" class="level3">
<h3 class="anchored" data-anchor-id="special-considerations">4. Special Considerations</h3>
<ul>
<li><strong>Communication Costs:</strong> Minimizing communication between nodes is critical. Reducing the number of representative points and optimizing data serialization formats can help. Strategies like locality-sensitive hashing (LSH) can be used to reduce the number of distance computations needed.</li>
<li><strong>Memory Management:</strong> Each node must have enough memory to store its partition of the data and intermediate results. Techniques like using iterators instead of loading all data into memory at once can help.</li>
<li><strong>Synchronization:</strong> The global merge step requires synchronization between nodes. Using Spark’s built-in synchronization primitives or Dask’s task scheduling can help manage this.</li>
<li><strong>Load Balancing:</strong> Uneven data distribution can lead to load imbalance, where some nodes are overloaded while others are idle. Techniques like repartitioning the data or using dynamic load balancing can help.</li>
<li><strong>Choice of Linkage Criterion:</strong> The choice of linkage criterion (single, complete, average, Ward) can significantly impact the quality and runtime of the clustering. Ward’s linkage is generally preferred for its ability to produce more balanced clusters, but it can be more computationally expensive.</li>
<li><strong>Handling Outliers:</strong> Outliers can significantly affect agglomerative clustering. Techniques like outlier detection and removal or using robust distance metrics can help mitigate their impact.</li>
<li><strong>Scalability Bottlenecks:</strong> The global merge step can become a bottleneck as the number of clusters decreases. Exploring approximate merge strategies or using techniques like canopy clustering can help alleviate this.</li>
<li><strong>Approximation Techniques:</strong> For extremely large datasets, approximate versions of agglomerative clustering may be necessary. One approach is to use mini-batch agglomerative clustering, where only a random subset of the data is used in each iteration.</li>
<li><strong>Network Latency:</strong> Network latency can be a significant factor in distributed environments. Minimizing the number of small messages and using efficient data serialization formats can help.</li>
<li><strong>Handling High Dimensionality:</strong> For high-dimensional data, dimensionality reduction techniques like PCA or t-SNE can be applied before clustering to reduce the computational cost.</li>
</ul>
</section>
<section id="mathematical-considerations" class="level3">
<h3 class="anchored" data-anchor-id="mathematical-considerations">5. Mathematical Considerations</h3>
<p>The choice of distance metric is also crucial. Common distance metrics include:</p>
<ul>
<li><strong>Euclidean Distance:</strong> <span class="math display">\[d(x, y) = \sqrt{\sum_{i=1}^{n} (x_i - y_i)^2}\]</span></li>
<li><strong>Manhattan Distance:</strong> <span class="math display">\[d(x, y) = \sum_{i=1}^{n} |x_i - y_i|\]</span></li>
<li><strong>Cosine Similarity:</strong> <span class="math display">\[d(x, y) = 1 - \frac{x \cdot y}{||x|| \cdot ||y||}\]</span></li>
</ul>
<p>The computational complexity of calculating the distance matrix is <span class="math inline">\(O(n^2)\)</span> for <span class="math inline">\(n\)</span> data points. In the distributed setting, the distance calculation can be parallelized, but the communication cost must be carefully considered.</p>
</section>
<section id="alternatives" class="level3">
<h3 class="anchored" data-anchor-id="alternatives">6. Alternatives</h3>
<p>An alternative is to use scalable clustering algorithms that are inherently designed for distributed computing, such as:</p>
<ul>
<li><strong>k-means:</strong> Though not hierarchical, k-means can be efficiently parallelized and scaled to large datasets using Spark’s MLlib library.</li>
<li><strong>BIRCH (Balanced Iterative Reducing and Clustering using Hierarchies):</strong> BIRCH is designed to handle large datasets by summarizing the data into Clustering Feature (CF) trees, which can be built and merged in parallel.</li>
<li><strong>Canopy Clustering:</strong> Canopy clustering is a fast and scalable clustering algorithm that can be used as a pre-processing step to reduce the size of the dataset before applying agglomerative clustering.</li>
</ul>
<p>By carefully considering these aspects, a scalable and efficient implementation of agglomerative clustering in a distributed computing environment can be achieved. The selection of the appropriate techniques depends on the specific characteristics of the dataset and the available resources.</p>
<p><strong>How to Narrate</strong></p>
<p>Here’s a step-by-step guide on how to articulate this in an interview:</p>
<ol type="1">
<li><p><strong>Start with the Basics:</strong> Briefly define agglomerative clustering and its limitations in terms of scalability for large datasets.</p>
<ul>
<li>“Agglomerative clustering is a hierarchical clustering technique that starts with each data point as its own cluster and iteratively merges the closest clusters. While effective, its <span class="math inline">\(O(n^3)\)</span> or <span class="math inline">\(O(n^2 log(n))\)</span> complexity makes it difficult to scale to very large datasets on a single machine.”</li>
</ul></li>
<li><p><strong>Introduce Distributed Computing:</strong> Explain the general idea of using a distributed computing environment to address the scalability issue.</p>
<ul>
<li>“To handle large datasets, we can leverage distributed computing frameworks like Spark or Dask to parallelize the clustering process.”</li>
</ul></li>
<li><p><strong>Outline the Parallelization Strategy:</strong> Explain the core idea of data partitioning and local clustering, followed by a distributed merge step.</p>
<ul>
<li>“The main idea is to divide the data into partitions, perform local agglomerative clustering on each partition, and then merge the local clusters into a global clustering.”</li>
</ul></li>
<li><p><strong>Discuss Implementation Details (Spark):</strong> Provide a high-level overview of the implementation steps using Spark.</p>
<ul>
<li>“In Spark, we can load the data into an RDD or DataFrame, partition it across the cluster, and then apply a local agglomerative clustering algorithm to each partition.”</li>
<li>“After local clustering, we select representative points from each local cluster, compute the distance matrix between these representatives in a distributed manner, and then iteratively merge the closest clusters until a stopping criterion is met.”</li>
</ul></li>
<li><p><strong>Address Challenges and Considerations:</strong> Emphasize the importance of communication costs, memory management, synchronization, and load balancing.</p>
<ul>
<li>“Several challenges need to be addressed, including minimizing communication between nodes, managing memory usage on each node, ensuring synchronization during the merge step, and addressing potential load imbalances.”</li>
</ul></li>
<li><p><strong>Linkage Criterion and Distance Metrics:</strong> Mention the different linkage criteria and distance metrics, highlighting their impact on the clustering results.</p>
<ul>
<li>“The choice of linkage criterion (single, complete, average, Ward) can significantly affect the quality and runtime of the clustering. The distance metric (Euclidean, Manhattan, Cosine) also influences the results.”</li>
</ul></li>
<li><p><strong>Mention Approximation Techniques (if appropriate):</strong> If the interviewer seems interested in more advanced topics, mention approximation techniques like mini-batch agglomerative clustering or canopy clustering.</p>
<ul>
<li>“For extremely large datasets, approximate versions of agglomerative clustering may be necessary, such as mini-batch agglomerative clustering.”</li>
</ul></li>
<li><p><strong>Discuss Alternatives (if time allows):</strong> Briefly mention other scalable clustering algorithms like k-means, BIRCH, or Canopy Clustering.</p>
<ul>
<li>“Alternatively, we could consider using scalable clustering algorithms that are inherently designed for distributed computing, such as k-means or BIRCH.”</li>
</ul></li>
<li><p><strong>Mathematical notation:</strong> If you discuss the equations such as <span class="math display">\[d(x, y) = \sqrt{\sum_{i=1}^{n} (x_i - y_i)^2}\]</span>, you can say “The Euclidean distance which is the square root of the sum of squared differences”. If you are asked for a derivation, then feel free to derive the equation.</p></li>
<li><p><strong>Invite Questions:</strong> Conclude by inviting the interviewer to ask further questions.</p>
<ul>
<li>“That’s a high-level overview of how I would approach implementing distributed agglomerative clustering. I’m happy to answer any questions you have.”</li>
</ul></li>
</ol>
<p><strong>Communication Tips:</strong></p>
<ul>
<li><strong>Pace Yourself:</strong> Don’t rush through the explanation. Give the interviewer time to absorb the information.</li>
<li><strong>Use Visual Aids (if possible):</strong> If you are interviewing remotely, consider sharing a screen with diagrams or code snippets to illustrate your points.</li>
<li><strong>Check for Understanding:</strong> Periodically ask the interviewer if they have any questions or if you should elaborate on anything.</li>
<li><strong>Be Flexible:</strong> Adapt your answer to the interviewer’s level of understanding and interests. If they seem particularly interested in a specific aspect, focus on that.</li>
<li><strong>Maintain Eye Contact (if in person):</strong> This shows that you are engaged and confident.</li>
<li><strong>Use a Clear and Concise Language:</strong> Avoid jargon and technical terms that the interviewer may not be familiar with.</li>
</ul>
<p>By following these guidelines, you can effectively communicate your knowledge of distributed agglomerative clustering and demonstrate your senior-level expertise.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>