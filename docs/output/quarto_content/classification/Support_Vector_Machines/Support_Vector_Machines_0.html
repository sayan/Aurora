<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.41">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>support_vector_machines_0</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../../">
<script src="../../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../site_libs/quarto-html/quarto-syntax-highlighting-48ffa3e5b9d089919c6712c39e5b00f2.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../site_libs/bootstrap/bootstrap-a37d0bf9d509de95c1ba4621f20add8c.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<section id="question-1.-can-you-explain-the-basic-concept-of-support-vector-machines-svms-and-describe-what-is-meant-by-maximizing-the-margin" class="level2">
<h2 class="anchored" data-anchor-id="question-1.-can-you-explain-the-basic-concept-of-support-vector-machines-svms-and-describe-what-is-meant-by-maximizing-the-margin">Question: 1. Can you explain the basic concept of Support Vector Machines (SVMs) and describe what is meant by ‘maximizing the margin’?</h2>
<p><strong>Best Answer</strong></p>
<p>Support Vector Machines (SVMs) are powerful supervised learning algorithms primarily used for classification but applicable to regression tasks as well. The fundamental idea behind SVMs is to find the optimal hyperplane that separates data points belonging to different classes with the largest possible margin.</p>
<p>Here’s a breakdown:</p>
<ul>
<li><p><strong>Hyperplane:</strong> In an <span class="math inline">\(n\)</span>-dimensional space, a hyperplane is a flat affine subspace of dimension <span class="math inline">\(n-1\)</span>. For example, in a 2D space (with two features), a hyperplane is a line. In a 3D space, it’s a plane.</p></li>
<li><p><strong>Separating Hyperplane:</strong> A hyperplane that distinctly separates data points of different classes. Ideally, we want a hyperplane that not only separates the classes but does so with the largest possible “gap” between the closest points of each class to the hyperplane.</p></li>
<li><p><strong>Margin:</strong> The margin is defined as the distance between the separating hyperplane and the closest data points from either class. These closest data points are known as support vectors. Mathematically, if the hyperplane is defined by <span class="math inline">\(w^Tx + b = 0\)</span>, where <span class="math inline">\(w\)</span> is the normal vector to the hyperplane and <span class="math inline">\(b\)</span> is the bias, then the margin (<span class="math inline">\(M\)</span>) can be expressed as:</p>
<p><span class="math display">\[M = \frac{2}{||w||}\]</span></p>
<p>where <span class="math inline">\(||w||\)</span> represents the Euclidean norm (magnitude) of the weight vector <span class="math inline">\(w\)</span>.</p></li>
<li><p><strong>Support Vectors:</strong> These are the data points that lie closest to the decision boundary (hyperplane). They are the most difficult points to classify and directly influence the position and orientation of the hyperplane. In fact, once the support vectors are identified, all other training data points are irrelevant; the SVM decision boundary is defined <em>solely</em> by the support vectors.</p></li>
<li><p><strong>Maximizing the Margin:</strong> The core principle of SVM is to find the hyperplane that <em>maximizes</em> this margin <span class="math inline">\(M\)</span>. Maximizing the margin leads to better generalization performance because it creates a decision boundary that is as far away as possible from the data points, making it less sensitive to noise and outliers. A larger margin implies a lower risk of misclassifying unseen data.</p>
<p>Mathematically, the SVM optimization problem can be formulated as follows:</p>
<p>Minimize: <span class="math inline">\(\frac{1}{2} ||w||^2\)</span></p>
<p>Subject to: <span class="math inline">\(y_i(w^Tx_i + b) \ge 1\)</span> for all <span class="math inline">\(i\)</span></p>
<p>Where:</p>
<ul>
<li><span class="math inline">\(x_i\)</span> is the <span class="math inline">\(i\)</span>-th data point.</li>
<li><span class="math inline">\(y_i\)</span> is the class label for the <span class="math inline">\(i\)</span>-th data point (+1 or -1).</li>
<li><span class="math inline">\(w\)</span> is the weight vector defining the hyperplane.</li>
<li><span class="math inline">\(b\)</span> is the bias term.</li>
</ul>
<p>The constraint <span class="math inline">\(y_i(w^Tx_i + b) \ge 1\)</span> ensures that all data points are correctly classified and lie at least a distance of <span class="math inline">\(\frac{1}{||w||}\)</span> from the hyperplane. Minimizing <span class="math inline">\(\frac{1}{2} ||w||^2\)</span> is equivalent to maximizing the margin <span class="math inline">\(\frac{2}{||w||}\)</span>. This optimization problem is typically solved using quadratic programming techniques.</p></li>
<li><p><strong>Non-linearly Separable Data:</strong> In real-world scenarios, data is often not linearly separable. To handle such cases, SVMs use the “kernel trick.”</p>
<ul>
<li><p><strong>Kernel Trick:</strong> The kernel trick implicitly maps the original data into a higher-dimensional feature space where it <em>becomes</em> linearly separable. This mapping is achieved using kernel functions, such as:</p>
<ul>
<li><strong>Polynomial Kernel:</strong> <span class="math inline">\(K(x_i, x_j) = (x_i^Tx_j + c)^d\)</span> , where <span class="math inline">\(c\)</span> is a constant and <span class="math inline">\(d\)</span> is the degree of the polynomial.</li>
<li><strong>Radial Basis Function (RBF) Kernel:</strong> <span class="math inline">\(K(x_i, x_j) = exp(-\frac{||x_i - x_j||^2}{2\sigma^2})\)</span>, where <span class="math inline">\(\sigma\)</span> is a bandwidth parameter.</li>
<li><strong>Sigmoid Kernel:</strong> <span class="math inline">\(K(x_i, x_j) = tanh(\alpha x_i^Tx_j + c)\)</span>, where <span class="math inline">\(\alpha\)</span> and <span class="math inline">\(c\)</span> are constants.</li>
</ul></li>
</ul>
<p>The kernel function calculates the dot product of the data points in the higher-dimensional space without explicitly computing the transformation, which is computationally efficient. The RBF kernel is a popular choice because it can model complex decision boundaries, but requires careful tuning of the <span class="math inline">\(\sigma\)</span> parameter. The choice of kernel depends on the specific problem and the characteristics of the data.</p></li>
<li><p><strong>Soft Margin SVM:</strong> Even with kernel functions, some datasets may still have outliers or noisy data that prevent perfect separation. In such cases, a “soft margin” SVM is used.</p>
<ul>
<li><p><strong>Soft Margin:</strong> Soft margin SVMs allow for some misclassification of training data points. This is achieved by introducing slack variables (<span class="math inline">\(\xi_i\)</span>) into the optimization problem:</p>
<p>Minimize: <span class="math inline">\(\frac{1}{2} ||w||^2 + C \sum_{i=1}^{n} \xi_i\)</span></p>
<p>Subject to: <span class="math inline">\(y_i(w^Tx_i + b) \ge 1 - \xi_i\)</span> and <span class="math inline">\(\xi_i \ge 0\)</span> for all <span class="math inline">\(i\)</span></p>
<p>Where:</p>
<ul>
<li><span class="math inline">\(C\)</span> is a regularization parameter that controls the trade-off between maximizing the margin and minimizing the classification error. A large <span class="math inline">\(C\)</span> penalizes misclassifications more heavily, leading to a smaller margin but potentially better performance on the training data. A small <span class="math inline">\(C\)</span> allows for more misclassifications, resulting in a larger margin and potentially better generalization to unseen data.</li>
<li><span class="math inline">\(\xi_i\)</span> are slack variables that represent the amount by which the <span class="math inline">\(i\)</span>-th data point violates the margin constraint.</li>
</ul></li>
</ul>
<p>The soft margin SVM finds a balance between maximizing the margin and minimizing the number of misclassified points (or points within the margin). The regularization parameter <em>C</em> controls this trade-off. Cross-validation is often used to select the optimal value for <em>C</em>.</p></li>
</ul>
<p>In summary, SVMs aim to find the optimal separating hyperplane by maximizing the margin, which improves generalization performance. The use of kernel functions allows SVMs to handle non-linearly separable data, and soft margins provide robustness to outliers and noisy data. The choice of kernel and the tuning of parameters like <em>C</em> and kernel-specific parameters (e.g., <span class="math inline">\(\sigma\)</span> for RBF) are crucial for achieving optimal performance.</p>
<p><strong>How to Narrate</strong></p>
<p>Here’s a suggested way to explain SVMs and margin maximization in an interview:</p>
<ol type="1">
<li><strong>Start with the High-Level Idea:</strong>
<ul>
<li>“Support Vector Machines are supervised learning models primarily used for classification. The core idea is to find a hyperplane that best separates different classes of data.”</li>
</ul></li>
<li><strong>Introduce the Concept of a Hyperplane:</strong>
<ul>
<li>“Imagine a line in 2D that divides two groups of points. In higher dimensions, this becomes a hyperplane. An SVM aims to find the best such hyperplane.”</li>
</ul></li>
<li><strong>Explain Maximizing the Margin:</strong>
<ul>
<li>“The ‘best’ hyperplane isn’t just any line; it’s the one that maximizes the margin. The margin is the distance between the hyperplane and the closest data points from each class. You can visualize it as the widest street you can draw between the classes.”</li>
<li>“The goal is to maximize the margin. A larger margin usually leads to better generalization because it’s less sensitive to noise or slight variations in the data.”</li>
</ul></li>
<li><strong>Introduce Support Vectors:</strong>
<ul>
<li>“The data points that are closest to the hyperplane, and therefore define the margin, are called support vectors. They are crucial because they determine the position and orientation of the hyperplane.”</li>
<li>“Essentially, once you’ve identified the support vectors, you can discard the rest of the training data; they don’t affect the decision boundary.”</li>
</ul></li>
<li><strong>Mention the Mathematical Formulation (Optional, Gauge the Interviewer’s Interest):</strong>
<ul>
<li>“Mathematically, this can be formulated as an optimization problem where we minimize the norm of the weight vector <em>w</em> subject to constraints that ensure all data points are correctly classified and at least a certain distance from the hyperplane.”</li>
<li>If the interviewer seems interested, briefly show the optimization equations above and explain what each part of the equation signifies. Be ready to answer questions on the constraints.</li>
</ul></li>
<li><strong>Discuss Non-linearly Separable Data and the Kernel Trick:</strong>
<ul>
<li>“In many real-world problems, the data isn’t linearly separable. That’s where the kernel trick comes in. The kernel trick implicitly maps the data into a higher-dimensional space where it <em>is</em> linearly separable.”</li>
<li>“Common kernel functions include polynomial, RBF (radial basis function), and sigmoid kernels. The choice of kernel depends on the data and the problem you’re trying to solve.”</li>
</ul></li>
<li><strong>Explain Soft Margin SVMs:</strong>
<ul>
<li>“Sometimes, even with kernels, perfect separation isn’t possible or desirable, especially if you have outliers. In these cases, we use a soft margin SVM, which allows for some misclassifications.”</li>
<li>“We introduce slack variables and a regularization parameter <em>C</em> to control the trade-off between maximizing the margin and minimizing the classification error. Cross-validation can be used to find an optimal value for C.”</li>
</ul></li>
<li><strong>Summarize and Emphasize Generalization:</strong>
<ul>
<li>“In summary, SVMs aim to find the optimal separating hyperplane by maximizing the margin, which improves generalization performance. The kernel trick handles non-linearly separable data, and soft margins add robustness to outliers. Selecting appropriate kernels and hyperparameters are important for obtaining optimal results.”</li>
</ul></li>
</ol>
<p><strong>Communication Tips:</strong></p>
<ul>
<li><strong>Pace Yourself:</strong> Don’t rush through the explanation. Allow the interviewer time to process the information.</li>
<li><strong>Use Visual Aids (If Possible):</strong> If you’re in a virtual interview, consider sharing a simple diagram or drawing to illustrate the concept of the margin and support vectors.</li>
<li><strong>Check for Understanding:</strong> Periodically ask if the interviewer has any questions.</li>
<li><strong>Tailor the Depth:</strong> Adjust the level of detail based on the interviewer’s background and interest. If they are highly technical, you can delve deeper into the mathematical formulation. If they are more business-oriented, focus on the high-level concepts and benefits.</li>
<li><strong>Highlight Practical Considerations:</strong> Mention how you would choose a kernel, tune hyperparameters, and handle outliers in a real-world scenario. This demonstrates practical experience.</li>
<li><strong>Be Confident:</strong> Speak clearly and confidently, demonstrating that you have a solid understanding of SVMs.</li>
</ul>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>