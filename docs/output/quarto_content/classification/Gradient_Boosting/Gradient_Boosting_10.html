<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.41">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>gradient_boosting_10</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../../">
<script src="../../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../site_libs/quarto-html/quarto-syntax-highlighting-48ffa3e5b9d089919c6712c39e5b00f2.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../site_libs/bootstrap/bootstrap-a37d0bf9d509de95c1ba4621f20add8c.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<section id="question-11.-gradient-boosting-can-sometimes-struggle-with-noisy-or-messy-data.-how-would-you-preprocess-or-adjust-the-model-to-ensure-robust-performance-in-such-scenarios" class="level2">
<h2 class="anchored" data-anchor-id="question-11.-gradient-boosting-can-sometimes-struggle-with-noisy-or-messy-data.-how-would-you-preprocess-or-adjust-the-model-to-ensure-robust-performance-in-such-scenarios">Question: 11. Gradient boosting can sometimes struggle with noisy or messy data. How would you preprocess or adjust the model to ensure robust performance in such scenarios?</h2>
<p><strong>Best Answer</strong></p>
<p>Gradient boosting is a powerful ensemble method, but its performance can be significantly degraded by noisy or messy data. This sensitivity arises because gradient boosting iteratively fits models to the residuals (errors) of previous models. Outliers or noise can unduly influence these residuals, leading the algorithm to focus on fitting the noise rather than the underlying signal.</p>
<p>To ensure robust performance in such scenarios, I would consider a combination of preprocessing techniques and model adjustments.</p>
<p><strong>1. Preprocessing Techniques:</strong></p>
<ul>
<li><p><strong>Missing Value Imputation:</strong> Gradient boosting algorithms generally handle missing values, however explicit imputation can aid and improve performance.</p>
<ul>
<li><strong>Simple Imputation:</strong> Mean, median, or mode imputation can be used for numerical features. For categorical features, a constant value (e.g., “Missing”) or the most frequent category can be used. While simple, it introduces bias if data is <em>not</em> missing completely at random (MCAR).</li>
<li><strong>More Advanced Imputation:</strong> K-Nearest Neighbors (KNN) imputation or model-based imputation (e.g., using a regression model to predict missing values) can capture more complex relationships. KNN imputes missing values by averaging the values of the k-nearest neighbors. Model-based imputation involves training a predictive model to estimate the missing values based on other features.</li>
<li><strong>Missing Value Indicators:</strong> Creating a binary indicator feature for each column with missing values can allow the model to explicitly account for the missingness.</li>
</ul></li>
<li><p><strong>Outlier Handling:</strong></p>
<ul>
<li><p><strong>Winsorization:</strong> This involves capping extreme values at a predefined percentile (e.g., 95th percentile). Values above the 95th percentile are set to the 95th percentile value, and values below the 5th percentile are set to the 5th percentile value.</p></li>
<li><p><strong>Trimming:</strong> Removing outliers entirely. This should be done cautiously, as removing too much data can lead to a loss of information.</p></li>
<li><p><strong>Transformation:</strong> Logarithmic or Box-Cox transformations can reduce the impact of outliers by compressing the range of values. Log transformations are applicable for positive values, while Box-Cox transformation can be used with both positive and negative values. The Box-Cox transformation is defined as:</p>
<p><span class="math display">\[
x^{(\lambda)} =
\begin{cases}
    \frac{x^\lambda - 1}{\lambda} &amp; \text{if } \lambda \neq 0 \\
    \log(x) &amp; \text{if } \lambda = 0
\end{cases}
\]</span> where <span class="math inline">\(\lambda\)</span> is a transformation parameter.</p></li>
</ul></li>
<li><p><strong>Noise Filtering:</strong></p>
<ul>
<li><strong>Smoothing:</strong> Techniques like moving averages or Savitzky-Golay filters can smooth out noise in time series data. Savitzky-Golay filters perform a polynomial regression on a sliding window of data points.</li>
<li><strong>Wavelet Denoising:</strong> Wavelet transforms decompose the data into different frequency components, allowing for the removal of high-frequency noise.</li>
</ul></li>
<li><p><strong>Feature Engineering:</strong></p>
<ul>
<li><strong>Robust Feature Scaling:</strong> Use robust scalers like <code>RobustScaler</code> in scikit-learn, which are less sensitive to outliers than standard scalers. <code>RobustScaler</code> uses the median and interquartile range (IQR) for scaling, making it robust to outliers.</li>
<li><strong>Interaction Terms:</strong> Creating interaction terms (e.g., multiplying two features) can sometimes help the model capture non-linear relationships and reduce the impact of noise on individual features. However, this must be done judiciously, as adding too many interaction terms can lead to overfitting, especially with noisy data.</li>
</ul></li>
</ul>
<p><strong>2. Model Adjustments:</strong></p>
<ul>
<li><p><strong>Robust Loss Functions:</strong></p>
<ul>
<li><p><strong>Huber Loss:</strong> The Huber loss is less sensitive to outliers than the squared error loss. It is quadratic for small errors and linear for large errors. Let <span class="math inline">\(y_i\)</span> be the true value and <span class="math inline">\(\hat{y}_i\)</span> be the predicted value. Then the Huber loss <span class="math inline">\(L_\delta\)</span> is defined as:</p>
<p><span class="math display">\[
L_\delta(y_i, \hat{y}_i) =
\begin{cases}
    \frac{1}{2} (y_i - \hat{y}_i)^2 &amp; \text{for } |y_i - \hat{y}_i| \leq \delta \\
    \delta |y_i - \hat{y}_i| - \frac{1}{2} \delta^2 &amp; \text{otherwise}
\end{cases}
\]</span> Here, <span class="math inline">\(\delta\)</span> is a hyperparameter that controls the sensitivity to outliers.</p></li>
<li><p><strong>Quantile Loss:</strong> Quantile loss focuses on predicting a specific quantile of the target variable. It is robust to outliers because it only considers whether the prediction is above or below the specified quantile. The quantile loss <span class="math inline">\(L_\tau\)</span> for quantile <span class="math inline">\(\tau \in (0, 1)\)</span> is defined as: <span class="math display">\[
L_\tau(y_i, \hat{y}_i) =
\begin{cases}
    \tau (y_i - \hat{y}_i) &amp; \text{if } y_i \geq \hat{y}_i \\
    (1 - \tau) (\hat{y}_i - y_i) &amp; \text{if } y_i &lt; \hat{y}_i
\end{cases}
\]</span></p></li>
</ul></li>
<li><p><strong>Regularization:</strong></p>
<ul>
<li><strong>L1 Regularization (Lasso):</strong> Encourages sparsity in the model, effectively performing feature selection by shrinking the coefficients of less important features to zero.</li>
<li><strong>L2 Regularization (Ridge):</strong> Shrinks the coefficients of all features, reducing the model’s sensitivity to noise and preventing overfitting.</li>
<li><strong>Early Stopping:</strong> Monitoring the performance on a validation set and stopping training when the performance starts to degrade can prevent the model from overfitting to the noise.</li>
</ul></li>
<li><p><strong>Subsampling:</strong></p>
<ul>
<li><strong>Stochastic Gradient Boosting:</strong> Using only a random subset of the data for each iteration can reduce the impact of outliers. This is similar to bagging and introduces randomness that helps prevent overfitting.</li>
<li><strong>Feature Subsampling:</strong> Randomly selecting a subset of features for each tree can also reduce the impact of noisy features.</li>
</ul></li>
<li><p><strong>Tree-Specific Parameters:</strong></p>
<ul>
<li><strong>Minimum Samples per Leaf:</strong> Increasing the minimum number of samples required to be in a leaf node can prevent the model from creating very specific rules based on noisy data points.</li>
<li><strong>Maximum Depth:</strong> Limiting the maximum depth of the trees can prevent the model from overfitting to the noise.</li>
<li><strong>Learning Rate:</strong> Using a smaller learning rate can make the model more robust to noise by slowing down the learning process and preventing it from focusing too much on individual noisy data points.</li>
</ul></li>
<li><p><strong>Robust Boosting Algorithms:</strong></p>
<ul>
<li><strong>M-estimation based Gradient Boosting:</strong> This approach replaces the standard least squares loss function with a robust M-estimator that is less sensitive to outliers.</li>
</ul></li>
</ul>
<p><strong>3. Evaluation:</strong></p>
<ul>
<li><strong>Use appropriate evaluation metrics:</strong> Instead of relying solely on metrics like mean squared error (MSE), which are sensitive to outliers, use more robust metrics like mean absolute error (MAE) or Huber loss.</li>
<li><strong>Cross-validation:</strong> Use cross-validation to estimate the model’s performance on unseen data. This helps to ensure that the model is not overfitting to the noise in the training data.</li>
</ul>
<p><strong>Example Implementation (Python - scikit-learn):</strong></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.ensemble <span class="im">import</span> GradientBoostingRegressor</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.model_selection <span class="im">import</span> train_test_split</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> mean_absolute_error</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.preprocessing <span class="im">import</span> RobustScaler</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Assuming you have a pandas DataFrame 'df' with features and target variable</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="co"># and some columns have missing values or outliers</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="co"># 1. Imputation (example: median imputation)</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> df.columns:</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> df[col].isnull().<span class="bu">any</span>():</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>        df[col] <span class="op">=</span> df[col].fillna(df[col].median())</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="co"># 2. Outlier Handling (example: winsorization)</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> winsorize(series, lower_percentile<span class="op">=</span><span class="fl">0.05</span>, upper_percentile<span class="op">=</span><span class="fl">0.95</span>):</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    lower_bound <span class="op">=</span> series.quantile(lower_percentile)</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    upper_bound <span class="op">=</span> series.quantile(upper_percentile)</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> series.clip(lower_bound, upper_bound)</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> df.select_dtypes(include<span class="op">=</span>[<span class="st">'number'</span>]).columns:  <span class="co"># Only numerical columns</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>    df[col] <span class="op">=</span> winsorize(df[col])</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a><span class="co"># 3. Feature Scaling (RobustScaler)</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>numerical_cols <span class="op">=</span> df.select_dtypes(include<span class="op">=</span>[<span class="st">'number'</span>]).columns</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>scaler <span class="op">=</span> RobustScaler()</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>df[numerical_cols] <span class="op">=</span> scaler.fit_transform(df[numerical_cols])</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a><span class="co"># 4. Split data</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> df.drop(<span class="st">'target'</span>, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> df[<span class="st">'target'</span>]</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>X_train, X_test, y_train, y_test <span class="op">=</span> train_test_split(X, y, test_size<span class="op">=</span><span class="fl">0.2</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a><span class="co"># 5. Model Training with Huber loss and regularization</span></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>gbr <span class="op">=</span> GradientBoostingRegressor(loss<span class="op">=</span><span class="st">'huber'</span>,</span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>                                learning_rate<span class="op">=</span><span class="fl">0.05</span>,</span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>                                n_estimators<span class="op">=</span><span class="dv">100</span>,</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>                                max_depth<span class="op">=</span><span class="dv">3</span>,</span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>                                subsample<span class="op">=</span><span class="fl">0.8</span>,</span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>                                random_state<span class="op">=</span><span class="dv">42</span>)  <span class="co"># added subsample</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>gbr.fit(X_train, y_train)</span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a><span class="co"># 6. Evaluation with MAE</span></span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>y_pred <span class="op">=</span> gbr.predict(X_test)</span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>mae <span class="op">=</span> mean_absolute_error(y_test, y_pred)</span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Mean Absolute Error: </span><span class="sc">{</span>mae<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>In summary,</strong> dealing with noisy data in gradient boosting requires a multi-faceted approach, combining careful preprocessing, robust model configurations, and appropriate evaluation metrics. The specific techniques to use will depend on the nature of the data and the specific characteristics of the noise. Iterative experimentation and validation are crucial to determine the optimal combination of techniques for a given problem.</p>
<p><strong>How to Narrate</strong></p>
<p>Here’s a guide on how to articulate this in an interview:</p>
<ol type="1">
<li><p><strong>Start with the problem:</strong> “Gradient boosting can be sensitive to noisy data because it iteratively fits models to residuals. Outliers can disproportionately influence these residuals, causing the model to fit the noise.” ( <em>sets context, shows understanding of the core issue</em>).</p></li>
<li><p><strong>Outline your approach:</strong> “To address this, I would employ a combination of preprocessing techniques and model adjustments. This usually involves 1. Preprocessing, 2. Model adjustments, 3. Evaluation”. (<em>provides a roadmap of the answer</em>).</p></li>
<li><p><strong>Preprocessing - Imputation:</strong> “First, I would handle missing data. While Gradient Boosting can handle missing values natively, explicitly imputing the values can assist the models performance. Simple methods such as mean and median can be used, and more advanced techniques like KNN imputation, or indicators for missingness can also be used” (<em>explain the importance of missing values and describe different types of methods to handle it</em>)</p></li>
<li><p><strong>Preprocessing - Outlier Handling:</strong> “Next, I’d address outliers. Winsorization is one method of capping the extreme values. Transformation methods such as logarithm or Box-Cox can also reduce the impact of the outliers” (<em>explain different types of methods to handle outliers</em>).</p></li>
<li><p><strong>Preprocessing - Noise Filtering</strong>: “Then, I would consider using methods to filter the noise such as using smoothing techniques like moving averages and Savitzky-Golay filters. Wavelet Denoising is also a potential candidate” (<em>explain the methods to handle noisy data</em>)</p></li>
<li><p><strong>Preprocessing - Feature Engineering:</strong> “Next, I would perform some feature engineering using techniques such as Robust Scaling. I could also engineer interaction terms if needed” (<em>explain the feature engineering methods that can assist the robustness of gradient boosting</em>).</p></li>
<li><p><strong>Model Adjustments - Robust Loss Functions:</strong> “For model adjustments, I would explore robust loss functions like Huber loss or quantile loss, which are less sensitive to outliers than squared error. I would mention the formula here and briefly explain how the Huber loss works for different error ranges and how this makes it robust.” (<em>Explain what a robust loss function is and describe one, possibly two types of robust losses. For Huber loss, briefly describe the formula and how it applies to different error ranges</em>).</p>
<ul>
<li>“<em>When discussing the Huber loss formula, write the formula on the whiteboard (if available) or simply say: ‘The Huber loss has a quadratic part for small errors and a linear part for large errors, controlled by a delta parameter.’“</em></li>
</ul></li>
<li><p><strong>Model Adjustments - Regularization:</strong> “I’d also use regularization techniques like L1 or L2 regularization to prevent overfitting.”</p></li>
<li><p><strong>Model Adjustments - Subsampling:</strong> “Additionally, subsampling techniques, like stochastic gradient boosting or feature subsampling, can reduce the impact of outliers and noisy features.”</p></li>
<li><p><strong>Model Adjustments - Tree Parameters:</strong> “Tuning tree-specific parameters such as minimum samples per leaf and maximum depth can also prevent overfitting to noise.”</p></li>
<li><p><strong>Evaluation:</strong> “Finally, when evaluating the model, I would use robust metrics like mean absolute error (MAE) instead of mean squared error (MSE), and use cross-validation to ensure the model generalizes well to unseen data.” (<em>Reinforce the importance of Evaluation metrics.</em>)</p></li>
<li><p><strong>Summarize:</strong> “In summary, improving the robustness of gradient boosting on noisy data involves a combination of careful preprocessing, robust model configurations, and appropriate evaluation. The specific techniques will depend on the data, and experimentation is key.” (<em>Provides a concise recap and emphasizes experimentation</em>)</p></li>
</ol>
<p><strong>Communication Tips:</strong></p>
<ul>
<li><strong>Pace Yourself:</strong> Don’t rush through the answer. Take your time to explain each concept clearly.</li>
<li><strong>Use Visual Aids:</strong> If a whiteboard is available, use it to write down key equations or diagrams to illustrate your points.</li>
<li><strong>Check for Understanding:</strong> Pause occasionally and ask the interviewer if they have any questions or if they would like you to elaborate on a specific point.</li>
<li><strong>Be Concise:</strong> While it’s important to be thorough, avoid getting bogged down in unnecessary details. Focus on the key concepts and techniques.</li>
<li><strong>Be Confident:</strong> Present your answer with confidence and enthusiasm. Show that you are knowledgeable and passionate about the topic.</li>
<li><strong>Tailor to Audience:</strong> Adapt your language and level of detail to the interviewer’s background. If the interviewer seems less familiar with the topic, provide more basic explanations. If they seem more knowledgeable, delve into more advanced details.</li>
<li><strong>Focus on Practicality:</strong> Whenever possible, relate the concepts to real-world applications and practical considerations. This will demonstrate that you not only understand the theory but also know how to apply it in practice.</li>
<li><strong>Engage the interviewer</strong>: Rather than just delivering a monologue, try to create a conversation. Ask the interviewer for their thoughts or experiences with similar problems. This shows that you are interested in their perspective and can collaborate effectively.</li>
</ul>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>